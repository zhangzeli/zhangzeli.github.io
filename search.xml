<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Yarn</title>
      <link href="/bigdata/hadoop/yarn_1/"/>
      <url>/bigdata/hadoop/yarn_1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="修改yarn-配置"><a href="#修改yarn-配置" class="headerlink" title="修改yarn 配置"></a>修改yarn 配置</h1><p>yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>&#123;hostname&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mapred-site.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.app.mapreduce.am.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=/opt/bigdata/hadoop-3.3.1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.map.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=/opt/bigdata/hadoop-3.3.1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.reduce.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=/opt/bigdata/hadoop-3.3.1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="博主主页"><a href="#博主主页" class="headerlink" title="博主主页"></a><strong><a href="http://www.zeze.info">博主主页</a></strong></h1><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> -[大数据, hadoop,yarn] </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Post</title>
      <link href="/bigdata/hadoop/hadoop_2/"/>
      <url>/bigdata/hadoop/hadoop_2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简单的word-count"><a href="#简单的word-count" class="headerlink" title="简单的word count"></a>简单的word count</h1><p>maven 依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>map</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountMap</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>, <span class="title">Text</span>,<span class="title">LongWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongWritable ONE =<span class="keyword">new</span> LongWritable(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Text WORD = <span class="keyword">new</span> Text();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Object key, Text value, Mapper&lt;Object, Text, Text, LongWritable&gt;.Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(value.toString());</span><br><span class="line">        <span class="keyword">while</span> (st.hasMoreTokens())&#123;</span><br><span class="line">            WORD.set(st.nextToken());</span><br><span class="line">            context.write(WORD,ONE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>reduce </p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountReduce</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">LongWritable</span>, <span class="title">Text</span>,<span class="title">LongWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongWritable RESULT = <span class="keyword">new</span> LongWritable();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text word, Iterable&lt;LongWritable&gt; values, Reducer&lt;Text, LongWritable, Text, LongWritable&gt;.Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (LongWritable value : values) &#123;</span><br><span class="line">            sum +=value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        RESULT.set(sum);</span><br><span class="line">        context.write(word,RESULT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(conf, <span class="string">"word count"</span>);</span><br><span class="line">        job.setJarByClass(Client<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapperClass(WordCountMap<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setCombinerClass(WordCountReduce<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setReducerClass(WordCountReduce<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(LongWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">        System.exit(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="简单的word-count排序"><a href="#简单的word-count排序" class="headerlink" title="简单的word count排序"></a>简单的word count排序</h1><p>将上一步的输出作为这次的输入</p><p>SortMap</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortMap</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>,<span class="title">LongWritable</span>, <span class="title">Text</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongWritable KEY =<span class="keyword">new</span> LongWritable(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Text VALUE = <span class="keyword">new</span> Text();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Object key, Text value, Mapper&lt;Object, Text, LongWritable, Text&gt;.Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        String s = value.toString();</span><br><span class="line">        String[] s1 = s.split(<span class="string">"\t"</span>);</span><br><span class="line">        KEY.set(Integer.valueOf(s1[<span class="number">1</span>]));</span><br><span class="line">        VALUE.set(s1[<span class="number">0</span>]);</span><br><span class="line">        context.write(KEY,VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SortReduce</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.<span class="type">LongWritable</span>;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.<span class="type">Text</span>;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.<span class="type">Reducer</span>;</span><br><span class="line"><span class="keyword">import</span> java.io.<span class="type">IOException</span>;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SortReduce</span> <span class="keyword">extends</span> <span class="title">Reducer&lt;LongWritable</span>, <span class="title">Text</span>,<span class="title">LongWritable</span>, <span class="title">Text&gt;</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void reduce(<span class="type">LongWritable</span> key, <span class="type">Iterable</span>&lt;<span class="type">Text</span>&gt; values, <span class="type">Reducer</span>&lt;<span class="type">LongWritable</span>, <span class="type">Text</span>, <span class="type">LongWritable</span>, <span class="type">Text</span>&gt;.<span class="type">Context</span> context) <span class="keyword">throws</span> <span class="type">IOException</span>, <span class="type">InterruptedException</span> &#123;</span><br><span class="line">        context.write(key,values.iterator().next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SortClient</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> E`xception </span>&#123;</span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(conf, <span class="string">" sort word count"</span>);</span><br><span class="line">        job.setJarByClass(SortClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapperClass(SortMap<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setCombinerClass(SortReduce<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setReducerClass(SortReduce<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputKeyClass(LongWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">        System.exit(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="博主主页"><a href="#博主主页" class="headerlink" title="博主主页"></a><strong><a href="http://www.zeze.info">博主主页</a></strong></h1><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> -[大数据, hadoop] </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop</title>
      <link href="/bigdata/hadoop/hadoop_1/"/>
      <url>/bigdata/hadoop/hadoop_1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html" target="_blank" rel="external nofollow noopener noreferrer">apache hadoop </a></p><p>Setup passphraseless ssh</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh-keygen -t rsa -P <span class="string">''</span> -f ~<span class="regexp">/.ssh/id</span>_rsa</span><br><span class="line"><span class="variable">$ </span>cat ~<span class="regexp">/.ssh/id</span>_rsa.pub &gt;&gt; ~<span class="regexp">/.ssh/authorized</span>_keys</span><br><span class="line"><span class="variable">$ </span>chmod 0600 ~<span class="regexp">/.ssh/authorized</span>_keys</span><br></pre></td></tr></table></figure><h2 id="stand-alone"><a href="#stand-alone" class="headerlink" title="stand-alone"></a>stand-alone</h2><p>不用启动hadoop 进程 可以直接运行</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> <span class="built_in">input</span></span><br><span class="line">$ <span class="keyword">cp</span> etc/hadoop/*.xml <span class="built_in">input</span></span><br><span class="line">$ bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-<span class="number">3.3</span>.<span class="number">1</span>.jar <span class="keyword">grep</span> <span class="built_in">input</span> output <span class="string">'dfs[a-z.]+'</span></span><br><span class="line">$ <span class="keyword">cat</span> output/*</span><br></pre></td></tr></table></figure><h2 id="Pseudo-Distributed-Operation"><a href="#Pseudo-Distributed-Operation" class="headerlink" title="Pseudo-Distributed Operation"></a>Pseudo-Distributed Operation</h2><p>伪集群部署</p><p>etc/hadoop/core-site.xml:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>etc/hadoop/hdfs-site.xml:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim hadoop-env.sh</span><br><span class="line"><span class="built_in">export</span> HDFS_NAMENODE_USER=root</span><br><span class="line"><span class="built_in">export</span> HDFS_DATANODE_USER=root</span><br><span class="line"><span class="built_in">export</span> HDFS_SECONDARYNAMENODE_USER=root</span><br><span class="line"><span class="built_in">export</span> YARN_RESOURCEMANAGER_USER=root</span><br><span class="line"><span class="built_in">export</span> YARN_NODEMANAGER_USER=root</span><br></pre></td></tr></table></figure><p>Format the filesystem:</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bin/hdfs </span>namenode -format</span><br></pre></td></tr></table></figure><p>Start NameNode daemon and DataNode daemon:</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">sbin/<span class="literal">start</span>-dfs.sh</span><br></pre></td></tr></table></figure><p><a href="./hadoop_2">下一章word count 程序</a></p><p><a href="https://activity.huaweicloud.com/828_promotion/index.html?fromacct=32419f0e-871e-4fe8-b461-cff4dfe872a0&utm_source=enpsMTUzMTE0ODQzNTc==&utm_medium=cps&utm_campaign=201905" target="_blank" rel="external nofollow noopener noreferrer">828企业上云节，多款产品限时特价</a></p><h1 id="博主主页"><a href="#博主主页" class="headerlink" title="博主主页"></a><strong><a href="http://www.zeze.info">博主主页</a></strong></h1><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> -[大数据, hadoop] </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程：CountDownLatch、CyclicBarrier和Semaphore</title>
      <link href="/java/concurrent/concurrent/"/>
      <url>/java/concurrent/concurrent/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java并发编程：CountDownLatch、CyclicBarrier和Semaphor-转载"><a href="#Java并发编程：CountDownLatch、CyclicBarrier和Semaphor-转载" class="headerlink" title="Java并发编程：CountDownLatch、CyclicBarrier和Semaphor(转载)"></a>Java并发编程：CountDownLatch、CyclicBarrier和Semaphor(转载)</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">一<span class="selector-class">.CountDownLatch</span>用法</span><br><span class="line">二<span class="selector-class">.CyclicBarrier</span>用法</span><br><span class="line">三<span class="selector-class">.Semaphore</span>用法</span><br></pre></td></tr></table></figure><p><a href="http://www.cnblogs.com/dolphin0520/p/3920397.html" target="_blank" rel="external nofollow noopener noreferrer">原文链接</a></p><h1 id="一-CountDownLatch用法"><a href="#一-CountDownLatch用法" class="headerlink" title="一.CountDownLatch用法"></a>一.CountDownLatch用法</h1><blockquote><p>CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。CountDownLatch类只提供了一个构造器</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;  &#125;;  <span class="comment">//参数count为计数值</span></span><br></pre></td></tr></table></figure><blockquote><p>然后下面这3个方法是CountDownLatch类中最重要的方法：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;  </span><br><span class="line"><span class="comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;  </span><br><span class="line"> <span class="comment">//将count值减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123; &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>下面看一个例子大家就清楚CountDownLatch的用法了：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">         <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;;</span><br><span class="line">         &#125;.start();</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">                     Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                     System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">                     latch.countDown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;;</span><br><span class="line">         &#125;.start();</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             System.out.println(<span class="string">"等待2个子线程执行完毕..."</span>);</span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(<span class="string">"2个子线程已经执行完毕"</span>);</span><br><span class="line">            System.out.println(<span class="string">"继续执行主线程"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程Thread-0正在执行</span><br><span class="line">线程Thread-1正在执行</span><br><span class="line">等待2个子线程执行完毕...</span><br><span class="line">线程Thread-0执行完毕</span><br><span class="line">线程Thread-1执行完毕</span><br><span class="line">2个子线程已经执行完毕</span><br><span class="line">继续执行主线程</span><br></pre></td></tr></table></figure><h1 id="二-CyclicBarrier用"><a href="#二-CyclicBarrier用" class="headerlink" title="二.CyclicBarrier用"></a>二.CyclicBarrier用</h1><blockquote><p>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。CyclicBarrier类位于java.util.concurrent包下，CyclicBarrier提供2个构造器：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参数parties指让多少个线程或者任务等待至barrier状态；参数barrierAction为当这些线程都达到barrier状态时会执行的内容。<br>然后CyclicBarrier中最重要的方法就是await方法，它有2个重载版本：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span><span class="keyword">throws</span> InterruptedException,BrokenBarrierException,TimeoutException </span>&#123; &#125;;</span><br></pre></td></tr></table></figure><p>第一个版本比较常用，用来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务；<br>第二个版本是让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。<br>下面举几个例子就明白了：<br>假若有若干个线程都要进行写数据操作，并且只有所有线程都完成写数据操作之后，这些线程才能继续做后面的事情，此时就可以利用CyclicBarrier了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier  = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"正在写入数据..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);      <span class="comment">//以睡眠来模拟写入数据操作</span></span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(BrokenBarrierException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"所有线程写入完毕，继续处理其他任务..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程Thread-0正在写入数据...</span><br><span class="line">线程Thread-3正在写入数据...</span><br><span class="line">线程Thread-2正在写入数据...</span><br><span class="line">线程Thread-1正在写入数据...</span><br><span class="line">线程Thread-2写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-0写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-3写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-1写入数据完毕，等待其他线程写入完毕</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br></pre></td></tr></table></figure><p>从上面输出结果可以看出，每个写入线程执行完写数据操作之后，就在等待其他线程写入操作完毕。<br>当所有线程线程写入操作完毕之后，所有线程就继续进行后续的操作了。<br>如果说想在所有线程写入操作完之后，进行额外的其他操作可以为CyclicBarrier提供Runnable参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier  = <span class="keyword">new</span> CyclicBarrier(N,<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"当前线程"</span>+Thread.currentThread().getName());   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"正在写入数据..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);      <span class="comment">//以睡眠来模拟写入数据操作</span></span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(BrokenBarrierException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"所有线程写入完毕，继续处理其他任务..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程Thread-0正在写入数据...</span><br><span class="line">线程Thread-1正在写入数据...</span><br><span class="line">线程Thread-2正在写入数据...</span><br><span class="line">线程Thread-3正在写入数据...</span><br><span class="line">线程Thread-0写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-1写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-2写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-3写入数据完毕，等待其他线程写入完毕</span><br><span class="line">当前线程Thread-3</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br><span class="line">所有线程写入完毕，继续处理其他任务...</span><br></pre></td></tr></table></figure><p>从结果可以看出，当四个线程都到达barrier状态后，会从四个线程中选择一个线程去执行Runnable。<br>下面看一下为await指定时间的效果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier  = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;N-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"正在写入数据..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);      <span class="comment">//以睡眠来模拟写入数据操作</span></span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await(<span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(BrokenBarrierException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"所有线程写入完毕，继续处理其他任务..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程Thread-0正在写入数据...</span><br><span class="line">线程Thread-2正在写入数据...</span><br><span class="line">线程Thread-1正在写入数据...</span><br><span class="line">线程Thread-2写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-0写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-1写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-3正在写入数据...</span><br><span class="line">java.util.concurrent.TimeoutException</span><br><span class="line">Thread-1所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-0所有线程写入完毕，继续处理其他任务...</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(Unknown Source)</span><br><span class="line">    at com.cxh.test1.Test$Writer.run(Test.java:58)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(Unknown Source)</span><br><span class="line">    at com.cxh.test1.Test$Writer.run(Test.java:58)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(Unknown Source)</span><br><span class="line">    at com.cxh.test1.Test$Writer.run(Test.java:58)</span><br><span class="line">Thread-2所有线程写入完毕，继续处理其他任务...</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">线程Thread-3写入数据完毕，等待其他线程写入完毕</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(Unknown Source)</span><br><span class="line">    at com.cxh.test1.Test$Writer.run(Test.java:58)</span><br><span class="line">Thread-3所有线程写入完毕，继续处理其他任务...</span><br></pre></td></tr></table></figure><p>上面的代码在main方法的for循环中，故意让最后一个线程启动延迟，因为在前面三个线程都达到barrier之后，等待了指定的时间发现第四个线程还没有达到barrier，就抛出异常并继续执行后面的任务。<br>另外CyclicBarrier是可以重用的，看下面这个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier  = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">25000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"CyclicBarrier重用"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"正在写入数据..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);      <span class="comment">//以睡眠来模拟写入数据操作</span></span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line">             </span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(BrokenBarrierException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"所有线程写入完毕，继续处理其他任务..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程Thread-0正在写入数据...</span><br><span class="line">线程Thread-1正在写入数据...</span><br><span class="line">线程Thread-3正在写入数据...</span><br><span class="line">线程Thread-2正在写入数据...</span><br><span class="line">线程Thread-1写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-3写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-2写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-0写入数据完毕，等待其他线程写入完毕</span><br><span class="line">Thread-0所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-3所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-1所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-2所有线程写入完毕，继续处理其他任务...</span><br><span class="line">CyclicBarrier重用</span><br><span class="line">线程Thread-4正在写入数据...</span><br><span class="line">线程Thread-5正在写入数据...</span><br><span class="line">线程Thread-6正在写入数据...</span><br><span class="line">线程Thread-7正在写入数据...</span><br><span class="line">线程Thread-7写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-5写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-6写入数据完毕，等待其他线程写入完毕</span><br><span class="line">线程Thread-4写入数据完毕，等待其他线程写入完毕</span><br><span class="line">Thread-4所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-5所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-6所有线程写入完毕，继续处理其他任务...</span><br><span class="line">Thread-7所有线程写入完毕，继续处理其他任务...</span><br></pre></td></tr></table></figure><p>从执行结果可以看出，在初次的4个线程越过barrier状态后，又可以用来进行新一轮的使用。而CountDownLatch无法进行重复使用。</p><h1 id="三-Semaphore用法"><a href="#三-Semaphore用法" class="headerlink" title="三.Semaphore用法"></a>三.Semaphore用法</h1><p>Semaphore翻译成字面意思为 信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</p><p>Semaphore类位于java.util.concurrent包下，它提供了2个构造器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;          <span class="comment">//参数permits表示许可数目，即同时可以允许多少线程进行访问</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;    <span class="comment">//这个多了一个参数fair表示是否是公平的，即等待时间越久的越先获取许可</span></span><br><span class="line">    sync = (fair)? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面说一下Semaphore类中比较重要的几个方法，首先是acquire()、release()方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  &#125;     <span class="comment">//获取一个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;    <span class="comment">//获取permits个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123; &#125;          <span class="comment">//释放一个许可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123; &#125;    <span class="comment">//释放permits个许可</span></span><br></pre></td></tr></table></figure><p>acquire()用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。<br>release()用来释放许可。注意，在释放许可之前，必须先获获得许可。<br>这4个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123; &#125;;    <span class="comment">//尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;  <span class="comment">//尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123; &#125;; <span class="comment">//尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;; <span class="comment">//尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</span></span><br></pre></td></tr></table></figure><p>另外还可以通过availablePermits()方法得到可用的许可数目。<br>下面通过一个例子来看一下Semaphore的具体使用：<br>假若一个工厂有5台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过Semaphore来实现:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">8</span>;            <span class="comment">//工人数</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>); <span class="comment">//机器数目</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            <span class="keyword">new</span> Worker(i,semaphore).start();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> num,Semaphore semaphore)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(<span class="string">"工人"</span>+<span class="keyword">this</span>.num+<span class="string">"占用一个机器在生产..."</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"工人"</span>+<span class="keyword">this</span>.num+<span class="string">"释放出机器"</span>);</span><br><span class="line">                semaphore.release();           </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">工人<span class="number">0</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">1</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">2</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">4</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">5</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">0</span>释放出机器</span><br><span class="line">工人<span class="number">2</span>释放出机器</span><br><span class="line">工人<span class="number">3</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">7</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">4</span>释放出机器</span><br><span class="line">工人<span class="number">5</span>释放出机器</span><br><span class="line">工人<span class="number">1</span>释放出机器</span><br><span class="line">工人<span class="number">6</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">3</span>释放出机器</span><br><span class="line">工人<span class="number">7</span>释放出机器</span><br><span class="line">工人<span class="number">6</span>释放出机器</span><br></pre></td></tr></table></figure><p>下面对上面说的三个辅助类进行一个总结：<br>　　1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：<br>　　　　CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；<br>　　　　而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；<br>　　　　另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。<br>　　2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。</p><h1 id="例如这样场景：文件每一行是个url，记录有多少个返回结果是200成功，有多少是其他状态码。"><a href="#例如这样场景：文件每一行是个url，记录有多少个返回结果是200成功，有多少是其他状态码。" class="headerlink" title="例如这样场景：文件每一行是个url，记录有多少个返回结果是200成功，有多少是其他状态码。"></a>例如这样场景：文件每一行是个url，记录有多少个返回结果是200成功，有多少是其他状态码。</h1><ul><li>文件很大，还可能经常更换，不知道文件一共有多少行。</li><li>需要尽快完成任务，单线程就很拉胯，需要用多线程。<br>一个重点是线程池该如何定制参数，另一个重点则是如何知道所有任务结束了。</li></ul><h2 id="线程池参数设定"><a href="#线程池参数设定" class="headerlink" title="线程池参数设定"></a>线程池参数设定</h2><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">用<span class="keyword">new</span><span class="type">CacheThreadPool</span>或者<span class="keyword">new</span><span class="type">FixedThreadPool</span>都是不合适的，前者会一直创建新线程直到创建int最大值个线程，之后再有线程就会抛异常然后程序就炸了。后者可以创建固定的线程数，但是如果超过这个数就会扔到队列LinkedBlockingQueue，这个队列也是最大只能int最大值个，仍有上面的问题。</span><br><span class="line"></span><br><span class="line">在当前场景下，我们可以对<span class="keyword">new</span><span class="type">CacheThreadPool</span>或者<span class="keyword">new</span><span class="type">FixedThreadPool</span>进行结合，模仿后者创建固定个数的线程，但是队列我们采用前者的空队列，这时候会在到达指定个数后reject，对于reject策略我们可以使用ThreadPoolExecutor.CallerRunsPolicy。这样在超出线程个数的时候，就会由创建线程的线程(我们这里就是主线程)来执行当前任务，因为<span class="string">"生产者"</span>去帮忙<span class="string">"消费"</span>了，所以生产任务就暂停了，这样起到一个负反馈的作用，使在工作的线程使用不超过<span class="number">101</span>个，如下。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor threadPool =</span><br><span class="line"> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">100</span>,<span class="number">100</span>,<span class="number">0</span>, TimeUnit.SECONDS,<span class="keyword">new</span> SynchronousQueue&lt;&gt;(),<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy())</span><br></pre></td></tr></table></figure><h2 id="如何知道所有任务结束"><a href="#如何知道所有任务结束" class="headerlink" title="如何知道所有任务结束"></a>如何知道所有任务结束</h2><p>即整个程序大概是这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于记录200状态码，和其他状态码的数量</span></span><br><span class="line">AtomicInteger okCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">AtomicInteger otherCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( (line = readLine(file)) !=<span class="keyword">null</span>)&#123;</span><br><span class="line">    String tmp = line;</span><br><span class="line"></span><br><span class="line">    threadPool.execute(()-&gt;&#123;</span><br><span class="line">        <span class="comment">// 对每一行进行处理</span></span><br><span class="line">        process(tmp,okCount,otherCount );</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"ok个数"</span>+okCount.get()+<span class="string">" 不ok的个数"</span>+otherCount);</span><br></pre></td></tr></table></figure><p>但打印结果这一行可能有问题，例如最后100个url的请求时间超级长，这100个线程创建完之后，就到了打印这一行了但是还没执行完，这样结果就是错的。常规思路下，计数器CountDownLatch是最佳选择，但是当前题目无法获知文件大小，而计数器必须一开始就指定计数的大小。这怎么解决呢？</p><p>当然思路是很多的，例如最简单的能想到的，就是在打印前判断线程池中活跃线程&gt;0，就sleep。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(threadPool.get<span class="constructor">ActiveCount()</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做不是特别的好，首先是这个getActiveCount拿到的个数是个大约的值，不保证准确，其次sleep的时长如何设定是恰当的有待商榷。我比较喜欢的做法是利用相位器Phaser。代码如下，有注释，但是可能也不太好理解，建议看下相位器那期视频。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicInteger okCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">AtomicInteger otherCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建数为1的相位器，不设置为0，是因为如果相位器总数从1减到0时，会导致阶段变为负数。1是个保护屏障。</span></span><br><span class="line">Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( (line = readLine(file)) !=<span class="keyword">null</span>)&#123;</span><br><span class="line">    String tmp = line;</span><br><span class="line">    <span class="comment">// 每一行内容读出来时相位器总数+1</span></span><br><span class="line">    phaser.register();</span><br><span class="line">    threadPool.execute(()-&gt;&#123;</span><br><span class="line">        <span class="comment">// 对每一行进行处理</span></span><br><span class="line">        process(tmp,okCount,otherCount );</span><br><span class="line">        <span class="comment">// 处理完一行相位器总数-1</span></span><br><span class="line">        phaser.arriveAndDeregister();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为初值设为1，所以最后需要arrive一次</span></span><br><span class="line">phaser.arrive();</span><br><span class="line">phaser.awaitAdvance(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"ok个数"</span>+okCount.get()+<span class="string">" 不ok的个数"</span>+otherCount);</span><br></pre></td></tr></table></figure><h1 id="博主主页"><a href="#博主主页" class="headerlink" title="博主主页"></a><strong><a href="http://www.zeze.info">博主主页</a></strong></h1><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java高并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这是一场修行</title>
      <link href="/life/index/"/>
      <url>/life/index/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一场修行"><a href="#一场修行" class="headerlink" title="一场修行"></a>一场修行</h1><p>&emsp;我很焦虑,每当听到周围有个朋友有个项目,总是想着沾光,能跟着一起混。这样的想法让总是让我思想混乱。我得承认,确实有很多牛逼又赚钱的生意,但是我赚不来,既然赚不了的钱为何不果断放弃呢？何必让自己那么难受。</p><p>&emsp;每天间歇性地焦虑、意淫式地渴望暴富,只会让我心情更加浮躁,感觉现在的自己已经寸步难行甚至影响到自己的工作了，真的是罪恶。没有清晰地规划，至于怎么一步步解决问题等都没有思考、规划过。这种漫无目的地焦虑是最没有价值的，是负面的。适当的焦虑使人进步，但是我要想清楚自己想要什么，以及怎么解决。明确地目标、清晰地规划、适度地焦虑能够让我走的更远！</p><p>&emsp;赚钱是一场道长且阻的修行，我现在最需要的是磨砺心性，也需要目标明确、步步为营。从现在开始我要明确自己的目标，至少不能被朋友所说的那些“项目”所影响，自己不适合，就永远不要去想，不以物喜不以己悲。不去关心别人赚了多少钱，别人做了什么项目，要关心自己，与自己的内心对话，明白自己具备哪些能力，能做哪些事情，以及如何把事情做到极致！。千万不要为了赚钱而赚钱。要不断地为社会创造长期价值,而现在我能为别人创造价值的唯一途径就是自己的本质工作,作为一名程序员，我一定要认真对待自己的工作,努力学习专业知识,提供更加优质的专业服务，如果公司成功，那对于公司的员工，我觉得我也是成功的，所以目前工作对我意义也非常大。</p><p>&emsp;我很喜欢编程，当时我还很担心就业前景问题。我记得当时我19岁老师给我说过的一句话“种一棵树最好的时间是十年前,其次就是现在”，而如今我都已经有3年多的工作经验了，想那么多最后连自己的工作都做不好，那岂不是让人笑话。所以我现在有一个很明确的目标，就是不断学习专业知识，满足工作需求，甚至出色的完成自己的工作，在业界也要留下好的口碑，在工作遇到的问题，和很多常用的技术，自己能归纳总结好。我坚信人生没有白走的路，每一步都算数。</p><p>&emsp;2020年李克强总理说：中国有6亿人月收入就1000元,年人均收入3万元。这么来看,年入百万是不是比登天还难？没有规划却意淫暴富,就是掩耳盗铃,自欺欺人。无论是打工上班,还是创业做生意,必须有目标,有阶段性规划,然后一步步实现财富增长。我从来不相信暴富,财富都是一点一滴积累的。《过秦论》有言：奋六世之余烈,振长策而御宇内。秦国能一统天下也是六代人不断积累的结果。那些拆迁、中奖等因运气暴富的人有多少能守住财富并富足地过一生？我还很年轻才25岁，还有很多时间。我相信自己可以孵化出属于自己的项目。现在我相信时间的力量，相信日复一日的力量，别人赚多少钱，引多少流量，和我一点关系没有，收心，把心收回自己的身体，身心合一。</p><p>&emsp;今年25岁，在这里给自己定个5年目标。</p><p>第一、重视健康，锻炼身体<br>第二、做好职业规划，让自己不被所在打的行业淘汰<br>第三、学会演讲。</p><p>人生路上，要保持持续的激情、明确地目标，步步为营地创造长期价值！</p><h1 id="我坚信人生没有白走的路，每一步都算数。"><a href="#我坚信人生没有白走的路，每一步都算数。" class="headerlink" title="我坚信人生没有白走的路，每一步都算数。"></a>我坚信人生没有白走的路，每一步都算数。</h1><p>欣然面对困难，坦然面对每一天，不浮躁！</p><h1 id="但行好事，莫问前程"><a href="#但行好事，莫问前程" class="headerlink" title="但行好事，莫问前程"></a>但行好事，莫问前程</h1><h1 id="博主主页"><a href="#博主主页" class="headerlink" title="博主主页"></a><strong><a href="http://www.zeze.info">博主主页</a></strong></h1><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS里常见的块级元素</title>
      <link href="/css/index2/"/>
      <url>/css/index2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CSS里常见的块级元素"><a href="#CSS里常见的块级元素" class="headerlink" title="CSS里常见的块级元素"></a>CSS里常见的块级元素</h1><blockquote><p>根据CSS规范的规定，每一个网页元素都有一个display属性，用于确定该元素的类型，每一个元素都有默认的display属性值，比如div元素，它的默认display属性值为“block”，成为“块级”元素(block-level)；而span元素的默认display属性值为“inline”，称为“行内”元素。</p></blockquote><blockquote><p>div这样的块级元素，就会自动占据一定矩形空间，可以通过设置高度、宽度、内外边距等属性，来调整的这个矩形的样子；与之相反，像“span”“a”这样的行内元素，则没有自己的独立空间，它是依附于其他块级元素存在的，因此，对行内元素设置高度、宽度、内外边距等属性，都是无效的。</p></blockquote><h2 id="内联元素（行内元素）内联元素-inline-element"><a href="#内联元素（行内元素）内联元素-inline-element" class="headerlink" title="内联元素（行内元素）内联元素(inline element)"></a>内联元素（行内元素）内联元素(inline element)</h2><ul><li>a - 锚点</li><li>abbr - 缩写</li><li>acronym - 首字</li><li>b - 粗体(不推荐)</li><li>bdo - bidi override</li><li>big - 大字体</li><li>br - 换行</li><li>cite - 引用</li><li>code - 计算机代码(在引用源码的时候需要)</li><li>dfn - 定义字段</li><li>em - 强调</li><li>font - 字体设定(不推荐)</li><li>i - 斜体</li><li>img - 图片</li><li>input - 输入框</li><li>kbd - 定义键盘文本</li><li>label - 表格标签</li><li>q - 短引用</li><li>s - 中划线(不推荐)</li><li>samp - 定义范例计算机代码</li><li>select - 项目选择</li><li>small - 小字体文本</li><li>span - 常用内联容器，定义文本内区块</li><li>strike - 中划线</li><li>strong - 粗体强调</li><li>sub - 下标</li><li>sup - 上标</li><li>textarea - 多行文本输入框</li><li>tt - 电传文本</li><li>u - 下划线</li><li>var - 定义变量</li></ul><h2 id="块元素-block-element"><a href="#块元素-block-element" class="headerlink" title="块元素(block element)"></a>块元素(block element)</h2><ul><li>address - 地址</li><li>blockquote - 块引用</li><li>center - 举中对齐块</li><li>dir - 目录列表</li><li>div - 常用块级容易，也是css layout的主要标签</li><li>dl - 定义列表</li><li>fieldset - form控制组</li><li>form - 交互表单</li><li>h1 - 大标题</li><li>h2 - 副标题</li><li>h3 - 3级标题</li><li>h4 - 4级标题</li><li>h5 - 5级标题</li><li>h6 - 6级标题</li><li>hr - 水平分隔线</li><li>isindex - input prompt</li><li>menu - 菜单列表</li><li>noframes - frames可选内容，（对于不支持frame的浏览器显示此区块内容</li><li>noscript - ）可选脚本内容（对于不支持script的浏览器显示此内容）</li><li>ol - 排序表单</li><li>p - 段落</li><li>pre - 格式化文本</li><li>table - 表格</li><li>ul - 非排序列表</li></ul><h2 id="可变元素"><a href="#可变元素" class="headerlink" title="可变元素"></a>可变元素</h2><p>可变元素为根据上下文语境决定该元素为块元素或者内联元素。</p><ul><li>applet - java applet</li><li>button - 按钮</li><li>del - 删除文本</li><li>iframe - inline frame</li><li>ins - 插入的文本</li><li>map - 图片区块(map)</li><li>object - object对象</li><li>script - 客户端脚本</li></ul><h1 id="博主主页"><a href="#博主主页" class="headerlink" title="博主主页"></a><strong><a href="http://www.zeze.info">博主主页</a></strong></h1><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入学习Css伪类和伪元素及其用法</title>
      <link href="/css/index1/"/>
      <url>/css/index1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>CSS的伪类和伪元素在平时的代码中经常会出现，可是一旦别人问你，什么是伪类，什么是伪元素，可能还是不能完整的表述出来，下面我们来一探究竟。</p></blockquote><h1 id="伪类和伪元素定义"><a href="#伪类和伪元素定义" class="headerlink" title="伪类和伪元素定义"></a>伪类和伪元素定义</h1><blockquote><p>伪类用于在页面中的元素处于某个状态时，为其添加指定的样式。</p></blockquote><blockquote><p>伪元素会创建一个抽象的伪元素，这个元素不是DOM中的真实元素，但是会存在于最终的渲染树中，我们可以为其添加样式。</p></blockquote><p><strong>重点:</strong>最常规的区分伪类和伪元素的方法是：实现伪类的效果可以通过添加类来实现，但是想要实现伪元素的等价效果只能创建实际的DOM节点。</p><p><strong>注意:</strong>伪类使用单冒号 “:” ; 伪元素使用双冒号 “::”</p><h1 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h1><blockquote><p>伪元素可以分为排版伪元素、突出显示伪元素、树中伪元素三类。</p></blockquote><h2 id="排版伪元素"><a href="#排版伪元素" class="headerlink" title="排版伪元素"></a>排版伪元素</h2><div class="note default"> 设置元素中第一行文本的样式[::first-line]</div><p><strong>注意:</strong>只有当选择器部分和左大括号之间有空格时，IE6-浏览器才支持。因为first-line中存在连接符的原因</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.firstLine</span><span class="selector-pseudo">::first-line</span> &#123;</span></span><br><span class="line">    width: 200px;</span><br><span class="line">    text-transform: uppercase;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#f3f3f3</span>;</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"firstLine"</span>&gt;</span>hello world hello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello world <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/css/index1/20200727184822.png!www.zeze.info" alt="first-line"><br>虽然在DOM中看不到，但实际上，上面的这段HTML代码会通过添加虚拟标签的方式进行修改。</p><div class="note default">指定一个元素第一个字母的样式[::first-letter]</div><ul><li>注意1:所有前导标点符号应与第一个字母一同应用该样式</li><li>注意2:只能与块级元素关联</li><li>注意3:只有当选择器部分和左大括号之间有空格时，IE6-浏览器才支持。因为first-letter中存在连接符的原因</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/css/index1/20200728110442.png!www.zeze.info" alt="first-letter"></p><h2 id="突出显示伪元素"><a href="#突出显示伪元素" class="headerlink" title="突出显示伪元素"></a>突出显示伪元素</h2><blockquote><p>突出显示伪元素表示文档中特定状态的部分，通常采用不同的样式展示该状态。如页面内容的选中。突出显示伪元素不需要在元素树中有体现，并且可以任意跨越元素边界而不考虑其嵌套结构。</p></blockquote><div class="note default">匹配被用户选择的部分[::selection]</div><p><a href="#">注意1:</a>firefox浏览器需要添加-moz-前缀<br><a href="#">注意2:</a>只支持双冒号写法<br><a href="#">注意3:</a>只支持颜色和背景颜色两个样式</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">div::selection&#123;color: red;&#125;</span><br></pre></td></tr></table></figure><h2 id="树中伪元素"><a href="#树中伪元素" class="headerlink" title="树中伪元素"></a>树中伪元素</h2><div class="note default">::before & ::after::before是在源元素的实际内容前添加伪元素。::after是在源元素的实际内容后添加伪元素。当::before/::after伪元素的content属性不为'none'时，这两类伪元素就会生成一个元素，作为源元素的子元素，可以和DOM树中的元素一样定义样式。</div><p>注意默认这个伪元素是行内元素，且继承元素可继承的属性；IE7-浏览器中必须声明!DOCTYPE，否则不起作用</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// content = 字符串</span><br><span class="line">.box:after&#123;content:"后缀"&#125;</span><br><span class="line">// content = url</span><br><span class="line">div:before&#123;</span><br><span class="line">    content: url("arrow.gif");</span><br><span class="line">&#125;</span><br><span class="line">// content = attr</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-before</span>=<span class="string">"把我现在上去"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">div:before&#123;</span><br><span class="line">    content: attr(data-before);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>content的内容可以直接使用 url() 引入图片</p></blockquote><div class="note default">::markder可以用于定义列表项标记的样式。</div><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span><span class="selector-pseudo">::marker</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span><span class="selector-pseudo">:green</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>该伪元素暂时只有safari支持，尝试的话请使用safari。可以用于该伪元素的属性也有限</strong></p><div class="note default">表示输入框内占位提示文字。可以定义其样式。[::placeholder]</div><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-pseudo">::placeholder</span> &#123;</span></span><br><span class="line">            color: blue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span> =<span class="string">"testtesttest"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><div><style>::placeholder { color: blue;}</style> <input type="text" placeholder="testtesttest"></div><h2 id="伪元素速查表"><a href="#伪元素速查表" class="headerlink" title="伪元素速查表"></a>伪元素速查表</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Typographic Pseudo-elements */</span></span><br><span class="line"><span class="selector-pseudo">::first-line</span>            <span class="comment">/* 选取文字块首行字符 */</span></span><br><span class="line"><span class="selector-pseudo">::first-letter</span>          <span class="comment">/* 选取文字块首行首个字符 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Highlight Pseudo-elements */</span></span><br><span class="line"><span class="selector-pseudo">::selection</span>             <span class="comment">/* 选取文档中高亮(反白)的部分*/</span></span><br><span class="line"><span class="selector-pseudo">::inactive-selection</span>    <span class="comment">/* 选取非活动状态时文档中高亮(反白)的部分*/</span></span><br><span class="line"><span class="selector-pseudo">::spelling-error</span>        <span class="comment">/* 选取被 UA 标记为拼写错误的文本 */</span></span><br><span class="line"><span class="selector-pseudo">::grammar-error</span>         <span class="comment">/* 选取被 UA 标记为语法错误的文本 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tree-Abiding Pseudo-elements */</span></span><br><span class="line"><span class="selector-pseudo">::before</span>                <span class="comment">/* 在选中元素中创建一个前置的子节点 */</span></span><br><span class="line"><span class="selector-pseudo">::after</span>                 <span class="comment">/* 在选中元素中创建一个后置的子节点 */</span></span><br><span class="line"><span class="selector-pseudo">::marker</span>                <span class="comment">/* 选取列表自动生成的项目标记符号 */</span></span><br><span class="line"><span class="selector-pseudo">::placeholder</span>           <span class="comment">/* 选取字段的占位符文本(提示信息) */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* WebVTT Format */</span></span><br><span class="line"><span class="selector-pseudo">::cue</span>                   <span class="comment">/* 匹配所选元素中 WebVTT 提示 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fullscreen API */</span></span><br><span class="line"><span class="selector-pseudo">::backdrop</span>              <span class="comment">/* 匹配全屏模式下的背景 */</span></span><br></pre></td></tr></table></figure><h1 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h1><blockquote><p>伪类经常与伪元素混淆，伪元素的效果类似于通过添加一个实际的元素才能达到，而伪类的效果类似于通过添加一个实际的类来达到。实际上css3为了区分两者，已经明确规定了伪类用一个冒号来表示，而伪元素则用两个冒号来表示。</p></blockquote><h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><blockquote><p>关于锚点<a>，有常见的5个伪类，分别是:link,:hover,:active,:focus,:visited</a></p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>&#123;<span class="attribute">background-color</span>:pink;&#125;<span class="comment">/*品红，未访问*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">background-color</span>:lightblue;&#125;<span class="comment">/*浅蓝，鼠标悬停*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span>&#123;<span class="attribute">background-color</span>:lightgreen;&#125;<span class="comment">/*浅绿，正被点击*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>&#123;<span class="attribute">background-color</span>:lightgrey;&#125;<span class="comment">/*浅灰，拥有焦点*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>&#123;<span class="attribute">color</span>:orange;&#125;<span class="comment">/*字体颜色为橙色，已被访问*/</span></span><br><span class="line"><span class="comment">/*[注意]visited伪类只能设置字体颜色、边框颜色、outline颜色的样式*/</span></span><br></pre></td></tr></table></figure><h2 id="伪类顺序"><a href="#伪类顺序" class="headerlink" title="伪类顺序"></a>伪类顺序</h2><blockquote><p>对于伪类顺序，有一个口诀是love-hate，代表着伪类的顺序是link、visited、focus、hover、active。但是否伪类的顺序只能如此呢？为什么是这个顺序呢？CSS层叠中有一条法则十分重要，就是后面覆盖前面，所以伪类的顺序是需要精心考虑的。</p></blockquote><ol><li>link和visited必须在最前面，且没有先后顺序，否则link或visited的效果将覆盖 hover active focus</li><li>hover、active、focus这三个伪类必须是focus、hover、active的顺序，因为在focus状态下，也需要触发hover和active，而要触发active一定要先触发hover，所以active要放在hover后面</li></ol><p>注意:link和visited称为静态伪类，只能应用于超链接</p><p>所以最终的顺序只有两种:link、visited、focus、hover、active或visited、link、focus、hover、active</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>&#123;<span class="attribute">background-color</span>:pink;&#125;<span class="comment">/*品红，未访问*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>&#123;<span class="attribute">color</span>:orange;&#125;<span class="comment">/*字体颜色为橙色，已被访问*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>&#123;<span class="attribute">background-color</span>:lightgrey;&#125;<span class="comment">/*浅灰，拥有焦点*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">background-color</span>:lightblue;&#125;<span class="comment">/*浅蓝，鼠标悬停*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span>&#123;<span class="attribute">background-color</span>:lightgreen;&#125;<span class="comment">/*浅绿，正被点击*/</span></span><br></pre></td></tr></table></figure><div><style>#test:link{background-color:pink;}/*品红，未访问*/#test:visited{color:orange;}/*字体颜色为橙色，已被访问*/#test:focus{background-color:lightgrey;}/*浅灰，拥有焦点*/#test:hover{background-color:lightblue;}/*浅蓝，鼠标悬停*/#test:active{background-color:lightgreen;}/*浅绿，正被点击*/</style> <a id="test" href="#">测试链接伪类</a></div><h2 id="UI元素伪类"><a href="#UI元素伪类" class="headerlink" title="UI元素伪类"></a>UI元素伪类</h2><blockquote><p>UI元素伪类包括:enabled、:disabled、:checked三个，主要针对于HTML中的form元素，IE8-浏览器不支持</p></blockquote><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:enabled</span>    可用状态</span><br><span class="line"><span class="selector-pseudo">:disabled</span>   不可用状态</span><br><span class="line"><span class="selector-pseudo">:checked</span>    选中状态</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:enabled</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">background-color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:disabled</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">background-color</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:checked</span>&#123;</span><br><span class="line">    <span class="attribute">outline</span>: <span class="number">2px</span> solid lightblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;button onclick = "btn.disabled = false;"&gt;按钮可用&lt;/button&gt;</span><br><span class="line">&lt;button onclick = "btn.disabled = true;"&gt;按钮不可用&lt;/button&gt;</span><br><span class="line">&lt;input type="button" id="btn" value="按钮"&gt;</span><br><span class="line">&lt;label&gt;Male&lt;input type="radio" name="sex" /&gt;&lt;/label&gt;</span><br><span class="line">&lt;label&gt;Female&lt;input type="radio" name="sex"  /&gt;&lt;/label&gt;</span><br></pre></td></tr></table></figure><h2 id="结构伪类"><a href="#结构伪类" class="headerlink" title="结构伪类"></a>结构伪类</h2><blockquote><p>结构伪类可分为以下3种情况，IE8-浏览器不支持</p></blockquote><h3 id="【1】-nth-child-n-、-nth-last-child-n-、first-child、last-child、-only-child"><a href="#【1】-nth-child-n-、-nth-last-child-n-、first-child、last-child、-only-child" class="headerlink" title="【1】:nth-child(n)、:nth-last-child(n)、first-child、last-child、:only-child"></a>【1】:nth-child(n)、:nth-last-child(n)、first-child、last-child、:only-child</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">E</span> <span class="selector-tag">F</span><span class="selector-pseudo">:nth-child(n)</span>           选择父元素的第<span class="selector-tag">n</span>个子元素</span><br><span class="line"><span class="selector-tag">E</span> <span class="selector-tag">F</span><span class="selector-pseudo">:nth-last-child(n)</span>      选择父元素的倒数第<span class="selector-tag">n</span>个子元素</span><br><span class="line"><span class="selector-tag">E</span> <span class="selector-tag">F</span><span class="selector-pseudo">:first-child</span>            父元素的第一个子元素，与<span class="selector-tag">E</span> <span class="selector-tag">F</span><span class="selector-pseudo">:nth-child(1)</span>等同</span><br><span class="line"><span class="selector-tag">E</span> <span class="selector-tag">F</span><span class="selector-pseudo">:last-child</span>             父元素的最后一个子元素，与<span class="selector-tag">E</span> <span class="selector-tag">F</span><span class="selector-pseudo">:nth-last-child(1)</span>等同</span><br><span class="line"><span class="selector-tag">E</span> <span class="selector-tag">F</span><span class="selector-pseudo">:only-child</span>             选择父元素中只包含一个子元素</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-child</span>    　　 代表的并不是&lt;<span class="selector-tag">p</span>&gt;的第一个子元素，而是&lt;<span class="selector-tag">p</span>&gt;元素是某元素的第一个子元素</span><br><span class="line"><span class="selector-tag">p</span> &gt; <span class="selector-tag">i</span><span class="selector-pseudo">:first-child</span>    匹配所有&lt;<span class="selector-tag">p</span>&gt;元素中的第一个&lt;<span class="selector-tag">i</span>&gt;元素</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-child</span> <span class="selector-tag">i</span> 　　  匹配所有作为第一个子元素的&lt;<span class="selector-tag">p</span>&gt;元素中的所有&lt;<span class="selector-tag">i</span>&gt;元素</span><br></pre></td></tr></table></figure><p>[注]n可以是整数(从1开始)，也可以是公式，也可以是关键字(even、odd)</p><h3 id="【2】-nth-of-type-n-、-nth-last-of-type-n-、-first-of-type、-last-of-type、-only-of-type"><a href="#【2】-nth-of-type-n-、-nth-last-of-type-n-、-first-of-type、-last-of-type、-only-of-type" class="headerlink" title="【2】:nth-of-type(n)、:nth-last-of-type(n)、:first-of-type、:last-of-type、:only-of-type"></a>【2】:nth-of-type(n)、:nth-last-of-type(n)、:first-of-type、:last-of-type、:only-of-type</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">E</span> <span class="selector-tag">F</span><span class="selector-pseudo">:nth-of-type(n)</span>          选择父元素的具有指定类型的第<span class="selector-tag">n</span>个子元素</span><br><span class="line"><span class="selector-tag">E</span> <span class="selector-tag">F</span><span class="selector-pseudo">:nth-last-of-type(n)</span>     选择父元素的具有指定类型的倒数第<span class="selector-tag">n</span>个子元素</span><br><span class="line"><span class="selector-tag">E</span> <span class="selector-tag">F</span><span class="selector-pseudo">:first-of-type</span>           选择父元素中具有指定类型的第1个子元素，与<span class="selector-tag">E</span> <span class="selector-tag">F</span><span class="selector-pseudo">:nth-of-type(1)</span>相同</span><br><span class="line"><span class="selector-tag">E</span> <span class="selector-tag">F</span><span class="selector-pseudo">:last-of-type</span>         　  选择父元素中具有指定类型的最后1个子元素，与<span class="selector-tag">E</span> <span class="selector-tag">F</span><span class="selector-pseudo">:nth-last-of-type(1)</span>相同</span><br><span class="line"><span class="selector-tag">E</span> <span class="selector-tag">F</span><span class="selector-pseudo">:only-of-type</span>        　　 选择父元素中只包含一个同类型的子元素</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">div</span><span class="selector-pseudo">:nth-of-type(even)</span>&#123;<span class="attribute">color</span>: red;&#125; </span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">p</span><span class="selector-pseudo">:nth-last-of-type(3)</span>&#123;<span class="attribute">color</span>: green;&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">div</span><span class="selector-pseudo">:first-of-type</span>&#123;<span class="attribute">color</span>: blue;&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">p</span><span class="selector-pseudo">:last-of-type</span>&#123;<span class="attribute">color</span>: yellow;&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">div</span><span class="selector-pseudo">:only-of-type</span>&#123;<span class="attribute">color</span>: pink;&#125;</span><br></pre></td></tr></table></figure><h3 id="【3】-root、-not、-empty、-target"><a href="#【3】-root、-not、-empty、-target" class="headerlink" title="【3】:root、:not、:empty、:target"></a>【3】:root、:not、:empty、:target</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span>        　选择文档的根元素</span><br><span class="line"><span class="selector-pseudo">:not</span>         　选择除某个元素之外的所有元素</span><br><span class="line"><span class="selector-pseudo">:empty</span>         选择没有子元素的元素，而且该元素也不包含任何文本节点</span><br><span class="line"><span class="selector-pseudo">:target</span>     　 匹配锚点对应的目标元素</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[注意]</span><span class="selector-pseudo">:not</span>选择器常用于导航之间的竖线处理，如<span class="selector-tag">li</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:last-of-type)</span></span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:root</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:not</span>&#123;<span class="attribute">background-color</span>: lightgrey;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:empty</span>&#123;<span class="attribute">height</span>:<span class="number">30px</span>;<span class="attribute">width</span>:<span class="number">30px</span>;<span class="attribute">background</span>:pink;&#125;</span><br><span class="line">:target&#123;color:blue;&#125; // 当点击页面上面的锚点时，锚点到的目标元素会采用这个样式</span><br></pre></td></tr></table></figure><h3 id="【其它】"><a href="#【其它】" class="headerlink" title="【其它】"></a>【其它】</h3><ol><li><p>:lang() 匹配某个语言，IE7-浏览器不支持</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:lang(en)</span> 匹配语言为"<span class="selector-tag">en</span>"的&lt;<span class="selector-tag">p</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>不仅可以使用单一伪类，也可以伪类结合使用</p></li></ol><p>顺序无关</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">:first-child</span>&#123;<span class="attribute">background-color</span>: lightgreen;&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:last-of-type</span><span class="selector-pseudo">:active</span>&#123;<span class="attribute">background-color</span>: lightblue;&#125;</span><br></pre></td></tr></table></figure><h2 id="伪类速查表"><a href="#伪类速查表" class="headerlink" title="伪类速查表"></a>伪类速查表</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Logical Combinations */</span></span><br><span class="line"><span class="selector-pseudo">:matches()</span> <span class="comment">/*:any()*/</span>   <span class="comment">/* 匹配 集合内指定 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:not()</span>                  <span class="comment">/* 排除 满足指定关系 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:has()</span>                  <span class="comment">/* 匹配 满足指定关系 的元素*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Linguistic Pseudo-classes */</span></span><br><span class="line"><span class="selector-pseudo">:dir()</span>                  <span class="comment">/* 匹配 设置dir(文字书写方向)属性 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:lang()</span>                 <span class="comment">/* 匹配 设置lang(定义元素语言)属性 的元素 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Location Pseudo-classes */</span></span><br><span class="line"><span class="selector-pseudo">:any-link</span>               <span class="comment">/* 匹配 任意有链接锚点 的元素*/</span></span><br><span class="line"><span class="selector-pseudo">:link</span>                   <span class="comment">/* 匹配 未处于访问记录中 的链接 */</span></span><br><span class="line"><span class="selector-pseudo">:visited</span>                <span class="comment">/* 匹配 处于访问记录中 的链接 */</span></span><br><span class="line"><span class="selector-pseudo">:target</span>                 <span class="comment">/* 匹配 URL指向的锚点 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:scope</span>                  <span class="comment">/* 匹配 设置scoped属性的style标签 的作用域 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* User Action Pseudo-classes */</span></span><br><span class="line"><span class="selector-pseudo">:hover</span>                  <span class="comment">/* 匹配 处于鼠标悬停状态 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:active</span>                 <span class="comment">/* 匹配 处于激活状态 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:focus</span>                  <span class="comment">/* 匹配 处于聚焦状态 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:focus-ring</span>             <span class="comment">/* 匹配 处于聚焦状态元素 的UA样式(聚焦轮廓) */</span></span><br><span class="line"><span class="selector-pseudo">:focus-within</span>           <span class="comment">/* 匹配 子节点处于聚焦状态 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:drop</span>                   <span class="comment">/* 匹配 处于拖拽状态 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:drop()</span>                 <span class="comment">/* 匹配 处于指定拖拽状态 的元素 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Time-dimensional Pseudo-classes */</span></span><br><span class="line"><span class="selector-pseudo">:current</span>                <span class="comment">/* 匹配 处于当前状态 的定义了timeline属性的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:past</span>                   <span class="comment">/* 匹配 处于过去状态 的定义了timeline属性的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:future</span>                 <span class="comment">/* 匹配 处于将来状态 的定义了timeline属性的元素 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Resource State Pseudos */</span></span><br><span class="line"><span class="selector-pseudo">:playing</span>                <span class="comment">/* 匹配 处于播放状态 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:paused</span>                 <span class="comment">/* 匹配 处于暂停状态 的元素 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The Input Pseudo-classes */</span></span><br><span class="line"><span class="selector-pseudo">:enabled</span>                <span class="comment">/* 匹配 可以编辑 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:disabled</span>               <span class="comment">/* 匹配 禁止编辑 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:read-only</span>              <span class="comment">/* 匹配 内容只读 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:read-write</span>             <span class="comment">/* 匹配 内容可编辑 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:placeholder-shown</span>      <span class="comment">/* 匹配 显示字段占位符文本 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:default</span>                <span class="comment">/* 匹配 页面载入默认选中 的元素 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:checked</span>                <span class="comment">/* 匹配 选中状态 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:indeterminate</span>          <span class="comment">/* 匹配 模糊状态 的元素 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:valid</span>                  <span class="comment">/* 匹配 输入内容通过类型验证 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:invalid</span>                <span class="comment">/* 匹配 输入内容无法通过类型验证 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:in-range</span>               <span class="comment">/* 匹配 输入数值符合范围 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:out-of-range</span>           <span class="comment">/* 匹配 输入数值溢出范围 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:required</span>               <span class="comment">/* 匹配 设置必填属性 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:optional</span>               <span class="comment">/* 匹配 可选字段 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:user-invalid</span>           <span class="comment">/* 匹配 用户输入内容未通过验证 的元素 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tree-Structural pseudo-classes */</span></span><br><span class="line"><span class="selector-pseudo">:root</span>                   <span class="comment">/* 匹配 文档树 的根元素*/</span></span><br><span class="line"><span class="selector-pseudo">:empty</span>                  <span class="comment">/* 匹配 无子节点 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:blank</span>                  <span class="comment">/* 匹配 仅包含空格或者换行符 的元素 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:nth-child(n)</span>           <span class="comment">/* 匹配 符合元素集合中指定位置 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:nth-last-child(n)</span>      <span class="comment">/* 反序匹配 符合元素集合内指定位置 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:first-child</span>            <span class="comment">/* 匹配 符合元素集合内首个 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:last-child</span>             <span class="comment">/* 匹配 符合元素集合内末尾 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:only-child</span>             <span class="comment">/* 匹配 无兄弟节点 的元素 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:nth-of-type(n)</span>         <span class="comment">/* 匹配 符合元素集合中同类型指定位置 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:nth-last-of-type(n)</span>    <span class="comment">/* 反序匹配 符合元素集合中同类型指定位置 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:first-of-type</span>          <span class="comment">/* 匹配 每个在元素集合中初次出现 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:last-of-type</span>           <span class="comment">/* 匹配 每个在元素集合中末次出现 的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:only-of-type</span>           <span class="comment">/* 匹配 无同类兄弟节点 的元素*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fullscreen API */</span></span><br><span class="line"><span class="selector-pseudo">:fullscreen</span>             <span class="comment">/* 匹配 全屏显示模式中 的元素 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Page Selectors */</span></span><br><span class="line"><span class="selector-pseudo">:first</span>                  <span class="comment">/* 打印文档时首页的样式 */</span></span><br><span class="line"><span class="selector-pseudo">:left</span>                   <span class="comment">/* 打印文档时左侧的样式 */</span></span><br><span class="line"><span class="selector-pseudo">:right</span>                  <span class="comment">/* 打印文档时右侧的样式 */</span></span><br></pre></td></tr></table></figure><h1 id="博主主页"><a href="#博主主页" class="headerlink" title="博主主页"></a><strong><a href="http://www.zeze.info">博主主页</a></strong></h1><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>责任链模式</title>
      <link href="/java/design/j4/"/>
      <url>/java/design/j4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h1><blockquote><p>每个版本都是一点一点演化过去的。代码版本多，但是都很简单行数也不多</p></blockquote><ol><li>在论坛发布文章</li><li>后台要经过处理才可以发表或者存入数据库</li><li>每条链都需要有权限去判断还继不继续往下执行</li><li>servlet filter实现</li></ol><h2 id="代码版本v1"><a href="#代码版本v1" class="headerlink" title="代码版本v1"></a>代码版本v1</h2><p><a href="https://github.com/zhangzeli/design_patterns/tree/master/src/main/java/com/cor/v1" target="_blank" rel="external nofollow noopener noreferrer">代码版本v1</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Msg msg = <span class="keyword">new</span> Msg();</span><br><span class="line">        <span class="comment">//在论坛发帖</span></span><br><span class="line">        msg.setMsg(<span class="string">"大家好：&#125;&lt;script&gt; ,欢迎访问www.zeze.info 台湾 "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一步网页脚本</span></span><br><span class="line">        String r = msg.getMsg();</span><br><span class="line">        r = r.replace(<span class="string">"&lt;"</span>,<span class="string">"&amp;lt;"</span>);</span><br><span class="line">        r = r.replace(<span class="string">"&gt;"</span>,<span class="string">"&amp;gt;"</span>);</span><br><span class="line">        msg.setMsg(r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二步处理敏感词</span></span><br><span class="line">        r = r.replace(<span class="string">"台湾"</span>,<span class="string">"中国"</span>);</span><br><span class="line">        msg.setMsg(r);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Msg</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Msg&#123;"</span> +</span><br><span class="line">                <span class="string">"msg='"</span> + msg + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码版本说明"><a href="#代码版本说明" class="headerlink" title="代码版本说明"></a>代码版本说明</h2><blockquote><p>代码直接写在一起，如果要加入其它的处理逻辑必须修改源码，比如现在要加一个URL过滤的处理，所以现在抽象出Filter，和FilterChain。对应版本V2和v3</p></blockquote><h2 id="代码V2-v3"><a href="#代码V2-v3" class="headerlink" title="代码V2-v3"></a>代码V2-v3</h2><p><a href="https://github.com/zhangzeli/design_patterns/tree/master/src/main/java/com/cor/v2" target="_blank" rel="external nofollow noopener noreferrer">代码版本v2</a><br><a href="https://github.com/zhangzeli/design_patterns/tree/master/src/main/java/com/cor/v3" target="_blank" rel="external nofollow noopener noreferrer">代码版本v3</a></p><p>这里直接贴出代码V3</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cor.v3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Msg</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String msg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Msg&#123;"</span> +</span><br><span class="line">                <span class="string">"msg='"</span> + msg + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">( Msg msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span></span>&#123;</span><br><span class="line">    List&lt; Filter&gt; filters = <span class="keyword">new</span>  ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFilter</span><span class="params">(Filter filter)</span></span>&#123;</span><br><span class="line">        filters.add(filter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteFilter</span><span class="params">(Filter filter)</span></span>&#123;</span><br><span class="line">        filters.remove(filter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链条处理完.这个方法名现在 故意这么取得后面就知道了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Msg msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( Filter f : filters)&#123;</span><br><span class="line">            f.doFilter(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTMLfilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">( Msg msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一步网页脚本</span></span><br><span class="line">        String r = msg.getMsg();</span><br><span class="line">        r = r.replace(<span class="string">"&lt;"</span>,<span class="string">"&amp;lt;"</span>);</span><br><span class="line">        r = r.replace(<span class="string">"&gt;"</span>,<span class="string">"&amp;gt;"</span>);</span><br><span class="line">        msg.setMsg(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SensitiveFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">( Msg msg)</span> </span>&#123;</span><br><span class="line">        String r = msg.getMsg();</span><br><span class="line">        <span class="comment">//第二步处理敏感词</span></span><br><span class="line">        r = r.replace(<span class="string">"台湾"</span>,<span class="string">"中国"</span>);</span><br><span class="line">        msg.setMsg(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Msg msg = <span class="keyword">new</span> Msg();</span><br><span class="line">        <span class="comment">//在论坛发帖</span></span><br><span class="line">        msg.setMsg(<span class="string">"大家好：&#125;&lt;script&gt; ,欢迎访问www.zeze.info 台湾 "</span>);</span><br><span class="line"></span><br><span class="line">        FilterChain filterChain = <span class="keyword">new</span> FilterChain();</span><br><span class="line"></span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> HTMLfilter());</span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> SensitiveFilter());</span><br><span class="line">        filterChain.doFilter(msg);</span><br><span class="line"></span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码版本说明-1"><a href="#代码版本说明-1" class="headerlink" title="代码版本说明"></a>代码版本说明</h2><blockquote><p>此时处理链是可以配置，比如我要先处理<code>HTML</code>,或者先处理<code>Sensitive</code>,但是现在需求就是我这条链可以加入其它链，而且如果上一条链处理不通过 下面所以的链都不执行了</p></blockquote><h2 id="代码v4-v5"><a href="#代码v4-v5" class="headerlink" title="代码v4-v5"></a>代码v4-v5</h2><p><a href="https://github.com/zhangzeli/design_patterns/tree/master/src/main/java/com/cor/v4" target="_blank" rel="external nofollow noopener noreferrer">代码版本v4</a><br><a href="https://github.com/zhangzeli/design_patterns/tree/master/src/main/java/com/cor/v5" target="_blank" rel="external nofollow noopener noreferrer">代码版本v5</a></p><blockquote><p>这里直接贴出 V5,我改进的有两个地方，第一让FilterChain也去实现Filter。这样我在addFilter的时候也可以加FilterChain.还有一个小技巧，在addFilter的方法返回一个FilterChain这样可以在调用的时链式调用。将doFilter方法返回值改为Boolean。即可实现新的需求</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cor.v5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Msg</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String msg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Msg&#123;"</span> +</span><br><span class="line">                <span class="string">"msg='"</span> + msg + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Msg msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    List&lt;Filter&gt; filters = <span class="keyword">new</span>  ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterChain <span class="title">addFilter</span><span class="params">(Filter filter)</span></span>&#123;</span><br><span class="line">        filters.add(filter);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteFilter</span><span class="params">(Filter filter)</span></span>&#123;</span><br><span class="line">        filters.remove(filter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链条处理完</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Msg msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( Filter f : filters)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> r = f.doFilter(msg);</span><br><span class="line">            <span class="keyword">if</span>(!r)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTMLfilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">( Msg msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一步网页脚本</span></span><br><span class="line">        String r = msg.getMsg();</span><br><span class="line">        r = r.replace(<span class="string">"&lt;"</span>,<span class="string">"&amp;lt;"</span>);</span><br><span class="line">        r = r.replace(<span class="string">"&gt;"</span>,<span class="string">"&amp;gt;"</span>);</span><br><span class="line">        msg.setMsg(r);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SensitiveFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">( Msg msg)</span> </span>&#123;</span><br><span class="line">        String r = msg.getMsg();</span><br><span class="line">        <span class="comment">//第二步处理敏感词</span></span><br><span class="line">        r = r.replace(<span class="string">"台湾"</span>,<span class="string">"中国"</span>);</span><br><span class="line">        msg.setMsg(r);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">URLFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Msg msg)</span> </span>&#123;</span><br><span class="line">        String r = msg.getMsg();</span><br><span class="line">        r = r.replace(<span class="string">"zeze.info"</span>,<span class="string">"^_^"</span>);</span><br><span class="line">        msg.setMsg(r);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SQLFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Msg msg)</span> </span>&#123;</span><br><span class="line">        String r = msg.getMsg();</span><br><span class="line">        r = r.replace(<span class="string">"OR"</span>,<span class="string">""</span>);</span><br><span class="line">        r = r.replace(<span class="string">"select"</span>,<span class="string">""</span>);</span><br><span class="line">        msg.setMsg(r);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Msg msg = <span class="keyword">new</span> Msg();</span><br><span class="line">        <span class="comment">//在论坛发帖</span></span><br><span class="line">        msg.setMsg(<span class="string">"大家好：&#125;&lt;script&gt; ,欢迎访问www.zeze.info 台湾 OR 1=1 "</span>);</span><br><span class="line"></span><br><span class="line">        FilterChain filterChain = <span class="keyword">new</span> FilterChain();</span><br><span class="line"></span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> HTMLfilter())</span><br><span class="line">                .addFilter(<span class="keyword">new</span> SensitiveFilter());</span><br><span class="line">        FilterChain filterChain2 = <span class="keyword">new</span> FilterChain();</span><br><span class="line">        filterChain2.addFilter(<span class="keyword">new</span> URLFilter());</span><br><span class="line">        filterChain2.addFilter(<span class="keyword">new</span> SQLFilter());</span><br><span class="line">        filterChain.addFilter(filterChain2);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="servlet-filter实现"><a href="#servlet-filter实现" class="headerlink" title="servlet filter实现"></a>servlet filter实现</h2><blockquote><p>先统一处理Request，然后在处理Response</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/design/j4/20200611162114.png!www.zeze.info" alt="servlet filter"></p><p><a href="https://github.com/zhangzeli/design_patterns/tree/master/src/main/java/com/cor/v5" target="_blank" rel="external nofollow noopener noreferrer">代码版本v6</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Request request,Response response,FilterChain filterChain)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    List&lt;Filter&gt; filters = <span class="keyword">new</span>  ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterChain <span class="title">addFilter</span><span class="params">(Filter filter)</span></span>&#123;</span><br><span class="line">        filters.add(filter);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteFilter</span><span class="params">(Filter filter)</span></span>&#123;</span><br><span class="line">        filters.remove(filter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链条处理完</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Request request,Response response,FilterChain filterChain)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==filters.size())&#123;<span class="keyword">return</span> <span class="keyword">true</span>;&#125;</span><br><span class="line">        Filter chain = filters.get(index);</span><br><span class="line">        index++;</span><br><span class="line">        chain.doFilter(request,response,filterChain);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span></span>&#123;</span><br><span class="line">    String data=<span class="string">"Request:"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Response</span></span>&#123;</span><br><span class="line">    String data=<span class="string">"Response:"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTMLfilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Request request,Response response,FilterChain filterChain)</span> </span>&#123;</span><br><span class="line">        request.setData(request.getData()+<span class="string">"HTMLfilter--"</span>);</span><br><span class="line">        filterChain.doFilter(request, response, filterChain);</span><br><span class="line">        response.setData(response.getData()+<span class="string">"HTMLfilter--"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SensitiveFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Request request,Response response,FilterChain filterChain)</span> </span>&#123;</span><br><span class="line">        request.setData(request.getData()+<span class="string">"SensitiveFilter--"</span>);</span><br><span class="line">        filterChain.doFilter(request, response, filterChain);</span><br><span class="line">        response.setData(response.getData()+<span class="string">"SensitiveFilter--"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Response response = <span class="keyword">new</span> Response();</span><br><span class="line">        Request request = <span class="keyword">new</span> Request();</span><br><span class="line"></span><br><span class="line">        FilterChain filterChain = <span class="keyword">new</span> FilterChain();</span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> HTMLfilter()).addFilter(<span class="keyword">new</span> SensitiveFilter());</span><br><span class="line">        filterChain.doFilter(request,response,filterChain);</span><br><span class="line">        System.out.println(request.getData());</span><br><span class="line">        System.out.println(response.getData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对你有帮助，请转发，谢谢</p><h1 id="博主主页"><a href="#博主主页" class="headerlink" title="博主主页"></a><strong><a href="http://www.zeze.info">博主主页</a></strong></h1><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/java/design/j3/"/>
      <url>/java/design/j3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="业务场景模拟"><a href="#业务场景模拟" class="headerlink" title="业务场景模拟"></a>业务场景模拟</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小孩在睡觉是被观察者</span><br><span class="line"></span><br><span class="line">爸爸，妈妈，和宠物是观察者</span><br><span class="line"></span><br><span class="line">小孩状态：睡觉 和 刚睡醒之后可能哭闹（cry）</span><br></pre></td></tr></table></figure><h1 id="代码版本V1"><a href="#代码版本V1" class="headerlink" title="代码版本V1"></a>代码版本V1</h1><p><a href="https://github.com/zhangzeli/design_patterns/blob/master/src/main/java/com/observer/v1/Main.java" target="_blank" rel="external nofollow noopener noreferrer">Github地址</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.observer.v1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> cry = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Dad dad = <span class="keyword">new</span> Dad();</span><br><span class="line">    <span class="keyword">private</span> Mum mum = <span class="keyword">new</span> Mum();</span><br><span class="line">    <span class="keyword">private</span> Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">wekeup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cry = <span class="keyword">true</span>;</span><br><span class="line">        dad.feed();</span><br><span class="line">        dog.Wang();</span><br><span class="line">        mum.hug();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dad</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dad feeding ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mum</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hug</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"mum hugging ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Wang</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dog wang ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Child child = <span class="keyword">new</span> Child();</span><br><span class="line">        child.wekeup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个版本代码比较简单，被观察者持有观察者引用,当业代码调用小孩的weakup时触发通知，此时爸爸，妈妈，宠物会作出不同的反应。</span><br></pre></td></tr></table></figure><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可见代码耦合度非常高，当新增一个观察者时必须通过修改源码才能实现，比如增加一个叔叔观察小孩，而且观察者的反应也不应该耦合到被观察者身上，比如狗见鸡跳墙也可能会叫</span><br></pre></td></tr></table></figure><h2 id="代码改进"><a href="#代码改进" class="headerlink" title="代码改进"></a>代码改进</h2><ol><li>定义Observer接口 里面有个方法叫 action 。抽象出观察者，方便扩展</li><li>被观察者定义一个集合用来存观察者</li><li>以下代码是在代码块里面初始化的观察者，实际上可以放在配置文件里面初始化观察者。这也新增观察者不会再需要修改源码了</li></ol><h1 id="代码版本V2"><a href="#代码版本V2" class="headerlink" title="代码版本V2"></a>代码版本V2</h1><p><a href="https://github.com/zhangzeli/design_patterns/blob/master/src/main/java/com/observer/v2/Main.java" target="_blank" rel="external nofollow noopener noreferrer">Github地址</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.observer.v2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> cry = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        observers.add(<span class="keyword">new</span> Dad());</span><br><span class="line">        observers.add(<span class="keyword">new</span> Mum());</span><br><span class="line">        observers.add(<span class="keyword">new</span> Dog());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">wekeup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cry = <span class="keyword">true</span>;</span><br><span class="line">        observers.forEach(o-&gt;&#123;</span><br><span class="line">            o.action();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dad</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dad feeding ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        feed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mum</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hug</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"mum hugging ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hug();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wang</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dog wang ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        wang();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Child child = <span class="keyword">new</span> Child();</span><br><span class="line">        child.wekeup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新需求"><a href="#新需求" class="headerlink" title="新需求"></a>新需求</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对应观察者（爸爸，妈妈，宠物）来说只能观察小孩，我们现在需求，比如观察厨房里面的汤做好没。观察家里闹钟等等，如此我们需要将被观察者也进行抽象（定义一个Subject接口，被观察者去实现，现在指的是小孩，汤，水）。被观察者会发出不同的事件，比如闹钟响事件，汤做好了事件，小孩醒了事件，水烧开了事件，所以定义事件对象（Event）</span><br></pre></td></tr></table></figure><h2 id="代码版本V3"><a href="#代码版本V3" class="headerlink" title="代码版本V3"></a>代码版本V3</h2><p><a href="https://github.com/zhangzeli/design_patterns/blob/master/src/main/java/com/observer/v3/Main.java" target="_blank" rel="external nofollow noopener noreferrer">Github地址</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不同的观察者根据事件类型不同，做不同的处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">(Event event)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> cry = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">wekeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cry = <span class="keyword">true</span>;</span><br><span class="line">        observers.forEach(o -&gt; &#123;</span><br><span class="line">            Event e = <span class="keyword">new</span> Event(System.currentTimeMillis(),<span class="string">"sleep"</span>,<span class="keyword">this</span>);</span><br><span class="line">            o.action(e);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        wekeup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件发生事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timestamp;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件名称，或者类型，可以定义枚举。咋这里为了掩饰方便</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件源对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Subject source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Event</span><span class="params">(<span class="keyword">long</span> timestamp, String name, Subject source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timestamp = timestamp;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Subject <span class="title">getSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dad</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">feed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dad feeding ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        feed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mum</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">hug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"mum hugging ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        hug();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">wang</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dog wang ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        wang();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> Child();</span><br><span class="line">        subject.addObserver(<span class="keyword">new</span> Dad());</span><br><span class="line">        subject.addObserver(<span class="keyword">new</span> Mum());</span><br><span class="line">        subject.addObserver(<span class="keyword">new</span> Dog());</span><br><span class="line">        subject.addObserver((e)-&gt;&#123;</span><br><span class="line">            System.out.println(e.getName());</span><br><span class="line">            System.out.println(e.getTimestamp());</span><br><span class="line">            System.out.println(e.getSource());</span><br><span class="line">        &#125;);</span><br><span class="line">        subject.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>缺点：</p><ol><li><p>一个观察目标对象有很多直接和间接的观察者，将所有的观察者都通知到会很花时间。</p></li><li><p>如果在观察者和观察目标之间存在循环依赖，观察目标会触发他们之间循环调用，可能会死循环。</p></li></ol><p>使用场景：</p><ol><li><p>一个对象的改变将导致一个或多个其他对象也发生改变，而不知道具体改变了多少。也不知道改变了谁。</p></li><li><p>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象将影响C以此类推。创建触发链条机制。</p></li></ol><h1 id="博主主页"><a href="#博主主页" class="headerlink" title="博主主页"></a><strong><a href="http://www.zeze.info">博主主页</a></strong></h1><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式：访问者（Visitoe）模式</title>
      <link href="/java/design/j2/"/>
      <url>/java/design/j2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>什么叫做访问，如果大家学过数据结构，对于这点就很清晰了，遍历就是访问的一般形式，单独读取一个元素进行相应的处理也叫作访问，读取到想要查看的内容+对其进行处理就叫做访问，那么我们平常是怎么访问的，基本上就是直接拿着需要访问的地址（引用）来读写内存就可以了。</p><p>为什么还要有一个访问者模式呢，这就要放到OOP之中了，在面向对象编程的思想中，我们使用类来组织属性，以及对属性的操作，那么我们理所当然的将访问操作放到了类的内部，这样看起来没问题，但是当我们想要使用另一种遍历方式要怎么办呢，我们必须将这个类进行修改，这在设计模式中是大忌，在设计模式中就要保证，对扩展开放，对修改关闭的开闭原则。</p><p>因此，我们思考，可不可以将<strong>访问操作独立出来</strong>变成一个新的类，当我们需要增加访问操作的时候，直接增加新的类，原来的代码不需要任何的改变，如果可以这样做，那么我们的程序就是好的程序，因为可以扩展，符合开闭原则。而访问者模式就是实现这个的，使得使用不同的访问方式都可以对某些元素进行访问。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/java/design/j2/20200522183840.png!www.zeze.info" alt="类图"></p><blockquote><p>涉及角色</p></blockquote><ul><li>Visitor 抽象访问者角色，为该对象结构中具体元素角色声明一个访问操作接口。该操作接口的名字和参数标识了发送访问请求给具体访问者的具体元素角色，这样访问者就可以通过该元素角色的特定接口直接访问它。</li><li>ConcreteVisitor (下文中ListVisitor和FileVisitor).具体访问者角色，实现Visitor声明的接口。</li><li>Element  定义一个接受访问操作(accept())，它以一个访问者(Visitor)作为参数。</li><li>ConcreteElement  (下文中Directory和File) 具体元素，实现了抽象元素(Element)所定义的接受操作接口。</li><li>ObjectStructure (下文中Entry) 结构对象角色，这是使用访问者模式必备的角色。它具备以下特性：能枚举它的元素；可以提供一个高层接口以允许访问者访问它的元素；如有需要，可以设计成一个复合对象或者一个聚集（如一个列表或无序集合）</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><strong>Element 接口</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Entry 类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(String prefix)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">printList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printList(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Entry <span class="title">add</span><span class="params">(Entry entry)</span> <span class="keyword">throws</span> RuntimeException</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Iterator <span class="title">iterator</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getName()+<span class="string">"&lt;"</span>+getSize()+<span class="string">"&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>File 类：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String name,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.size=size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        System.out.println(prefix+<span class="string">"/"</span>+<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//  System.out.println("开始访问文件:"+this);</span></span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">       <span class="comment">// System.out.println("结束访问文件:"+this);</span></span><br><span class="line">       <span class="comment">// System.out.println();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Directory类：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Directory</span> <span class="keyword">extends</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    ArrayList entrys=<span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Directory</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">        Iterator it=entrys.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            size+=((Entry)it.next()).getSize();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Entry <span class="title">add</span><span class="params">(Entry entry)</span> </span>&#123;</span><br><span class="line">        entrys.add(entry);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> entrys.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        System.out.println(prefix+<span class="string">"/"</span>+<span class="keyword">this</span>);</span><br><span class="line">        Iterator it=entrys.iterator();</span><br><span class="line">        Entry entry;</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            entry=(Entry)it.next();</span><br><span class="line">            entry.printList(prefix+<span class="string">"/"</span>+name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//  System.out.println("开始访问文件夹:"+this);</span></span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">     <span class="comment">//   System.out.println("结束访问文件夹:"+this);</span></span><br><span class="line">     <span class="comment">//   System.out.println();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Visitor 类：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(File file)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Directory directory)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ListVisitor类：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListVisitor</span> <span class="keyword">extends</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String currentDir = <span class="string">""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        System.out.println(currentDir+<span class="string">"/"</span>+file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Directory directory)</span> </span>&#123;</span><br><span class="line">        System.out.println(currentDir+<span class="string">"/"</span>+directory);</span><br><span class="line">        String saveDir=currentDir;</span><br><span class="line">        currentDir+=(<span class="string">"/"</span>+directory.getName());</span><br><span class="line">        Iterator it=directory.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            Entry entry=(Entry)it.next();</span><br><span class="line">            entry.accept(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        currentDir=saveDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>FileVisitor 类：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileVisitor</span> <span class="keyword">extends</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String currentDir = <span class="string">""</span>;</span><br><span class="line">    String suffix;</span><br><span class="line">    ArrayList files=<span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileVisitor</span><span class="params">(String suffix)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.suffix = suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(file.getName().endsWith(suffix))&#123;</span><br><span class="line">         <span class="comment">// System.out.println(currentDir+"/"+file);</span></span><br><span class="line">            files.add(currentDir+<span class="string">"/"</span>+file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Directory directory)</span> </span>&#123;</span><br><span class="line">        String saveDir=currentDir;</span><br><span class="line">        currentDir+=(<span class="string">"/"</span>+directory.getName());</span><br><span class="line">        Iterator it=directory.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            Entry entry=(Entry)it.next();</span><br><span class="line">            entry.accept(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        currentDir=saveDir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Iterator <span class="title">getFiles</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> files.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Client类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.visitor.t1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Directory root=<span class="keyword">new</span> Directory(<span class="string">"根目录"</span>);</span><br><span class="line"></span><br><span class="line">        Directory life=<span class="keyword">new</span> Directory(<span class="string">"我的生活"</span>);</span><br><span class="line">        File eat=<span class="keyword">new</span> File(<span class="string">"吃火锅.txt"</span>,<span class="number">100</span>);</span><br><span class="line">        File sleep=<span class="keyword">new</span> File(<span class="string">"睡觉.html"</span>,<span class="number">100</span>);</span><br><span class="line">        File study=<span class="keyword">new</span> File(<span class="string">"学习.txt"</span>,<span class="number">100</span>);</span><br><span class="line">        life.add(eat);</span><br><span class="line">        life.add(sleep);</span><br><span class="line">        life.add(study);</span><br><span class="line"></span><br><span class="line">        Directory work=<span class="keyword">new</span> Directory(<span class="string">"我的工作"</span>);</span><br><span class="line">        File write=<span class="keyword">new</span> File(<span class="string">"写博客.doc"</span>,<span class="number">200</span>);</span><br><span class="line">        File paper=<span class="keyword">new</span> File(<span class="string">"写论文.html"</span>,<span class="number">200</span>);</span><br><span class="line">        File homework=<span class="keyword">new</span> File(<span class="string">"写家庭作业.docx"</span>,<span class="number">200</span>);</span><br><span class="line">        work.add(write);</span><br><span class="line">        work.add(paper);</span><br><span class="line">        work.add(homework);</span><br><span class="line"></span><br><span class="line">        Directory relax=<span class="keyword">new</span> Directory(<span class="string">"我的休闲"</span>);</span><br><span class="line">        File music=<span class="keyword">new</span> File(<span class="string">"听听音乐.js"</span>,<span class="number">200</span>);</span><br><span class="line">        File walk=<span class="keyword">new</span> File(<span class="string">"出去转转.psd"</span>,<span class="number">200</span>);</span><br><span class="line">        relax.add(music);</span><br><span class="line">        relax.add(walk);</span><br><span class="line"></span><br><span class="line">        Directory read=<span class="keyword">new</span> Directory(<span class="string">"我的阅读"</span>);</span><br><span class="line">        File book=<span class="keyword">new</span> File(<span class="string">"学习书籍.psd"</span>,<span class="number">200</span>);</span><br><span class="line">        File novel=<span class="keyword">new</span> File(<span class="string">"娱乐小说.txt"</span>,<span class="number">200</span>);</span><br><span class="line">        read.add(book);</span><br><span class="line">        read.add(novel);</span><br><span class="line"></span><br><span class="line">        root.add(life);</span><br><span class="line">        root.add(work);</span><br><span class="line">        root.add(relax);</span><br><span class="line">        root.add(read);</span><br><span class="line"></span><br><span class="line">        root.accept(<span class="keyword">new</span> ListVisitor());</span><br><span class="line">        System.out.println(<span class="string">"========================"</span>);</span><br><span class="line">        FileVisitor visitor=<span class="keyword">new</span> FileVisitor(<span class="string">".psd"</span>);</span><br><span class="line">        root.accept(visitor);</span><br><span class="line">        Iterator it = visitor.getFiles();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/java/design/j2/20200522183310.png!www.zeze.info" alt="运行结果"></p><p>可以看到我们的运行结果第一个和使用Composite模式的结果一样，第二个是实现另一种方式的访问，只访问文件后缀为某一特定的内容的文件，结果也是正确的，并且为了说明我们的访问还可以保存下来访问的结果，我们使用了ArrayList自带的迭代器将保存到ArrayList中的结果输出出来，我们当然也可以直接在遍历的时候就输出出来，这个看我们的使用要求了。由此可以看到在保证数据结构（File和Directory）不发生变化的情况下（没有新增或者删除），可以非常方便增加新的一种访问方法，只需要新增加一个访问类即可，但是如果我们数据结构发生变化之后，就需要修改继承自Visitor类的所有类了，这也违背了开闭原则，因此我们应该认真考虑，到底我们的数据结构是定死的还是经常变化的。没有任何一种设计模式是十全十美的，总是有所取舍，有所利弊，根据实际情况来选择才是最好的设计方法。</p><p>这里要说明一下<strong>双重分发</strong>机制，我们来看一下最核心的遍历逻辑，结合组合模式的时候我们已经分析过的遍历方法，递归，大家觉得这次我们要怎么在数据结构外面进行遍历，肯定还是要使用递归了，可是数据结构中的数据在类的内部，怎么递归到内部呢，我们想到了间接递归，也就是双重分发。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        System.out.println(prefix+<span class="string">"/"</span>+<span class="keyword">this</span>);</span><br><span class="line">        Iterator it=entrys.iterator();</span><br><span class="line">        Entry entry;</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            entry=(Entry)it.next();</span><br><span class="line">            entry.printList(prefix+<span class="string">"/"</span>+name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的代码是在组合模式类的内部遍历的过程，可以明确的看到递归（直接递归）的使用。我们看一下访问者模式中的间接递归：</p><p><strong>Directory类中：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println("开始访问文件夹:"+this);</span></span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//System.out.println("结束访问文件夹:"+this);</span></span><br><span class="line">        <span class="comment">//System.out.println();</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>在ListVisitor中：</strong></p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="built_in">File</span> file)</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(currentDir+<span class="string">"/"</span>+file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Directory directory)</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(currentDir+<span class="string">"/"</span>+directory);</span><br><span class="line">        <span class="keyword">String</span> saveDir=currentDir;</span><br><span class="line">        currentDir+=(<span class="string">"/"</span>+directory.getName());</span><br><span class="line">        Iterator it=directory.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            Entry entry=(Entry)it.next();</span><br><span class="line">            entry.accept(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        currentDir=saveDir;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们看到了<code>entry.accept(this)</code>这句话，这句话是非常重要的，我们在Client中是这样用的：</p><blockquote><p>root.accept(new ListVisitor());</p></blockquote><p>在accept函数中调用visit，同样在visit中调用accept，这就是间接递归，或者叫做双重分发。产生的原因就是访问者需要和被访问者相互交流，才能一步步的得到想要的数据。我们可以考虑主持人采访一个明星，那么这个明星接受采访，把自己基本信息（能问的问题以及某些答案）告诉主持人，问主持人有问题吗？如果主持人有问题（还能向下问）要问那么就再次拿着新的问题问这个明星，这个明星再次将自己关于这方面的信息告诉主持人；如果没有问题（得到答案），主持人将信息总结之后说出来。就这样一直持续下去，直到主持人没问题问了，并且明星的信息也都被问到了，这样采访就结束了。由此可见，很多时候设计模式都是和生活密切相关的，生活中的常识有时候就是一些套路，而这种套路就是一种抽象的模式。</p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ol><li><p>优点</p><p>符合单一职责原则<br>元素类可以通过接受不同的访问者来实现对不同操作的扩展。</p></li><li><p>缺点</p><p>具体元素对访问者公布细节，违背了迪米特法则。<br>违背了依赖倒置原则，访问者依赖的是具体元素，而不是抽象元素。</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>  访问者模式是一个非常有意思的模式，因为自己需要得到数据就需要向被访者索取，如果能够一次索取成功，访问就结束了，如果还需要其他信息，则再次向被访问者索取，就这样知道拿到自己需要的所有数据。在本例中借用了组合模式中的数据结构，那是因为这种树形的结构很适合我们进行递归访问。访问者模式和迭代器模式都是在某种数据结构上进行处理，一种是对数据结构中的元素进行某种特定的处理，另一种是用某种方式遍历所有元素。在实际应用中，我们根据实际需要来考虑是不是需要双重分发机制。在本例中的访问者模式中用到了组合模式、委托（组合）、双重分发等原理，便于新增访问方式，不便于对数据结构的修改。</p><p><a href="https://github.com/zhangzeli/design_patterns/tree/master/src/main/java/com/visitor/t1" target="_blank" rel="external nofollow noopener noreferrer">代码地址</a></p><h1 id="博主主页"><a href="#博主主页" class="headerlink" title="博主主页"></a><strong><a href="http://www.zeze.info">博主主页</a></strong></h1><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式一篇就够了</title>
      <link href="/java/design/j1/"/>
      <url>/java/design/j1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>很常用的结构型设计模式，用做两个不兼容的接口之间的桥梁，结合了两个独立接口的功能。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><div class="note default"> 中国标准电压是 220V，电器也是支持 220V的，代码实现使用电器的逻辑。</div><blockquote><p>创建电器类</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChinaDevice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用电器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voltage 输入电压</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(<span class="keyword">int</span> voltage)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"输入电压"</span> + voltage + <span class="string">"V"</span>);</span><br><span class="line">        <span class="keyword">if</span> (voltage == <span class="number">220</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"中国电器正常运行"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"中国电器烧毁"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建电源类</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChinaPower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ChinaDevice device)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用220V电压运行</span></span><br><span class="line">        device.use(<span class="number">220</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用电器：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceUnitTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建220V电源</span></span><br><span class="line">        ChinaPower chinaPower = <span class="keyword">new</span> ChinaPower();</span><br><span class="line">        <span class="comment">// 创建电器</span></span><br><span class="line">        ChinaDevice device = <span class="keyword">new</span> ChinaDevice();</span><br><span class="line">        <span class="comment">// 运行电器</span></span><br><span class="line">        chinaPower.run(device);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>开发完成，电器正常运行起来了。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入电压220V</span><br><span class="line">中国电器正常运行</span><br></pre></td></tr></table></figure><h3 id="拓展需求"><a href="#拓展需求" class="headerlink" title="拓展需求"></a>拓展需求</h3><div class="note default"> 产品经理拿来一个美国电器，仅支持 110V 电压，要求也要正常运行。</div><blockquote><p>考虑到每个国家电器标准都不一样，需求必然会经常变更，这次我们抽离出一个接口：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Device</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用电器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voltage 输入电压</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">(<span class="keyword">int</span> voltage)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建美国电器类：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">USADevice</span> <span class="keyword">implements</span> <span class="title">Device</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(<span class="keyword">int</span> voltage)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"输入电压"</span> + voltage + <span class="string">"V"</span>);</span><br><span class="line">        <span class="keyword">if</span> (voltage == <span class="number">110</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"美国电器正常运行"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"美国电器烧毁"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>美国电器使用 220V 必然烧毁，那么应该如何解决呢？</p></blockquote><blockquote><p>很简单，创建一个美国电源类就可以了：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">USAPower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Device device)</span> </span>&#123;</span><br><span class="line">        device.use(<span class="number">110</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note default"> 这种方式当然没有问题，但是随着国家的增多，电源类也会越来越多。从实际生活的角度看，我们也不可能拥有多个电压的电源，只能借助变压器（适配器）来解决该问题。</div><h3 id="引入适配器模式"><a href="#引入适配器模式" class="headerlink" title="引入适配器模式"></a>引入适配器模式</h3><blockquote><p>创建一个 220V 的适配器：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChinaAdapter</span> <span class="keyword">implements</span> <span class="title">Device</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> USADevice mUsaDevice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认中国电器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChinaAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 适配美国电器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChinaAdapter</span><span class="params">(USADevice usaDevice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mUsaDevice = usaDevice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(<span class="keyword">int</span> voltage)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"输入电压"</span> + voltage + <span class="string">"V"</span>);</span><br><span class="line">        <span class="keyword">if</span> (mUsaDevice != <span class="keyword">null</span>) &#123;<span class="comment">// 适配美国电器</span></span><br><span class="line">            <span class="keyword">if</span> (voltage == <span class="number">110</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"美国电器正常运行"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"适配器工作...进行变压"</span>);</span><br><span class="line">                voltage = <span class="number">110</span>;</span><br><span class="line">                System.out.println(<span class="string">"美国电器在"</span> + voltage + <span class="string">"V正常运行"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 默认中国电器</span></span><br><span class="line">            <span class="keyword">if</span> (voltage == <span class="number">220</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"中国电器正常运行"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"中国电器烧毁"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细对比<code>ChinaAdapter</code>和<code>ChinaDevice</code>，可以发现，这个适配器只是扩展了<code>ChinaDevice</code>，使其支持<code>USADevice</code>美国电器，本质上还是中国电器</p><p>[x] 无参构造 创建的是中国电器，在 use 方法中，仅支持 220V。<br>[x] 带参构造 创建的是美国电器，在 use 方法中，将 220V 转为 110V。</p><p>使用适配器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceUnitTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建220V电源</span></span><br><span class="line">        ChinaPower chinaPower = <span class="keyword">new</span> ChinaPower();</span><br><span class="line">        <span class="comment">// 适配器</span></span><br><span class="line">        Device device = <span class="keyword">new</span> ChinaAdapter(<span class="keyword">new</span> USADevice());</span><br><span class="line">        chinaPower.run(device);</span><br><span class="line">        <span class="comment">// 默认构造，就是支持220V的中国电器</span></span><br><span class="line">        device = <span class="keyword">new</span> ChinaAdapter();</span><br><span class="line">        chinaPower.run(device);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><blockquote><p>在这种模式下，电源不需要知道是哪种电器，只要提供 220V 电压即可，具体操作的什么类，由适配器决定。</p></blockquote><p>适配器模式具有以下优势：</p><ol><li>可以让任何两个没有关联的类一起运行。</li><li>提高了类的复用。</li><li>灵活性好。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>[x] 意图：将一个类的接口转换成另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>[x] 主要解决：常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。<br>[x] 如何解决：继承类或实现接口（推荐）。<br>[x] 关键代码：适配器继承已有的对象，实现想要的目标接口。<br>[x] 缺点：过多地使用适配器，会使代码非常凌乱。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接进行重构。<br>[x] 注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p><h1 id="博主主页"><a href="#博主主页" class="headerlink" title="博主主页"></a><strong><a href="http://www.zeze.info">博主主页</a></strong></h1><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6-判断Js数据类型</title>
      <link href="/javaScript/cacl/cacl3/"/>
      <url>/javaScript/cacl/cacl3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Typeof的返回值"><a href="#Typeof的返回值" class="headerlink" title="Typeof的返回值"></a>Typeof的返回值</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>           ---&gt; <span class="string">'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'hello'</span>     ---&gt; <span class="string">'string'</span></span><br><span class="line"><span class="keyword">typeof</span> alert       ---&gt; <span class="string">'function'</span></span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]     ---&gt; <span class="string">'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;   ---&gt; <span class="string">'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>        ---&gt; <span class="string">'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>         ---&gt; <span class="string">'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>   ---&gt; <span class="string">'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>()    ---&gt; <span class="string">'symbol'</span></span><br></pre></td></tr></table></figure><blockquote><p>疑惑：typeof null返回’object’，typeof NaN竟然返回’number’（NaN有专门的方法检测—isNaN,那么我们可不可以有专门的方式检测null呢？比如isNull来判断null类型），NaN本意为Not A Number,这就无法理解。查了一下，这是好多年的坑了。</p></blockquote><h1 id="利用Object-prototype-toString"><a href="#利用Object-prototype-toString" class="headerlink" title="利用Object.prototype.toString"></a>利用Object.prototype.toString</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="string">"hello"</span>));<span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="number">123</span>));<span class="comment">//[object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>));<span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>));<span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>));<span class="comment">//[object Null]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(&#123;<span class="attr">name</span>: <span class="string">"jerry"</span>&#125;));<span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;));<span class="comment">//[object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call([]));<span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>));<span class="comment">//[object Date]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="regexp">/\d/</span>));<span class="comment">//[object RegExp]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> foo()));<span class="comment">//[object Object]</span></span><br></pre></td></tr></table></figure><blockquote><p>问题解决了，但是返回值带[]看着太难受了。</p></blockquote><h1 id="自定义方式"><a href="#自定义方式" class="headerlink" title="自定义方式"></a>自定义方式</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//es5方式，返回布尔值</span></span><br><span class="line"><span class="keyword">const</span> isType = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//es6方式，返回布尔值</span></span><br><span class="line"><span class="keyword">const</span> isType1 = <span class="function"><span class="params">type</span> =&gt;</span> <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则匹配，返回真正的类型值</span></span><br><span class="line"><span class="keyword">const</span> isType2 = <span class="function"><span class="params">type</span> =&gt;</span>(<span class="regexp">/^\[object\s(.*)\]$/</span>.exec(<span class="built_in">Object</span>.prototype.toString.call(type)))[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用，先定义要检测的类型,传入Object.prototype.toString.call返回的值，如：Array，Number...</span></span><br><span class="line"><span class="keyword">const</span> isArray = isType(<span class="string">'Array'</span>);<span class="comment">// 注意首字母大写</span></span><br><span class="line"><span class="keyword">const</span> isSymbol = isType1(<span class="string">'Symbol'</span>);</span><br><span class="line">isArray([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) ;<span class="comment">// true</span></span><br><span class="line">isSymbol(<span class="built_in">Symbol</span>()); <span class="comment">// true</span></span><br><span class="line">isType2(<span class="literal">null</span>); <span class="comment">// 'Null'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************包装一下**************************/</span></span><br><span class="line"><span class="keyword">const</span> isType = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj).includes(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> types = [<span class="string">'String'</span>,<span class="string">'Object'</span>,<span class="string">'Array'</span>,<span class="string">'Null'</span>,<span class="string">'Undefined'</span>,<span class="string">'Boolean'</span>]</span><br><span class="line"><span class="keyword">let</span> fns = &#123;&#125;;</span><br><span class="line">types.forEach(<span class="function"><span class="params">type</span> =&gt;</span>&#123;</span><br><span class="line">    fns[<span class="string">'is'</span>+type] = isType(type)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.info(fns.isString(a))<span class="comment">//函数柯里化</span></span><br></pre></td></tr></table></figure><p><strong><a href="http://www.zeze.info">博主主页</a></strong></p><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>都说ThreadLocal被面试官问烂了，可为什么面试官还是喜欢继续问</title>
      <link href="/java/concurrent/threadLocal/"/>
      <url>/java/concurrent/threadLocal/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原创 泽泽</p><p><strong>面试官：</strong> 有如下场景：在多线程并发情况下，有一个共享变量，不同线程设置不同值后，各线程只想获取自己设置的值，如何实现？</p><p><strong>小小白：</strong> 使用ThreadLocal，通过ThreadLocal实例对象的set方法设置各线程自己的值，通过ThreadLocal实例对象的get方法获取各线程自己设置的值。</p><p><strong>面试官：</strong> 写一下简单的实现代码？</p><p><strong>小小白：</strong> 噼里啪啦写了如下代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">    threadLocal.set(<span class="string">"hello"</span>);</span><br><span class="line">    System.out.println(<span class="string">"main thread:"</span> + threadLocal.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            threadLocal.set(<span class="string">"world"</span>);</span><br><span class="line">            System.out.println(<span class="string">"new Thread1:"</span> + threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            threadLocal.set(<span class="string">"!!!"</span>);</span><br><span class="line">            System.out.println(<span class="string">"new Thread2:"</span> + threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>面试官：</strong> ThreadLocal源码有看过吗？</p><p><strong>小小白：</strong> 看过。</p><p><strong>面试官：</strong> 那说一下ThreadLocal的实现原理？</p><p><strong>小小白：</strong> 从ThreadLocal的set方法的源码开始：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)&#123;</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>set方法的第一步是获取当前线程实例，然后通过getMap方法获取当前线程实例的<code>threadLocals</code>属性，<code>threadLocals</code>是<code>ThreadLocalMap</code>类型的变量，而<code>ThreadLocalMap</code>则是一个定制化的<code>HashMap</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadLocal类中的getMap方法</span></span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t.threadLocals;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread类中声明的threadLocals变量</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><blockquote><p>如果getMap方法获取的ThreadLocalMap类型变量map不等于null，则以当前ThreadLocal实例对象为key，传入的value值为value存到这个ThreadLocalMap中，需要注意的是在实际存储的时候，key使用的是ThreadLocal的弱引用。</p></blockquote><blockquote><p>如果getMap方法获取的ThreadLocalMap类型变量map等于null，则调用createMap方法创建一个ThreadLocalMap实例对象，并以当前ThreadLocal实例对象为key，传入的value值为value存到这个ThreadLocalMap中。</p></blockquote><blockquote><p>看到这里就会明白，使用ThreadLocal时，每个线程维护一个ThreadLocalMap映射表，映射表的key是ThreadLocal实例，并且使用的是ThreadLocal的弱引用 ，value是具体需要存储的Object。</p></blockquote><blockquote><p>紧接着进入ThreadLocal类的get方法，这个方法的第一步也是获取当前线程，通过getMap方法获取当前线程所维护的ThreadLocalMap实例，如果ThreadLocalMap对象实例不等于null，则以当前ThreadLocal对象实例为key从ThreadLocalMap中获取所需要的值。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (T)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果getMap方法获取到的ThreadLocalMap对象实例等于null，则调用setInitialValue方法初始化一个ThreadLocalMap，并以当前ThreadLocal实例对象为key，null值为value存到这个ThreadLocalMap中，同时返回null。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)&#123;</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>面试官：</em>看来这部分很熟悉，那为什么Thread类中声明的threadLocals变量是map结构的？</p><p><em>小小白：</em>因为每个线程都可以关联很多个ThreadLocal变量。</p><p><em>面试官：</em>你知道ThreadLocal使用不当会发生内存泄露吗？</p><p><em>小小白：</em>知道。每一个Thread维护一个ThreadLocalMap映射表，映射表的key是ThreadLocal实例，并且使用的是ThreadLocal的弱引用 ，value是具体需要存储的Object。下面用一张图展示这些对象之间的引用关系，实心箭头表示强引用，空心箭头表示弱引用。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/java/threadlocal/20200329091959.png!www.zeze.info" alt="threadlocal"></p><blockquote><p>从上图可以看出，如果ThreadLocal没有外部强引用，当发生垃圾回收时，这个ThreadLocal一定会被回收(弱引用的特点是不管当前内存空间足够与否，GC时都会被回收)，这样就会导致ThreadLocalMap中出现key为null的Entry，外部将不能获取这些key为null的Entry的value，并且如果当前线程一直存活，那么就会存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value，导致value对应的Object一直无法被回收，产生内存泄露。查看源码会发现，ThreadLocal的get、set和remove方法都实现了对所有key为null的value的清除，但仍可能会发生内存泄露，因为可能使用了ThreadLocal的get或set方法后发生GC，此后不调用get、set或remove方法，为null的value就不会被清除。</p></blockquote><p>面试官：这个问题如何解决？</p><p><strong>小小白：</strong> 解决办法是每次使用完ThreadLocal都调用它的remove()方法清除数据，或者按照JDK建议将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉。</p><p><strong>面试官：</strong> 就你最开始写的代码，现在又有新需求，想在子线程中获取主线程threadLocal中set方法设置的值，如何实现？</p><p><strong>小小白：</strong> 使用InheritableThreadLocal，ThreadLocal threadLocal = new InheritableThreadLocal()，这样在子线程中就可以通过get方法获取到主线程set方法设置的值了。</p><p><strong>面试官：</strong> InheritableThreadLocal的实现原理是什么？</p><p><strong>小小白：</strong> InheritableThreadLocal继承了ThreadLocal，并且重写了childValue、getMap和createMap方法，当在主线程中创建InheritableThreadLocal实例对象后，通过new Thread()方式创建子线程时，进入如下代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,<span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">    init(g, target, name, stackSize, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,<span class="keyword">long</span> stackSize, AccessControlContext acc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name.toCharArray();</span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">        security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    g.addUnstarted();</span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">        <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">        acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        setPriority(priority);</span><br><span class="line">        <span class="comment">// 如果父线程的inheritableThreadLocals不为null</span></span><br><span class="line">    <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// 通过createInheritedMap方法将父线程中inheritableThreadLocals的值复制到子线程的inheritableThreadLocals中</span></span><br><span class="line">    <span class="keyword">this</span>.inheritableThreadLocals =ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line">    <span class="comment">/* Set thread ID */</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当使用InheritableThreadLocal创建实例对象时，当前线程Thread对象中维护了一个inheritableThreadLocals变量，它也是ThreadLocalMap类型，在创建子线程的过程中，将主线程维护的inheritableThreadLocals变量的值复制到子线程维护的inheritableThreadLocals变量中，这样子线程就可以获取到主线程设置的值了。</p></blockquote><p><strong><a href="http://www.zeze.info">博主主页</a></strong></p><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>24个ES6方法</title>
      <link href="/javaScript/work/js1/"/>
      <url>/javaScript/work/js1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="介绍25种很实用的ES6方法，来解决实际开发中的问题"><a href="#介绍25种很实用的ES6方法，来解决实际开发中的问题" class="headerlink" title="介绍25种很实用的ES6方法，来解决实际开发中的问题"></a>介绍25种很实用的ES6方法，来解决实际开发中的问题</h1><p>原创 @泽泽vlog 昨天</p><p>主要是介绍25种ES6方法，这些方法都挺实用的，用本本记好要考的，嘿嘿嘿。时不时翻出来看看</p><h1 id="1-如何隐藏所有指定的元素"><a href="#1-如何隐藏所有指定的元素" class="headerlink" title="1. 如何隐藏所有指定的元素"></a>1. 如何隐藏所有指定的元素</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hide = <span class="function">(<span class="params">el</span>)=&gt;</span></span><br><span class="line">  [...el].forEach(<span class="function"><span class="params">e</span>=&gt;</span>e.style.display = <span class="string">'none'</span>)</span><br><span class="line">hide(<span class="built_in">document</span>.querySelectorAll(<span class="string">'img'</span>))</span><br></pre></td></tr></table></figure><h1 id="2-如何检查元素是否具有指定的类"><a href="#2-如何检查元素是否具有指定的类" class="headerlink" title="2. 如何检查元素是否具有指定的类"></a>2. 如何检查元素是否具有指定的类</h1><p>在页面DOM里的每个节点上都有一个classList对象，程序员可以使用里面的方法新增、删除、修改节点上的CSS类。使用classList，程序员还可以用它来判断某个节点是否被赋予了某个CSS类</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hasClass = <span class="function">(<span class="params">el,className</span>)=&gt;</span>el.classList.contains(className)</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">hasClass(<span class="built_in">document</span>.querySelector(<span class="string">'div.s_form_wrapper '</span>),<span class="string">'soutu-env-nomac'</span>)</span><br></pre></td></tr></table></figure><h1 id="3-如何切换一个元素的类"><a href="#3-如何切换一个元素的类" class="headerlink" title="3. 如何切换一个元素的类"></a>3. 如何切换一个元素的类</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> toggleClass =<span class="function">(<span class="params">el,className</span>)=&gt;</span>el.classList.toggle(className)</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例 移除div具有`s_form_wrapper`的类</span></span><br><span class="line">toggleClass( <span class="built_in">document</span>.querySelector(<span class="string">'div.s_form_wrapper '</span>),<span class="string">'s_form_wrapper'</span>)</span><br></pre></td></tr></table></figure><h1 id="4-如何获取当前页面的滚动位置"><a href="#4-如何获取当前页面的滚动位置" class="headerlink" title="4. 如何获取当前页面的滚动位置"></a>4. 如何获取当前页面的滚动位置</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getScrollPosition =<span class="function">(<span class="params">el=<span class="built_in">window</span></span>)=&gt;</span>(&#123;</span><br><span class="line">    x:el.pageXOffset !==<span class="literal">undefined</span> ? el.pageXOffset:el.scrollLeft,</span><br><span class="line">    y:el.pageYOffset !==<span class="literal">undefined</span> ? el.pageYOffset:el.scrollTop</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">getScrollPosition() <span class="comment">//&#123;x: 0, y: 600&#125;</span></span><br></pre></td></tr></table></figure><h1 id="5-如何平滑滚动到页面顶部"><a href="#5-如何平滑滚动到页面顶部" class="headerlink" title="5. 如何平滑滚动到页面顶部"></a>5. 如何平滑滚动到页面顶部</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scrollToTop=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> c = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop</span><br><span class="line">    <span class="keyword">if</span>(c &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame(scrollToTop)</span><br><span class="line">        <span class="built_in">window</span>.scrollTo(<span class="number">0</span>,c-c/<span class="number">8</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">scrollToTop()</span><br></pre></td></tr></table></figure><p><code>requestAnimationFrame()</code>不需要设置时间间隔，是由系统的时间间隔定义的。大多数浏览器的刷新频率是60Hz(每秒钟反复绘制60次)，循环间隔是1000/60，约等于16.7ms。大多数浏览器会对反复挥着这个操作加以限制，不能超过60HZ，即使人为设置超过了该值，效果也不会改善。<code>requestAnimationFrame()</code>保证了最佳的绘制效率。<br>当页面被隐藏或者最小化时，<code>setInterval()</code>仍在后台继续执行，这种动画刷新是完全没有意义的，对cpu也是极大的浪费；<br>当页面被隐藏或者最小化时，<code>requestAnimationFramel()</code>中页面的渲染会被系统暂停，当页面再次激活后，继续从上次停止地方继续绘制；</p><h1 id="6-如何检查指定的元素在视口中是否可见"><a href="#6-如何检查指定的元素在视口中是否可见" class="headerlink" title="6. 如何检查指定的元素在视口中是否可见"></a>6. 如何检查指定的元素在视口中是否可见</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> elmentIsVisibleInViewport = <span class="function">(<span class="params">el,partiallyVisible=<span class="literal">false</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;top,left,bottom,right &#125; = el.getBoundingClientRect();</span><br><span class="line">    <span class="keyword">const</span> &#123; innerHeight ,innerWidth &#125; = <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">return</span> partiallyVisible</span><br><span class="line">    ?((top &gt; <span class="number">0</span> &amp;&amp; top &lt; innerHeight ) ||( bottom &gt; <span class="number">0</span> &amp;&amp; bottom &lt; innerHeight )) &amp;&amp;</span><br><span class="line">    ((left &gt; <span class="number">0</span> &amp;&amp; left &lt; innerWidth ) || (right &gt; <span class="number">0</span> &amp;&amp; right &lt; innerWidth ))</span><br><span class="line">    : top &gt;= <span class="number">0</span> &amp;&amp; left &gt;=<span class="number">0</span> &amp;&amp; bottom &lt;= innerHeight &amp;&amp; right &lt;= innerWidth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">elmentIsVisibleInViewport(el);<span class="comment">//需要左右可见</span></span><br><span class="line">elmentIsVisibleInViewport(el,<span class="literal">true</span>);<span class="comment">//需要全屏(上下左右)可见</span></span><br></pre></td></tr></table></figure><h1 id="7-如何检查父元素是否包含子元素"><a href="#7-如何检查父元素是否包含子元素" class="headerlink" title="7. 如何检查父元素是否包含子元素"></a>7. 如何检查父元素是否包含子元素</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> elementContains =<span class="function">(<span class="params">parent,child</span>)=&gt;</span>parent !== child &amp;&amp; parent.contains(child);</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">elementContains(<span class="built_in">document</span>.querySelector(<span class="string">'head'</span>),<span class="built_in">document</span>.querySelector(<span class="string">'title'</span>)</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">elementContains(<span class="built_in">document</span>.querySelector(<span class="string">'body'</span>),<span class="built_in">document</span>.querySelector(<span class="string">'body'</span>)</span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure><h1 id="8-如何获取元素中的所有图像？"><a href="#8-如何获取元素中的所有图像？" class="headerlink" title="8. 如何获取元素中的所有图像？"></a>8. 如何获取元素中的所有图像？</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getImages = <span class="function">(<span class="params">el,includeDuplicates = <span class="literal">false</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> images = [...el.getElementByTagName(<span class="string">'img'</span>)].map(<span class="function"><span class="params">img</span> =&gt;</span> img.getAttribute(<span class="string">'src'</span>));</span><br><span class="line">    <span class="keyword">return</span> includeDuplicates?images:[...new <span class="built_in">Set</span>(images)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例  includeDuplicates 为 true 表示需要重复元素</span></span><br><span class="line">getImages(<span class="built_in">document</span>,<span class="literal">true</span>)</span><br><span class="line">getImages(<span class="built_in">document</span>,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h1 id="9-如何确定设备是移动设备还是台式机-笔记本电脑"><a href="#9-如何确定设备是移动设备还是台式机-笔记本电脑" class="headerlink" title="9. 如何确定设备是移动设备还是台式机/笔记本电脑"></a>9. 如何确定设备是移动设备还是台式机/笔记本电脑</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> detectDeviceType = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/Android|webOS|iPhone|iPad|BlackBerry|IEMobile|Opera Mini/i</span></span><br><span class="line">    .test(navigator.userAgent)?<span class="string">'Mobile'</span>:<span class="string">'Desktop'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">detectDeviceType();</span><br></pre></td></tr></table></figure><h1 id="10-获取当前url"><a href="#10-获取当前url" class="headerlink" title="10. 获取当前url"></a>10. 获取当前url</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> currentURL =<span class="function"><span class="params">()</span> =&gt;</span>&#123;<span class="built_in">window</span>.location.href&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">currentURL();<span class="comment">//www.zeze.info</span></span><br></pre></td></tr></table></figure><h1 id="11-验证url的格式合法性"><a href="#11-验证url的格式合法性" class="headerlink" title="11. 验证url的格式合法性"></a>11. 验证url的格式合法性</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isURL=<span class="function">(<span class="params">str_url</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/(?:(https?|ftp|file):)?\/\/[-A-Za-z0-9+&amp;@#/%?=~_|!:,.;]+[-A-Za-z0-9+&amp;@#/%=~_|]/</span>;</span><br><span class="line">    <span class="keyword">let</span> re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(reg);</span><br><span class="line">    <span class="keyword">return</span> re.test(str_url);</span><br><span class="line">&#125;</span><br><span class="line">isURL(<span class="string">'http://www.zeze.info'</span>)</span><br></pre></td></tr></table></figure><h1 id="12-如何创建一个包含当前URL参数的对象"><a href="#12-如何创建一个包含当前URL参数的对象" class="headerlink" title="12. 如何创建一个包含当前URL参数的对象"></a>12. 如何创建一个包含当前URL参数的对象</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getURLParameters = <span class="function"><span class="params">url</span> =&gt;</span>(url.match(<span class="regexp">/([^?=&amp;]+)(=([^&amp;]*))/g</span>) || []).reduce(</span><br><span class="line">    (accumulator,currentValue) =&gt; ((accumulator[currentValue.slice(<span class="number">0</span>,v.indexOf(<span class="string">'='</span>))] = currentValue.slice(currentValue.indexOf(<span class="string">'='</span>)+<span class="number">1</span>)),accumulator)</span><br><span class="line">    ,&#123;&#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">getURLParameters(<span class="string">'http://www.zeze.info/index?a=1&amp;b=2'</span>) <span class="comment">//&#123;a:1,b:2&#125;</span></span><br><span class="line">getURLParameters(<span class="string">'http://www.zeze.info'</span>) <span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure><h1 id="13-如何将一组表单元素转化为对象"><a href="#13-如何将一组表单元素转化为对象" class="headerlink" title="13. 如何将一组表单元素转化为对象"></a>13. 如何将一组表单元素转化为对象</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> formToObject = <span class="function"><span class="params">form</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.from(<span class="keyword">new</span> FormData(form)).reduce(</span><br><span class="line">        (acc,[key,value])=&gt;(&#123;</span><br><span class="line">            ...acc,</span><br><span class="line">            [key]:value</span><br><span class="line">        &#125;),</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">formToObject(<span class="built_in">document</span>.querySelector(<span class="string">'#from'</span>))</span><br><span class="line"><span class="comment">//&#123;email:'test@email.com',name:'www.zeze.info'&#125;</span></span><br></pre></td></tr></table></figure><h1 id="14-如何从对象检索给定选择器指示的一组属性"><a href="#14-如何从对象检索给定选择器指示的一组属性" class="headerlink" title="14. 如何从对象检索给定选择器指示的一组属性"></a>14. 如何从对象检索给定选择器指示的一组属性</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">get</span> =(from,...selectos)=&gt;</span><br><span class="line">    [...selectos].map(s=&gt;</span><br><span class="line">        s</span><br><span class="line">        .replace(/\[([^\[\]]*)\]/g,'.$1.')</span><br><span class="line">        .split('.')</span><br><span class="line">        .filter(t=&gt; t !=='')</span><br><span class="line">        .reduce((prev,cur)=&gt;prev &amp;&amp; prev[cur],from)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">const obj = &#123; selector:&#123;<span class="attr">to</span>:&#123;<span class="attr">val</span>:<span class="string">'val to select'</span> &#125; &#125;, <span class="attr">target</span>:[<span class="number">1</span>,<span class="number">2</span>,&#123;<span class="attr">a</span>:<span class="string">'test'</span>&#125;] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">get</span>(obj,'selector.to.val','target[0]','target[2].a')</span><br><span class="line">// ["val to select", 1, "test"]</span><br></pre></td></tr></table></figure><h1 id="15-如何在等待指定时间后调用提供的函数"><a href="#15-如何在等待指定时间后调用提供的函数" class="headerlink" title="15. 如何在等待指定时间后调用提供的函数"></a>15. 如何在等待指定时间后调用提供的函数</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> delay =<span class="function">(<span class="params">fn,wait,...args</span>)=&gt;</span>setTimeout(fn,wait,...args)</span><br><span class="line"></span><br><span class="line">delay(</span><br><span class="line">    (test)=&gt;<span class="built_in">console</span>.info(test),</span><br><span class="line">    <span class="number">1000</span>,</span><br><span class="line">    <span class="string">'later'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="16-如何在给定元素上触发特定事件且能选择地传递自定义数据"><a href="#16-如何在给定元素上触发特定事件且能选择地传递自定义数据" class="headerlink" title="16. 如何在给定元素上触发特定事件且能选择地传递自定义数据"></a>16. 如何在给定元素上触发特定事件且能选择地传递自定义数据</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建一个事件对象，名字为newEvent，类型为build */</span></span><br><span class="line"><span class="keyword">var</span> newEvent = <span class="keyword">new</span> Event(<span class="string">'build'</span>, &#123; <span class="attr">bubbles</span>:<span class="literal">true</span>,<span class="attr">cancelable</span>:<span class="literal">true</span>,<span class="attr">composed</span>:<span class="literal">true</span> &#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 给这个事件对象创建一个属性并赋值 */</span></span><br><span class="line">newEvent.name = <span class="string">"新的事件！"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将自定义事件绑定在document对象上，这里绑定的事件要和我们创建的事件类型相同，不然无法触发 */</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"build"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"你触发了自定义事件！"</span> + newEvent.name);</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 触发自定义事件 */</span></span><br><span class="line"><span class="built_in">document</span>.dispatchEvent(newEvent);</span><br></pre></td></tr></table></figure><p>启动文档的时候因为”document.dispatchEvent(newEvent)”的关系，会先触发一次事件：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/js/25ES6/1.png!www.zeze.info" alt="事件对象"></p><p>之后你每执行一次”document.dispatchEvent(newEvent)”都会触发这个事件：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/js/25ES6/1.gif!www.zeze.info" alt="事件对象"></p><p>接下来我们看看Event()这个方法的语法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">event = <span class="keyword">new</span> Event(typeArg, eventInit);</span><br></pre></td></tr></table></figure><p>typeArg：指定事件类型，传递一个字符串。这里的事件类型指的是像点击事件（click）、提交事件（submit）、加载事件（load）等等。<br>eventInit：可选，传递EventInit类型的字典。实际上这个EventInit类型的字典也就是我们使用InitEvent()时需要传递的参数，以键值对的形式传递，不过它可以多选一个参数：<br>bubbles：事件是否支持冒泡，传递一个boolean类型的参数，默认值为false。<br>cancelable：是否可取消事件的默认行为，传递一个boolean类型的参数，默认值为false。<br>composed：事件是否会触发shadow DOM（阴影DOM）根节点之外的事件监听器，传递一个boolean类型的参数，默认值为false。（关于shadow DOM可以去看<a href="https://www.cnblogs.com/coco1s/p/5711795.html" target="_blank" rel="external nofollow noopener noreferrer">ChokCoco前辈的这篇文章</a>，这里就不详说了，可能我会根据自己的理解也写一个关于shadow DOM的笔记）这个参数是InitEvent()中没有的新参数。</p><p>我们先通过下面的例子了解一下如何使用CustomEvent()去创建一个事件对象（这里先不使用事件相关值detail）;</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/* 创建一个事件对象，名字为newEvent，类型为build */</span></span><br><span class="line"><span class="keyword">var</span> newEvent = <span class="keyword">new</span> CustomEvent(<span class="string">'build'</span>, &#123; <span class="attr">bubbles</span>:<span class="literal">true</span>,<span class="attr">cancelable</span>:<span class="literal">true</span>,<span class="attr">composed</span>:<span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给这个事件对象创建一个属性并赋值，这里绑定的事件要和我们创建的事件类型相同，不然无法触发 */</span></span><br><span class="line">newEvent.name = <span class="string">"新的事件！"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将自定义事件绑定在document对象上 */</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"build"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"你触发了使用CustomEvent创建的自定义事件！"</span> + newEvent.name);</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 触发自定义事件 */</span></span><br><span class="line"><span class="built_in">document</span>.dispatchEvent(newEvent);</span><br></pre></td></tr></table></figure><div class="note default"> 然后我们来看CustomEvent()的语法：</div><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">event = <span class="keyword">new</span> CustomEvent(typeArg, customEventInit);</span><br></pre></td></tr></table></figure>typeArg：指定事件类型，传递一个字符串。这里的事件类型指的是像点击事件（click）、提交事件（submit）、加载事件（load）等等。customEventInit：可选。传递一个CustomEventInit字典。实际上这个字典就是我们使用initCustomEvent()时需要的参数，这个参数就是事件相关值（detail）：detail：可选，默认值为null，类型为any（也就是说可以传递任意类型的参数）。这个值就是和事件相关联的值。在展示使用detail作为第二个参数的例子前，要先注意一件事：CustomEventInit字典也可以接受EventInit字典的参数，就像一开始的例子一样，我传递了EventInit字典的bubbles、cancelable、composed。<div class="note default"> 下面将展示使用detail参数的例子，使用到detail的部分我会加粗处理（为了看着方便，这回就不传递EventInit字典中的参数了）：</div><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/* 创建一个事件对象，名字为newEvent，类型为build */</span></span><br><span class="line"><span class="keyword">var</span> newEvent = <span class="keyword">new</span> CustomEvent(<span class="string">'build'</span>,&#123; </span><br><span class="line">    detail: &#123;</span><br><span class="line">        dog:<span class="string">"wo"</span>,<span class="attr">cat</span>:<span class="string">"mio"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将自定义事件绑定在document对象上 */</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"build"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">" event.detail.dog:"</span> + event.detail.dog</span><br><span class="line">        + <span class="string">"\n event.detail.cat:"</span> + event.detail.cat );</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 触发自定义事件 */</span></span><br><span class="line"><span class="built_in">document</span>.dispatchEvent(newEvent);</span><br></pre></td></tr></table></figure><h1 id="17-如何从元素中移除事件监听器"><a href="#17-如何从元素中移除事件监听器" class="headerlink" title="17. 如何从元素中移除事件监听器"></a>17. 如何从元素中移除事件监听器</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>  off =</span><br><span class="line">    (el,evt,fn,opts=<span class="literal">false</span>) =&gt; el.removeEventListener(evt,fn,opts);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn =<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'!'</span>)</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>,fn)</span><br><span class="line">off(<span class="built_in">document</span>.body,<span class="string">'click'</span>,fn)</span><br></pre></td></tr></table></figure><h1 id="18-如何获得给定毫秒数的可读格式"><a href="#18-如何获得给定毫秒数的可读格式" class="headerlink" title="18. 如何获得给定毫秒数的可读格式"></a>18. 如何获得给定毫秒数的可读格式</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>  formatDuration = <span class="function"><span class="params">ms</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ms&lt;<span class="number">0</span>) ms = -ms;</span><br><span class="line">    <span class="keyword">const</span> time =&#123;</span><br><span class="line">        day: <span class="built_in">Math</span>.floor(ms/<span class="number">86400000</span>),</span><br><span class="line">        hour:<span class="built_in">Math</span>.floor(ms/<span class="number">3600000</span>) % <span class="number">24</span>,</span><br><span class="line">        minute: <span class="built_in">Math</span>.floor(ms/<span class="number">60000</span>) % <span class="number">60</span>,</span><br><span class="line">        second: <span class="built_in">Math</span>.floor(ms/<span class="number">1000</span>) % <span class="number">60</span>,</span><br><span class="line">        millisecond: <span class="built_in">Math</span>.floor(ms) % <span class="number">1000</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.entries(time)</span><br><span class="line">    .filter(<span class="function"><span class="params">val</span> =&gt;</span> val[<span class="number">1</span>] !== <span class="number">0</span>)</span><br><span class="line">    .map(<span class="function">(<span class="params">[key,val]</span>)=&gt;</span><span class="string">`<span class="subst">$&#123;val&#125;</span> <span class="subst">$&#123;key&#125;</span><span class="subst">$&#123;val !== <span class="number">1</span> ? <span class="string">'s'</span>:<span class="string">''</span>&#125;</span>`</span>)</span><br><span class="line">    .join(<span class="string">','</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">formatDuration(<span class="number">1001</span>);</span><br><span class="line"><span class="comment">//"1 second,1 millisecond"</span></span><br><span class="line">formatDuration(<span class="number">3432505574</span>);</span><br><span class="line"><span class="comment">//"39 days,17 hours,28 minutes,25 seconds,574 milliseconds"</span></span><br></pre></td></tr></table></figure><h1 id="19-如何获得两个日期之间的差异（以天为单位）"><a href="#19-如何获得两个日期之间的差异（以天为单位）" class="headerlink" title="19. 如何获得两个日期之间的差异（以天为单位）"></a>19. 如何获得两个日期之间的差异（以天为单位）</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getDaysDiffBetweenDates = <span class="function">(<span class="params">dateInitial,dateFinal</span>)=&gt;</span></span><br><span class="line">    (dateFinal - dateInitial) / (<span class="number">1000</span> * <span class="number">3600</span> *<span class="number">24</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">getDaysDiffBetweenDates(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2020-03-01'</span>),<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2020-03-03'</span>))</span><br></pre></td></tr></table></figure><h1 id="20-如何向传递的URL发出GET请求"><a href="#20-如何向传递的URL发出GET请求" class="headerlink" title="20. 如何向传递的URL发出GET请求"></a>20. 如何向传递的URL发出GET请求</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> httpGet = <span class="function">(<span class="params">url,callback,err = <span class="built_in">console</span>.error</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">'GET'</span>,url,<span class="literal">true</span>);</span><br><span class="line">    request.onload = <span class="function"><span class="params">()</span> =&gt;</span>callback(request.responseText);</span><br><span class="line">    request.onerror = <span class="function"><span class="params">()</span> =&gt;</span> err(request);</span><br><span class="line">    request.send();</span><br><span class="line">&#125;</span><br><span class="line">httpGet(</span><br><span class="line">    <span class="string">'https://jsonplaceholder.typicode.com/posts/1'</span>,</span><br><span class="line">    <span class="built_in">console</span>.log</span><br><span class="line">)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  "userId": 1,</span></span><br><span class="line"><span class="comment">  "id": 1,</span></span><br><span class="line"><span class="comment">  "title": "sunt aut facere repellat provident occaecati excepturi optio reprehenderit",</span></span><br><span class="line"><span class="comment">  "body": "quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto"</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="21-如何对传递的URL发出POST请求"><a href="#21-如何对传递的URL发出POST请求" class="headerlink" title="21. 如何对传递的URL发出POST请求"></a>21. 如何对传递的URL发出POST请求</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> httpPost = <span class="function">(<span class="params">url,data,callback,err = <span class="built_in">console</span>.error</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.open(<span class="string">'POST'</span>,url,<span class="literal">true</span>);</span><br><span class="line">    request.setRequestHeader(<span class="string">'Content-type'</span>,<span class="string">'application/json; charset=utf-8'</span>);</span><br><span class="line">    request.onload = <span class="function"><span class="params">()</span> =&gt;</span>callback(request.responseText);</span><br><span class="line">    request.onerror = <span class="function"><span class="params">()</span> =&gt;</span> err(request);</span><br><span class="line">    request.send(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> postData=&#123;</span><br><span class="line">    userId:<span class="number">1</span>,</span><br><span class="line">    title:<span class="string">'Foo'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> data =<span class="built_in">JSON</span>.stringify(postData)</span><br><span class="line">httpPost(</span><br><span class="line">    <span class="string">'https://jsonplaceholder.typicode.com/posts'</span>,</span><br><span class="line">    data,</span><br><span class="line">    <span class="built_in">console</span>.log</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="22-如何为指定选择器创建具有指定范围，步长和持续时间的计数器"><a href="#22-如何为指定选择器创建具有指定范围，步长和持续时间的计数器" class="headerlink" title="22. 如何为指定选择器创建具有指定范围，步长和持续时间的计数器"></a>22. 如何为指定选择器创建具有指定范围，步长和持续时间的计数器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> counter = <span class="function">(<span class="params">selector,start,end,step=<span class="number">1</span>,duration</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = start;</span><br><span class="line">    _step = (end-start) * step &lt; <span class="number">0</span>?-step : step</span><br><span class="line">    timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        current += _step;</span><br><span class="line">        <span class="built_in">document</span>.querySelector(selector).innerHTML = current;</span><br><span class="line">        <span class="keyword">if</span> (current &gt;= end) &#123;</span><br><span class="line">            <span class="built_in">document</span>.querySelector(selector).innerHTML = end ;</span><br><span class="line">            clearInterval(timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="built_in">Math</span>.abs(<span class="built_in">Math</span>.floor(duration/(end-start))));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">counter(<span class="string">'#myId'</span>,<span class="number">1</span>,<span class="number">1000</span>,<span class="number">5</span>,<span class="number">20000</span>);</span><br></pre></td></tr></table></figure><h1 id="23-如何将字符串复制到剪贴板"><a href="#23-如何将字符串复制到剪贴板" class="headerlink" title="23. 如何将字符串复制到剪贴板"></a>23. 如何将字符串复制到剪贴板</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> copyToClipboard = <span class="function"><span class="params">str</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(<span class="string">'textarea'</span>);</span><br><span class="line">    el.value = str;</span><br><span class="line">    el.setAttribute(<span class="string">'readonly'</span>,<span class="string">''</span>);</span><br><span class="line">    el.style.position=<span class="string">'absolute'</span>;</span><br><span class="line">    el.style.left = <span class="string">'-9999px'</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(el);</span><br><span class="line">    <span class="keyword">const</span> selected =<span class="built_in">document</span>.getSelection().rangeCount &gt;<span class="number">0</span>?<span class="built_in">document</span>.getSelection().getRangeAt(<span class="number">0</span>):<span class="literal">false</span>;</span><br><span class="line">    el.select();</span><br><span class="line">    <span class="built_in">document</span>.execCommand(<span class="string">'copy'</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(el)</span><br><span class="line">    <span class="keyword">if</span>(selected)&#123;</span><br><span class="line">        <span class="built_in">document</span>.getSelection().removeAllRanges();</span><br><span class="line">        <span class="built_in">document</span>.getSelection().addRange(selected);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">copyToClipboard(<span class="string">'www.zeze.info'</span>)</span><br></pre></td></tr></table></figure><h1 id="24-如何确定页面的浏览器选项卡是否聚焦"><a href="#24-如何确定页面的浏览器选项卡是否聚焦" class="headerlink" title="24. 如何确定页面的浏览器选项卡是否聚焦"></a>24. 如何确定页面的浏览器选项卡是否聚焦</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isBrowserTabFocused= <span class="function"><span class="params">()</span>=&gt;</span> !<span class="built_in">document</span>.hidden; </span><br><span class="line">isBrowserTabFocused();</span><br></pre></td></tr></table></figure><h1 id="25-如何创建目录（如果不存在）"><a href="#25-如何创建目录（如果不存在）" class="headerlink" title="25. 如何创建目录（如果不存在）"></a>25. 如何创建目录（如果不存在）</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs =<span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> createDirIfNotExists = <span class="function"><span class="params">dir</span> =&gt;</span>(!fs.existsSync(dir)?fs.mkdirSync(dir):<span class="literal">undefined</span>);</span><br><span class="line">createDirIfNotExists(<span class="string">'test'</span>);</span><br></pre></td></tr></table></figure><p>这里面的方法大都挺实用，可以解决很多开发过程问题，大家就好好利用起来吧。</p><p><strong><a href="http://www.zeze.info">博主主页</a></strong></p><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> javaScript </category>
          
          <category> es6 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>你本可以少写些 If-Else</title>
      <link href="/javaScript/oop/if-else/"/>
      <url>/javaScript/oop/if-else/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>在JavaScript开发中，条件判断语句的使用频率是极高的，而对于条件判断简单易读的if else应该都是大家的首选。可是代码写的久了，我们总是希望自己的代码看着能更为简洁规范（逼格更高），那么今天我们就由浅到深介绍几种实用小技巧，帮大家减少代码中的if else。说在开头，本文并未有消灭或歧视 if else的意思，if else的好用都知道，这里只是在某些特定场景为大家额外提供一种思路罢了，如何使用还请自行抉择，那么本文开始。</p></blockquote><h1 id="短路求值"><a href="#短路求值" class="headerlink" title="短路求值"></a>短路求值</h1><blockquote><p>在函数定义时，常有若函数调用未提供参数则使用默认值的情景，当然我们可以使用if else来解决这个问题：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!name)&#123;</span><br><span class="line">        name = <span class="string">'听风是风'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;;</span><br><span class="line">fn();<span class="comment">//听风是风</span></span><br><span class="line">fn(<span class="string">'行星飞行'</span>);<span class="comment">//行星飞行</span></span><br></pre></td></tr></table></figure><blockquote><p>有没有更优雅的做法呢？当然，我们可以使用短路求值，像这样：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">fn</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    name = name || <span class="string">'听风是风'</span>;</span><br><span class="line">    console.log(name);</span><br><span class="line">&#125;;</span><br><span class="line">fn();<span class="comment">//听风是风</span></span><br><span class="line">fn(<span class="string">'行星飞行'</span>);<span class="comment">//行星飞行</span></span><br></pre></td></tr></table></figure><blockquote><p>我们简单复习下 ||或 和 &amp;&amp;与 的概念，||表示两者任意一个为真便为真，&amp;&amp;表示两者都为真才是真，任意一个为假就是假。</p></blockquote><blockquote><p>为什么这个特定能用在变量赋值呢？其实这是利用了 || 前者为真后者不判断，&amp;&amp;前者为假后者不判断的特点，来看个例子(<a href="../cacl/cacl1">查看详情</a>)：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">fn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.log(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">true</span> || fn(); <span class="comment">//不执行</span></span><br><span class="line"><span class="keyword">false</span> &amp;&amp; fn(); <span class="comment">//不执行</span></span><br><span class="line"><span class="keyword">false</span> || fn(); <span class="comment">//1</span></span><br><span class="line"><span class="keyword">true</span> &amp;&amp; fn() <span class="comment">//1</span></span><br></pre></td></tr></table></figure><blockquote><p>所以上面的短路求值中，当name有值时后面的默认值就被忽略了不判断，而name无值时便会判断后者取到默认值。</p></blockquote><blockquote><p>短路求值除了用在变量赋值外，还能用于函数调用，比如在下方例子为假时才调用某个方法：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">let name = <span class="keyword">false</span>;</span><br><span class="line"><span class="function">function <span class="title">fn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.log(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//if</span></span><br><span class="line"><span class="keyword">if</span> (!name) &#123;</span><br><span class="line">    fn();<span class="comment">//1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//短路</span></span><br><span class="line">!name &amp;&amp; fn();<span class="comment">//1</span></span><br></pre></td></tr></table></figure><blockquote><p>对于函数形参短路赋值其实有个缺点，假设我的参数就是0，false或者null，因为短路的特性会被认为假，这样我们无法拿到想要的值，更佳的做法是使用ES6的形参默认值，像这样：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    param = param || <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(param);</span><br><span class="line">&#125;;</span><br><span class="line">fn(<span class="number">0</span>); <span class="comment">//1</span></span><br><span class="line">fn(<span class="literal">null</span>); <span class="comment">//1</span></span><br><span class="line">fn(<span class="literal">false</span>); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用形参默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">param = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(param);</span><br><span class="line">&#125;;</span><br><span class="line">fn1(); <span class="comment">//1</span></span><br><span class="line">fn1(<span class="number">0</span>); <span class="comment">//0</span></span><br><span class="line">fn1(<span class="literal">null</span>); <span class="comment">//null</span></span><br><span class="line">fn1(<span class="literal">false</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h1 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h1><blockquote><p>三元运算符我想大家都不会陌生，在开发中三元运算的使用场景其实非常多，比如我希望为条件为 true时变量为1，反之为0，通过三元运算符我们可以这样做：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> blo = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> num;</span><br><span class="line"><span class="keyword">if</span> (blo) &#123;</span><br><span class="line">    num = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(num);<span class="comment">//1</span></span><br><span class="line"><span class="comment">//三元运算符</span></span><br><span class="line">blo =<span class="literal">false</span>;</span><br><span class="line">blo ? num = <span class="number">1</span> : num = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num);<span class="comment">//0</span></span><br></pre></td></tr></table></figure><blockquote><p>比如我们希望条件为true时调用函数fn，为false时什么也不做，使用三元看起来也会更加舒服：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> blo = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//if</span></span><br><span class="line"><span class="keyword">if</span> (blo) &#123;</span><br><span class="line">    fn(); <span class="comment">//1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//三元</span></span><br><span class="line">blo ? fn() : <span class="literal">null</span>;<span class="comment">//1</span></span><br></pre></td></tr></table></figure><blockquote><p>在开发中函数常常需要 return 一份数据回去，有时候根据条件不同我们可能要分别对应返回不同的数据，三元也能解决这个问题：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flo = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (flo) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> f = fn(); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flo = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//三元</span></span><br><span class="line">    <span class="keyword">return</span> flo ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> f1 = fn1();<span class="comment">//1</span></span><br></pre></td></tr></table></figure><blockquote><p>三元结合return的操作非常适合我们递归处理时做收尾工作，如果满足条件继续递归，不满足跳出递归，比如我们要求正整数N到0之间所有整数之和，可以这么写：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    result += n</span><br><span class="line">    <span class="keyword">return</span> n&gt;=<span class="number">2</span> ? add(n<span class="number">-1</span>) : result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> num = add(<span class="number">10</span>);<span class="comment">//55</span></span><br></pre></td></tr></table></figure><blockquote><p>怎么样？看着是不是特别简洁舒服。需要注意的是，三元运算符的表达式只能是单语句，否则无法使用，比如下方例子中由于执行语句超过了2句，这就无法使用三元运算符改写了：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">let i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//执行语句超过2句</span></span><br><span class="line">    console.log(<span class="number">1</span>);</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h1><blockquote><p>短路求值与三元运算符固然好用，但其实有一个遗憾，它们都只能解决非A即B的条件判断，凡是条件判断超过两种就显得十分无力了。那难道我们只能使用 else if 吗，其实可以使用switch case。</p></blockquote><blockquote><p>例如A情况我们希望A情况输出a，B情况输出b，C情况输出c，其它情况输出d，用 else if 与switch case分别是这样：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'B'</span>;</span><br><span class="line"><span class="comment">//if else if</span></span><br><span class="line"><span class="keyword">if</span> (name === <span class="string">'A'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (name === <span class="string">'B'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (name === <span class="string">'C'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'c'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'d'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//switch case</span></span><br><span class="line"><span class="keyword">switch</span> (name) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'B'</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'c'</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'d'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>那么我们希望A或B情况输出1，C情况输出2，其它情况输出3呢，switch case其实也能做到：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'B'</span>;</span><br><span class="line"><span class="comment">//if else if</span></span><br><span class="line"><span class="keyword">if</span> (name === <span class="string">'A'</span> || name === <span class="string">'B'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (name === <span class="string">'C'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//switch case</span></span><br><span class="line"><span class="keyword">switch</span> (name) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'B'</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>当然我想大多数人还是会觉得switch case写起来贼麻烦，尽管它的可读性确实比 else if 更高，没关系，就算作为了解也没有坏处。</p></blockquote><h1 id="对象配置-配置数据与业务逻辑分离"><a href="#对象配置-配置数据与业务逻辑分离" class="headerlink" title="对象配置(配置数据与业务逻辑分离)"></a>对象配置(配置数据与业务逻辑分离)</h1><blockquote><p>条件超过三种，else if 写起来不太优雅，switch case又觉得麻烦，有没有更棒的做法呢？我在实际开发遇到过这样一个情景，我需要根据用户不同的操作类型对同一份数据进行不同加工，比如新增，修改，删除等。那么我用else if是这么做的：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">del</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//删除操作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//新增</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//更新</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">operateType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (operateType === <span class="string">'del'</span>) &#123;</span><br><span class="line">        del()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operateType === <span class="string">'add'</span>) &#123;</span><br><span class="line">        add()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operateType === <span class="string">'update'</span>) &#123;</span><br><span class="line">        update()</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">process(<span class="string">'del'</span>);<span class="comment">//删除</span></span><br></pre></td></tr></table></figure><blockquote><p>一种很棒的做法就是通过对象配置，将你的操作类型作为key，具体操作的函数作为value，像这样：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">del</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//删除操作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//新增</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//更新</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> typeFn = &#123;</span><br><span class="line">    <span class="string">'del'</span>: del,</span><br><span class="line">    <span class="string">'add'</span>: add,</span><br><span class="line">    <span class="string">'update'</span>: update</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">operateType</span>) </span>&#123;</span><br><span class="line">    typeFn[operateType]();</span><br><span class="line">&#125;;</span><br><span class="line">process(<span class="string">'del'</span>); <span class="comment">//删除</span></span><br></pre></td></tr></table></figure><blockquote><p>怎么样，有没有眼前一亮呢？我们将需求升级，现在除了判断操作type类型外，还得额外附加一个状态类型，else if是这样，这里简单描述下：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">operateType, status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (operateType === <span class="string">'del'</span> &amp;&amp; status === <span class="number">1</span>) &#123;</span><br><span class="line">        del()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operateType === <span class="string">'add'</span>&amp;&amp; status === <span class="number">2</span>) &#123;</span><br><span class="line">        add()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operateType === <span class="string">'update'</span>&amp;&amp; status === <span class="number">3</span>) &#123;</span><br><span class="line">        update()</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>不太优雅，通过对象配置做法，我们其实只用将参数简单配置就OK了，像这样是不是更清爽呢：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> typeFn = &#123;</span><br><span class="line">    <span class="string">'del_1'</span>: del,</span><br><span class="line">    <span class="string">'add_2'</span>: add,</span><br><span class="line">    <span class="string">'update_3'</span>: update</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">operateType,status</span>) </span>&#123;</span><br><span class="line">    typeFn[<span class="string">`<span class="subst">$&#123;operateType&#125;</span>_<span class="subst">$&#123;status&#125;</span>`</span>]();</span><br><span class="line">&#125;;</span><br><span class="line">process(<span class="string">'del'</span>,<span class="number">1</span>); <span class="comment">//删除</span></span><br></pre></td></tr></table></figure><blockquote><p>什么，对象配置的调用方式语义化不太明显？那各位可曾对ES6的map数据结构有了解呢，如果你觉得这样的调用不太实在，我们再改改，将调用条件与函数配置成map数据，像这样：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> typeFn = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">'del_1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*do something*/</span> &#125;],</span><br><span class="line">    [<span class="string">'add_2'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*do something*/</span> &#125;],</span><br><span class="line">    [<span class="string">'update_3'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*do something*/</span> &#125;],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">operateType, status</span>) </span>&#123;</span><br><span class="line">    typeFn.get(<span class="string">`<span class="subst">$&#123;operateType&#125;</span>_<span class="subst">$&#123;status&#125;</span>`</span>)();</span><br><span class="line">&#125;;</span><br><span class="line">process(<span class="string">'del'</span>, <span class="number">1</span>); <span class="comment">//删除</span></span><br></pre></td></tr></table></figure><blockquote><p>我们通过map数据的get方法去数据中找到方法执行，这下可读性总强一点了吧，诸君可否满意呢？</p></blockquote><h1 id="数组配置-配置数据与业务逻辑分离"><a href="#数组配置-配置数据与业务逻辑分离" class="headerlink" title="数组配置(配置数据与业务逻辑分离)"></a>数组配置(配置数据与业务逻辑分离)</h1><blockquote><p>在处理条件判断时，我们常会遇到条件与对应结果全部已知的情况，比如我们要根据用户的经验设置等级头衔，[0,100)–萌新，[100,200)–骑士，[200,300)–英雄，[300-无限大]–传说，那么用else if怎么写已经没有悬念了：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">youAreMyHero</span>(<span class="params">experience</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (experience &lt; <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'萌新'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (experience &lt; <span class="number">200</span> &amp;&amp; experience &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'骑士'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (experience &lt; <span class="number">300</span> &amp;&amp; experience &gt;= <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'英雄'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (experience &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'传说'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> level = youAreMyHero(<span class="number">351</span>); <span class="comment">//传说</span></span><br></pre></td></tr></table></figure><blockquote><p>对于这种条件与结果已知的情况，我们其实可以通过数组配置的形式将条件结果抽离出来，像这样：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">youAreMyHero</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> experience = [<span class="number">300</span>, <span class="number">200</span>, <span class="number">100</span>];</span><br><span class="line">    <span class="keyword">let</span> level = [<span class="string">'传说'</span>, <span class="string">'英雄'</span>, <span class="string">'骑士'</span>, <span class="string">'萌新'</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; experience.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (param &gt;= experience[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> level[i];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> level[level.length - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> level = youAreMyHero(<span class="number">250</span>); <span class="comment">//英雄</span></span><br></pre></td></tr></table></figure><blockquote><p>这么做的好处就是便于管理条件与执行结果，如果后面新增了等级判断，我们不用去修改业务逻辑中的 else if 语句长度，只用单纯维护我们抽离的数据即可。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那么到这里，我们大致介绍了五种可取代if else的方式，我们知道短路运算符除了短路求值，还能用于函数调用；三元运算符也不仅仅是处理变量赋值，在return场景结合三元用起来居然如此舒适。<br>在文章后半段，我们还了解了对象配置，利用map数据结构，以及数据实行来解决特殊场景。我并不推荐为了追求高逼格而牺牲代码可读性，但我更希望在你以后的代码中不仅仅只有if else，那么到这里本文结束。<br><strong><a href="http://www.zeze.info">博主主页</a></strong></p><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六大设计原则</title>
      <link href="/java/design6/"/>
      <url>/java/design6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 原则，故名思议则是本质的意思。所谓擒贼先擒王，研究设计模式自然要先了解设计原则，所有的模式都是在这些原则的基础之上发展起来的，有的是侧重一个，有的是多个都有所涉及。看完设计模式之后，我感觉到每个模式都有这些原则的影子，还渗透着面向对象的三大属性，也觉得这些原则也都有相通之处，，正是有了他们才使我们由代码工人转为艺术家。下面我来点评一下六大原则，望各位拍砖：</p><h1 id="单一职责原则（Single-Responsibility-Principle，简称SRP）"><a href="#单一职责原则（Single-Responsibility-Principle，简称SRP）" class="headerlink" title="单一职责原则（Single Responsibility Principle，简称SRP）"></a>单一职责原则（Single Responsibility Principle，简称SRP）</h1><blockquote><p>单一职责原则，就一个类而言，应该仅有一个引起它变化的原因。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会消弱或者一直这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。而软件设计真正要做的许多内容，就是发现职责，并把这些职责相互分离。</p></blockquote><p>一句话点评：高内聚低耦合的绝佳体现，不要乱拉关系，独善其身挺好。</p><h1 id="开放–封闭原则（The-Open-Closed-Principle简称OCP）"><a href="#开放–封闭原则（The-Open-Closed-Principle简称OCP）" class="headerlink" title="开放–封闭原则（The Open-Closed Principle简称OCP）"></a>开放–封闭原则（The Open-Closed Principle简称OCP）</h1><blockquote><p>开放–封闭原则，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可以修改。即对于扩展是开放的，对于更改是封闭的。 我们不可能做到未卜先知，在设计的时候尽可能让一个类足够好，设计好了就不要去修改了；不能完全封闭的情况下，当发生变化时，我们就创建抽象来隔离以后发生的同类变化。</p></blockquote><p>一句话点评：开放扩展，封闭更改，开合有度是一门艺术。</p><h1 id="依赖倒转原则（Dependence-Inversion-Principle-）"><a href="#依赖倒转原则（Dependence-Inversion-Principle-）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle ）"></a>依赖倒转原则（Dependence Inversion Principle ）</h1><blockquote><p>依赖倒转原则，指高层模块不应该依赖低层模块，两个都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。说白了就是要针对接口编程，不要对实现编程。举个例子：计算机硬件中，如果内存坏了，那么只需要换一个内存条就可以了，而不需要去换一个主板，在这里内存是一个接口类，只要符合他的规格要求就行，无论是那一根。</p></blockquote><p>一句话点评：搞建筑时要做设计师，而不是砖瓦工，抽象的蓝图要靠具体的材料一点点实现。</p><h1 id="里氏代换原则（Liskov-Substitution-Principle，简称LSP）"><a href="#里氏代换原则（Liskov-Substitution-Principle，简称LSP）" class="headerlink" title="里氏代换原则（Liskov Substitution Principle，简称LSP）"></a>里氏代换原则（Liskov Substitution Principle，简称LSP）</h1><blockquote><p>里氏代换原则，子类型必须能够替换掉他们的父类型。在软件里面，把父类都替换成其子类，程序的行为不会发生变化。正是由于子类型的可替换性才使得使用父类型的模块在无需修改的情况下就可以扩展。</p></blockquote><p>一句话点评：长辈给了你继承的权利就一定要做赡养的义务，把长辈的职责都要承担起来。</p><h1 id="迪米特法则（Law-of-Demeter）"><a href="#迪米特法则（Law-of-Demeter）" class="headerlink" title="迪米特法则（Law of Demeter）"></a>迪米特法则（Law of Demeter）</h1><blockquote><p>迪米特法则，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法时，可以通过第三者转发这个调用。类之间的耦合越弱，就越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。 主要是强调了类之间的松耦合。</p></blockquote><p>一句话点评：不要和陌生人说话，若两国交战要尽量避免正面冲突，多派使者协商调度</p><h1 id="合成-聚合复用原则（Composition-Aggregation-Principle-，简称CARP）"><a href="#合成-聚合复用原则（Composition-Aggregation-Principle-，简称CARP）" class="headerlink" title="合成/聚合复用原则（Composition/Aggregation Principle]，简称CARP）"></a>合成/聚合复用原则（Composition/Aggregation Principle]，简称CARP）</h1><blockquote><p>合成聚合复用原则，尽量使用合成/聚合，尽量不使用类继承。合成聚合是“has  a”的关系，而继承是“is  a”的关系。由于继承是一中强耦合的结构，父类变，子类必变。所以不是“is  a”关系，我们一般不要用继承。优先使用合成聚合复用原则，有助于保持每个类的封装，降低继承的层次。</p></blockquote><p>一句话点评：尽量使用对象组合，而不是继承来达到复用的目的。</p><p><strong><a href="http://www.zeze.info">博主主页</a></strong></p><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java如何消除太多的if Else判断？</title>
      <link href="/java/if-else/"/>
      <url>/java/if-else/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>if判断语句是很多编程语言的重要组成部分。但是，若我们最终编写了大量嵌套的if语句，这将使得我们的代码更加复杂和难以维护。</p></blockquote><h2 id="让我们看看能否使用别的方式来做呢。"><a href="#让我们看看能否使用别的方式来做呢。" class="headerlink" title="让我们看看能否使用别的方式来做呢。"></a>让我们看看能否使用别的方式来做呢。</h2><blockquote><p>设计模式是为了更好的代码重用性，可读性，可靠性，可维护性，它有六大原则</p></blockquote><ol><li>单一职责原则（Single Responsibility Principle，简称SRP）:该原则是针对类来说的，即一个类应该只负责一项职责.</li><li>开放–封闭原则（The Open-Closed Principle简称OCP）:是说软件实体（类、模块、函数等等）应该可以扩展，但是不可以修改。</li><li>依赖倒转原则（Dependence Inversion Principle :针对接口编程，不要对实现编程</li><li>里氏代换原则（Liskov Substitution Principle，简称LSP）:里氏代换原则，子类型必须能够替换掉他们的父类型</li><li>迪米特法则（Law of Demeter）:如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用</li><li>合成/聚合复用原则（Composition/Aggregation Principle]，简称CARP）:尽量使用合成/聚合，尽量不使用类继承。合成聚合是“has  a”的关系，而继承是“is  a”的关系。</li></ol><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="if-else"><a href="#if-else" class="headerlink" title="if..else"></a>if..else</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, String operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"add"</span>.equals(operator)) &#123;</span><br><span class="line">        result = a + b;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"multiply"</span>.equals(operator)) &#123;</span><br><span class="line">        result = a * b;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"divide"</span>.equals(operator)) &#123;</span><br><span class="line">        result = a / b;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"subtract"</span>.equals(operator)) &#123;</span><br><span class="line">        result = a - b;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"modulo"</span>.equals(operator)) &#123;</span><br><span class="line">        result = a % b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="case-switch"><a href="#case-switch" class="headerlink" title="case-switch"></a>case-switch</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateUsingSwitch</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, String operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (operator) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"add"</span>:</span><br><span class="line">        result = a + b;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"multiply"</span>:</span><br><span class="line">        result = a * b;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"divide"</span>:</span><br><span class="line">        result = a / b;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"subtract"</span>:</span><br><span class="line">        result = a - b;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"modulo"</span>:</span><br><span class="line">        result = a % b;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        result = Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h1><h2 id="工厂方式重构"><a href="#工厂方式重构" class="headerlink" title="工厂方式重构"></a>工厂方式重构</h2><blockquote><p>抽象层Operation.java</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>加法实现Addition.java：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Addition</span> <span class="keyword">implements</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>减法实现Subtraction.java</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subtraction</span> <span class="keyword">implements</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>乘法实现Multiplication.java</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Multiplication</span> <span class="keyword">implements</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a*b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>除法实现Division.java</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Division</span> <span class="keyword">implements</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>求余实现Modulo.java</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Modulo</span> <span class="keyword">implements</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a % b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>工厂类OperatorFactory.java</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Operation&gt; operationMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        operationMap.put(<span class="string">"add"</span>, <span class="keyword">new</span> Addition());</span><br><span class="line">        operationMap.put(<span class="string">"divide"</span>, <span class="keyword">new</span> Division());</span><br><span class="line">        operationMap.put(<span class="string">"multiply"</span>, <span class="keyword">new</span> Multiplication());</span><br><span class="line">        operationMap.put(<span class="string">"subtract"</span>, <span class="keyword">new</span> Subtraction());</span><br><span class="line">        operationMap.put(<span class="string">"modulo"</span>, <span class="keyword">new</span> Modulo());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;Operation&gt; <span class="title">getOperation</span><span class="params">(String operation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(operationMap.get(operation));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用示例</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateUsingFactory</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, String operator)</span> </span>&#123;</span><br><span class="line">    Operation targetOperation = OperatorFactory</span><br><span class="line">      .getOperation(operator)</span><br><span class="line">      .orElseThrow(() -&gt; <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid Operator"</span>));</span><br><span class="line">    <span class="keyword">return</span> targetOperation.apply(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举方式重构"><a href="#枚举方式重构" class="headerlink" title="枚举方式重构"></a>枚举方式重构</h2><blockquote><p>枚举实现Operator.java</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operator &#123;</span><br><span class="line">    ADD &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MULTIPLY &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a * b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUBTRACT &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a - b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a / b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MODULO &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a % b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>封装Operator到Calculator.java</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Operator operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> operator.apply(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用示例</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenCalculateUsingEnumOperator_thenReturnCorrectResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">    <span class="keyword">int</span> result = calculator.calculate(<span class="number">3</span>, <span class="number">4</span>, Operator.valueOf(<span class="string">"ADD"</span>));</span><br><span class="line">    assertEquals(<span class="number">7</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><blockquote><p>抽象的接口</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实现类（这里只写加法实现，其他的就不写了节省篇幅）</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddCommand</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>包装</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> command.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试demo</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenCalculateUsingCommand_thenReturnCorrectResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">    <span class="keyword">int</span> result = calculator.calculate(<span class="keyword">new</span> AddCommand(<span class="number">3</span>, <span class="number">7</span>));</span><br><span class="line">    assertEquals(<span class="number">10</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="规则引擎重构"><a href="#规则引擎重构" class="headerlink" title="规则引擎重构"></a>规则引擎重构</h2><blockquote><p>抽象规则</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rule</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">evaluate</span><span class="params">(Expression expression)</span></span>;</span><br><span class="line">    <span class="function">Result <span class="title">getResult</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实现规则AddRule.java（这里只写加法实现，其他的就不写了节省篇幅）</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddRule</span> <span class="keyword">implements</span> <span class="title">Rule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> result;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evaluate</span><span class="params">(Expression expression)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> evalResult = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (expression.getOperator() == Operator.ADD) &#123;</span><br><span class="line">            <span class="keyword">this</span>.result = expression.getX() + expression.getY();</span><br><span class="line">            evalResult = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> evalResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中：返回结果</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Result</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>表达式</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer x;</span><br><span class="line">    <span class="keyword">private</span> Integer y;</span><br><span class="line">    <span class="keyword">private</span> Operator operator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Expression</span><span class="params">(Integer x, Integer y, Operator operator)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">            <span class="keyword">this</span>.operator = operator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operator <span class="title">getOperator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> operator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>规则引擎RuleEngine.java</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleEngine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Rule&gt; rules = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        rules.add(<span class="keyword">new</span> AddRule());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">process</span><span class="params">(Expression expression)</span> </span>&#123;</span><br><span class="line">        Rule rule = rules.stream()</span><br><span class="line">            .filter(r -&gt; r.evaluate(expression))</span><br><span class="line">            .findFirst()</span><br><span class="line">            .orElseThrow(() -&gt; <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Expression does not matches any Rule"</span>));</span><br><span class="line">        <span class="keyword">return</span> rule.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试demo</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenNumbersGivenToRuleEngine_thenReturnCorrectResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Expression expression = <span class="keyword">new</span> Expression(<span class="number">5</span>, <span class="number">5</span>, Operator.ADD);</span><br><span class="line">    RuleEngine engine = <span class="keyword">new</span> RuleEngine();</span><br><span class="line">    Result result = engine.process(expression);</span><br><span class="line">    assertNotNull(result);</span><br><span class="line">    assertEquals(<span class="number">10</span>, result.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><table><thead><tr><th align="left">重构方式</th><th align="left">SRP</th><th align="left">OCP</th><th align="left">DIP</th><th align="left">LSP</th><th align="left">LD</th><th align="left">CARP</th></tr></thead><tbody><tr><td align="left">IF/ELSE</td><td align="left">N</td><td align="left">N</td><td align="left">N</td><td align="left">N</td><td align="left">N</td><td align="left">N</td></tr><tr><td align="left">工厂方法</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td></tr><tr><td align="left">枚举方法</td><td align="left">N</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td></tr><tr><td align="left">命令模式</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td></tr><tr><td align="left">规则引擎</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td></tr></tbody></table><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><blockquote><p>为了更好的代码重用性，可读性，可靠性，可维护性，我们会尝试将IF/ELSE或者case-switch进行改造，使用工厂方法，枚举方法，命令模式，规则引擎方式不同方法进行尝试，最后使用设计模式的六大原则对代码进行评估。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="./design6">六大设计原则</a></p><p><strong><a href="http://www.zeze.info">博主主页</a></strong></p><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIFE(即时调用函数表达式)</title>
      <link href="/javaScript/module/1/"/>
      <url>/javaScript/module/1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><blockquote><p>函数跟随一对圆括号()表示函数调用</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数声明语句写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数表达式写法</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>　　但有时需要在定义函数之后，立即调用该函数。这种函数就叫做立即执行函数，全称为立即调用的函数表达式IIFE(Imdiately Invoked Function Expression)<br>　　[注意]javascript引擎规定，如果function关键字出现在行首，一律解释成函数声明语句</p><ol><li><p>函数声明语句需要一个函数名，由于没有函数名，所以报错</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SyntaxError: Unexpected token (</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br></pre></td></tr></table></figure></li><li><p>函数声明语句后面加上一对圆括号，只是函数声明语句与分组操作符的组合而已。由于分组操作符不能为空，所以报错</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SyntaxError: Unexpected token )</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">();<span class="comment">//SyntaxError: Unexpected token )</span></span><br></pre></td></tr></table></figure></li><li><p>函数声明语句加上一对有值的圆括号，也仅仅是函数声明语句与不报错的分组操作符的组合而已</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>所以，解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式</p></li></ol><p>最常用的两种办法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;()); </span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;)();</span><br></pre></td></tr></table></figure><p>其他写法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;();</span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"><span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();</span><br></pre></td></tr></table></figure><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><blockquote><p>对于IIFE来说，通过作用域链来查找变量与普通函数有一些不同的地方</p></blockquote><h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><blockquote><p>with语句中的IIFE会先在with语句中查找，然后再向上查找。在下列代码中，标准浏览器下f()函数和IIFE都返回’bar’，但IE10-浏览器中的f()函数返回’abc’</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">with</span>(&#123;</span><br><span class="line">    foo:<span class="string">"bar"</span></span><br><span class="line">&#125;)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(foo);</span><br><span class="line">    &#125;;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(foo);</span><br><span class="line">    &#125;)();</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h2><blockquote><p>在下列代码中，标准浏览器下f()函数和IIFE都返回’error’，但IE10-浏览器中的f()函数返回’10’</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;)();</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具名函数表达式"><a href="#具名函数表达式" class="headerlink" title="具名函数表达式"></a>具名函数表达式</h2><blockquote><p>在下列代码中，标准浏览器下a()函数返回1，而IIFE返回a函数代码；但IE8-浏览器中，二者都返回1</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line">a();</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><blockquote><p>IIFE一般用于构造私有变量，避免全局空间污染</p></blockquote><p>接下来用一个需求实现来更直观地说明IIFE的用途。假设有一个需求，每次调用函数，都返回加1的一个数字(数字初始值为0)</p><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><blockquote><p>一般情况下，我们会使用全局变量来保存该数字状态</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add());<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(add());<span class="comment">//2</span></span><br></pre></td></tr></table></figure><h2 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h2><blockquote><p>但上面的方法中，变量a实际上只和add函数相关，却声明为全局变量，不太合适。</p></blockquote><p>将变量a更改为函数的自定义属性更为恰当</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++add.count;</span><br><span class="line">&#125;</span><br><span class="line">add.count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(add());<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(add());<span class="comment">//2</span></span><br></pre></td></tr></table></figure><h2 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h2><blockquote><p>其实这样做，还是有问题。有些代码可能会无意中将add.count重置</p></blockquote><p>使用IIFE把计数器变量保存为私有变量更安全，同时也可以减少对全局空间的污染</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++counter; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(add())<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(add())<span class="comment">//2</span></span><br></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><blockquote><p>执行如下代码会报错，提示此时的a是undefined</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a());<span class="comment">//报错</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这是因为没有加分号，浏览器将上面代码解释成如下所示</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a());<span class="comment">//报错</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>如果加上分号，就不会出错了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a());<span class="comment">//1</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><strong><a href="http://www.zeze.info">博主主页</a></strong></p><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript运算符——条件、逗号、赋值、()和void运算符</title>
      <link href="/javaScript/cacl/cacl2/"/>
      <url>/javaScript/cacl/cacl2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h1><blockquote><p>条件运算符是javascript中唯一的一个三元运算符(三个操作数)，有时直接称做三元运算符。通常这个运算符写成?:，当然在代码中往往不会这么简写，因为这个运算符拥有三个操作数，第一个操作数在?之前，第二个操作数在?和:之间，第三个操作数在:之后</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">variable = boolean_expression ? true_value : false_value;</span><br></pre></td></tr></table></figure><blockquote><p>本质上，这就是基于对boolean_expression求值的结果，决定给变量variable赋什么值。如果求值结果是true，则给变量variable赋值true_value；如果求值结果是false，则给变量variable赋值false_value</p></blockquote><blockquote><p>条件运算符的操作数可以是任意类型，第一个操作数当成布尔值，如果它是真值，那么将计算第二个操作数，并返回其计算结果。否则，如果第一个操作数是假值，那么将计算第三个操作数，并返回其计算结果。第二个和第三个操作数总是会计算其中之一，不可能两者同时执行</p></blockquote><blockquote><p>其实使用if语句也会带来同样的效果，’?:’运算符只是提供了一种简写形式。下面是一个’?:’的典型应用场景，判断一个变量是否有定义(并拥有一个有意义的真值)，如果有定义则使用它，如果无定义则使用一个默认值:</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">greeting = <span class="string">'hello '</span> + (username ? username : <span class="string">'there'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>这和下面使用if语句的代码是等价的，但显然上面的代码更加简洁:</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">greeting = <span class="string">'hello '</span>;</span><br><span class="line"><span class="keyword">if</span>(username)</span><br><span class="line">    greeting += username;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    greeting += <span class="string">'there'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>三元条件表达式与<code>if...else</code>语句具有同样表达效果，但是两者有一个重大差别，<code>if...else</code>是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用<code>if...else</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> ? <span class="string">'T'</span> : <span class="string">'F'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，console.log()方法的参数必须是一个表达式，这时就只能使用三元条件表达式</p></blockquote><h1 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h1><blockquote><p>逗号运算符是二元运算符，它的操作数可以是任意类型。它首先计算左操作数，然后计算右操作数，最后返回右操作数的值，用逗号运算符可以在一条语句中执行多个运算</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span>,j = <span class="number">1</span>,k = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//计算结果是2，它和下面的代码基本等价</span></span><br><span class="line">i =<span class="number">0</span>; j = <span class="number">1</span>; k = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><blockquote><p>逗号运算符常用于声明多个变量</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum1 = <span class="number">1</span>, iNum = <span class="number">2</span>, iNum3 = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><blockquote><p>逗号运算符最常用的场景是在for循环中，这个for循环通常具有多个循环变量：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for循环中的第一个逗号是var语句的一部分</span></span><br><span class="line"><span class="comment">//第二个逗号是逗号运算符</span></span><br><span class="line"><span class="comment">//它将两个表达式(i++和j--)放在一条语句中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>, j=<span class="number">10</span>;i&lt;j;i++,j--)&#123;<span class="built_in">console</span>.log(i+j);&#125;</span><br></pre></td></tr></table></figure><blockquote><p>逗号运算符还可以用于赋值，在用于赋值时，逗号运算符总是返回表达式中的最后一项</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num);<span class="comment">//5</span></span><br></pre></td></tr></table></figure><p>　　[注意]去掉括号会报错</p><h1 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h1><blockquote><p>简单的赋值操作符由等号’=’表示，作用是把等号右边的值赋予等号左边的变量或属性</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">i = o;</span><br><span class="line">o.x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><blockquote><p>‘=’运算符希望它的左操作数是一个左值：一个变量或者对象属性(或数组元素)。它的右操作数可以是任意类型的任意值。赋值表达式的值就是右操作数的值</p></blockquote><blockquote><p>尽管赋值表达式通常非常简单，但有时仍会看到一些复杂表达式包含赋值表达式的情况。例如，可以将赋值和关系操作符放在一个表达式中，就像这样：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(a=b) == <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>如果这样做的话，应该清楚知道’=’和’==’运算符之间的区别。’=’具有非常低的优先级，通常在一个较长的表达式中用到了一条赋值语句的值时的时候，需要补充圆括号以保证正确的运算顺序</p></blockquote><blockquote><p>赋值操作符的结合性是从右到左，也就是说，如果一个表达式中出现了多个赋值运算符，运算顺序是从右到左。因此，可以通过如下方式来对多个变量赋值：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">i = j = k = <span class="number">0</span>;<span class="comment">//把三个变量初始化为0</span></span><br></pre></td></tr></table></figure><blockquote><p>javascript还提供11个复合的赋值运算符，这些复合的赋值运算符，都是先进行指定运算，然后将得到的值返回给左边的变量</p></blockquote><p>　　[注意]设计这些操作符的目的是简化赋值操作，使用它们并不会带来任何性能的提升</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">total += sales_tax;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">total = total + sales_tax;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">运算符</th><th align="center">示例</th><th align="center">等价于</th></tr></thead><tbody><tr><td align="center">+=</td><td align="center">a+=b</td><td align="center">a=a+b</td></tr><tr><td align="center">-=</td><td align="center">a-=b</td><td align="center">a=a-b</td></tr><tr><td align="center">*=</td><td align="center">a*=b</td><td align="center">a=a*b</td></tr><tr><td align="center">/=</td><td align="center">a/=b</td><td align="center">a=a/b</td></tr><tr><td align="center">%=</td><td align="center">a%=b</td><td align="center">a=a%b</td></tr><tr><td align="center">&lt;&lt;=</td><td align="center">a&lt;&lt;=b</td><td align="center">a=a&lt;&lt;b</td></tr><tr><td align="center">&gt;&gt;=</td><td align="center">a&gt;&gt;=b</td><td align="center">a=a&gt;&gt;b</td></tr><tr><td align="center">&gt;&gt;&gt;=</td><td align="center">a&gt;&gt;&gt;=b</td><td align="center">a=a&gt;&gt;&gt;b</td></tr><tr><td align="center">&amp;=</td><td align="center">a&amp;=b</td><td align="center">a=a&amp;b</td></tr><tr><td align="center"></td><td align="center">=</td><td align="center">a</td></tr><tr><td align="center">^=</td><td align="center">a^=b</td><td align="center">a=a^b</td></tr></tbody></table><blockquote><p>在大多数情况下，表达式为:</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a op= b</span><br></pre></td></tr></table></figure><blockquote><p>这里op代表一个运算符，这个表达式和下面的表达式等价</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = a op b</span><br></pre></td></tr></table></figure><blockquote><p>在第一行中，表达式a计算了一次，在第二行中，表达式a计算了两次，只有在a包含具有副作用的表达式(比如函数调用和赋值操作)的时候，两者才不等价</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data[i++]*=<span class="number">2</span>;</span><br><span class="line">data[i++] = data[i++]*<span class="number">2</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],i=<span class="number">0</span>;</span><br><span class="line">data[++i]+=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(data);<span class="comment">//[0,11,2]</span></span><br><span class="line"><span class="keyword">var</span> data = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],i=<span class="number">0</span>;</span><br><span class="line">data[++i]= data[++i] + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(data);<span class="comment">//[0,12,2]</span></span><br></pre></td></tr></table></figure><h1 id="圆括号运算符"><a href="#圆括号运算符" class="headerlink" title="圆括号运算符"></a>圆括号运算符</h1><blockquote><p>圆括号运算符也叫分组运算符，它有两种用法：如果表达式放在圆括号中，作用是求值；如果跟在函数后面，作用是调用函数</p></blockquote><blockquote><p>把表达式放在圆括号之中，将返回表达式的值</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">1</span>));  <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="string">'a'</span>)); <span class="comment">//'a'</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">1</span>+<span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><blockquote><p>把对象放在圆括号之中，则会返回对象的值，即对象本身</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">p</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log((o));<span class="comment">// Object &#123;p: 1&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>将函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数，即对函数求值</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line"><span class="built_in">console</span>.log((f));<span class="comment">// function f()&#123;return 1;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>　　[注意]圆括号运算符不能为空，否则会报错</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">();<span class="comment">//SyntaxError: Unexpected token )</span></span><br></pre></td></tr></table></figure><blockquote><p>由于圆括号的作用是求值，如果将语句放在圆括号之中，就会报错，因为语句没有返回值</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">var</span> a = <span class="number">1</span>);<span class="comment">// SyntaxError: Unexpected token var</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">var</span> a = <span class="number">1</span>));<span class="comment">// SyntaxError: Unexpected token var</span></span><br></pre></td></tr></table></figure><h1 id="void运算符"><a href="#void运算符" class="headerlink" title="void运算符"></a>void运算符</h1><blockquote><p>void是一元运算符，它出现在操作数之前，操作数可以是任意类型，操作数会照常计算，但忽略计算结果并返回undefined。由于void会忽略操作数的值，因此在操作数具有副作用的时候使用void来让程序更具语义</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">void</span> <span class="number">0</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">void</span>(<span class="number">0</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="【作用一】替代undefined"><a href="#【作用一】替代undefined" class="headerlink" title="【作用一】替代undefined"></a>【作用一】替代undefined</h2><blockquote><p>由于undefined并不是一个关键字，其在IE8-浏览器中会被重写，在高版本函数作用域中也会被重写；所以可以用void 0 来替换undefined</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>);<span class="comment">//IE8-浏览器下为10，高版本浏览器下为undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(t());<span class="comment">//所有浏览器下都是10</span></span><br></pre></td></tr></table></figure><h2 id="【作用二】客户端URL"><a href="#【作用二】客户端URL" class="headerlink" title="【作用二】客户端URL"></a>【作用二】客户端URL</h2><blockquote><p>这个运算符最常用在客户端URL——javascript:URL中，在URL中可以写带有副作用的表达式，而void则让浏览器不必显示这个表达式的计算结果。例如，经常在HTML代码中的<a>标签里使用void运算符</a></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">"javascript:void window.open();"</span>&gt;打开一个新窗口&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure><h2 id="【作用三】阻止默认事件"><a href="#【作用三】阻止默认事件" class="headerlink" title="【作用三】阻止默认事件"></a>【作用三】阻止默认事件</h2><blockquote><p>阻止默认事件的方式是给事件置返回值false</p></blockquote><p>``js<br>//一般写法<br><a href="http://example.com" target="_blank" rel="external nofollow noopener noreferrer" onclick="f();return false;">文字</a></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;使用void运算符可以取代上面写法</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(f())"</span>&gt;</span>文字<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong><a href="http://www.zeze.info">博主主页</a></strong></p><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> js运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java高并发编程四-线程的常用方法</title>
      <link href="/java/concurrent/j3/"/>
      <url>/java/concurrent/j3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="做个笔记-java线程常用的方法-过一遍留点印象"><a href="#做个笔记-java线程常用的方法-过一遍留点印象" class="headerlink" title="做个笔记,java线程常用的方法,过一遍留点印象"></a>做个笔记,java线程常用的方法,过一遍留点印象</h1><table><thead><tr><th align="left">编号</th><th align="center">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">public void start()</td><td align="left">使该线程开始执行；Java 虚拟机调用该线程的 run 方法。</td></tr><tr><td align="left">2</td><td align="center">public void run()</td><td align="left">如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。</td></tr><tr><td align="left">3</td><td align="center">public final void setName(String name)</td><td align="left">改变线程名称，使之与参数 name 相同。</td></tr><tr><td align="left">4</td><td align="center">public final void setPriority(int priority)</td><td align="left">更改线程的优先级。</td></tr><tr><td align="left">5</td><td align="center">public final void setDaemon(boolean on)</td><td align="left">将该线程标记为守护线程或用户线程。</td></tr><tr><td align="left">6</td><td align="center">public final void join(long millisec)</td><td align="left">等待该线程终止的时间最长为 millis 毫秒。</td></tr><tr><td align="left">7</td><td align="center">public void interrupt()</td><td align="left">中断线程。</td></tr><tr><td align="left">8</td><td align="center">public final boolean isAlive()</td><td align="left">测试线程是否处于活动状态。</td></tr><tr><td align="left">9</td><td align="center">public static void yield()</td><td align="left">暂停当前正在执行的线程对象，并执行其他线程。</td></tr><tr><td align="left">10</td><td align="center">public static void sleep(long millisec)</td><td align="left">在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</td></tr><tr><td align="left">11</td><td align="center">public static Thread currentThread()</td><td align="left">返回对当前正在执行的线程对象的引用。</td></tr></tbody></table><h1 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h1><h2 id="currentThread-方法可以返回代码段正在被哪个线程调用的信息。"><a href="#currentThread-方法可以返回代码段正在被哪个线程调用的信息。" class="headerlink" title="currentThread()方法可以返回代码段正在被哪个线程调用的信息。"></a>currentThread()方法可以返回代码段正在被哪个线程调用的信息。</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;                 </span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep()方法"></a>sleep()方法</h2><blockquote><p>方法sleep()的作用是在指定的毫秒数内让当前“正在执行的线程”休眠（暂停执行）。这个“正在执行的线程”是指this.currentThread()返回的线程。</p></blockquote><p>sleep方法有两个重载版本：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sleep(<span class="keyword">long</span> millis)     <span class="comment">//参数为毫秒</span></span><br><span class="line">sleep(<span class="keyword">long</span> millis,<span class="keyword">int</span> nanoseconds)    <span class="comment">//第一参数为毫秒，第二个参数为纳秒</span></span><br></pre></td></tr></table></figure><blockquote><p>sleep相当于让线程睡眠，交出CPU，让CPU去执行其他的任务。但是有一点要非常注意，<code>sleep方法不会释放锁</code>，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。看下面这个例子就清楚了：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        MyThread thread1 = test.<span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread thread2 = test.<span class="keyword">new</span> MyThread();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.println(<span class="string">"i:"</span>+i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"进入睡眠状态"</span>);</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"睡眠结束"</span>);</span><br><span class="line">                i++;</span><br><span class="line">                System.out.println(<span class="string">"i:"</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/java/concurrent/20191230112613.png!www.zeze.info" alt="线程"></p><blockquote><p>从上面输出结果可以看出，当Thread-0进入睡眠状态之后，Thread-1并没有去执行具体的任务。只有当Thread-0执行完之后，此时Thread-0释放了对象锁，Thread-1才开始执行。</p></blockquote><blockquote><p>注意，如果调用了sleep方法，必须捕获<code>InterruptedException</code>异常或者将该异常向上层抛出。当线程睡眠时间满后，不一定会立即得到执行，因为此时可能CPU正在执行其他的任务。所以说调用sleep方法相当于让线程进入阻塞状态。</p></blockquote><h2 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h2><blockquote><p>调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体的交出CPU的时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。</p></blockquote><blockquote><p>注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。代码：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>  <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> beginTime=System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50000000</span>;i++)&#123;</span><br><span class="line">            count=count+(i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//Thread.yield();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime=System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"用时："</span>+(endTime-beginTime)+<span class="string">" 毫秒！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread t= <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用时：3 毫秒！</span></span><br><span class="line"><span class="comment">//如果将 Thread.yield();的注释去掉，执行结果如下：</span></span><br><span class="line">用时：<span class="number">16080</span> 毫秒！</span><br></pre></td></tr></table></figure><h1 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h1><h2 id="start-方法"><a href="#start-方法" class="headerlink" title="start()方法"></a>start()方法</h2><blockquote><p>start()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程来执行用户定义的子任务，在这个过程中，会为相应的线程分配需要的资源。</p></blockquote><h2 id="run-方法"><a href="#run-方法" class="headerlink" title="run()方法"></a>run()方法</h2><blockquote><p>run()方法是不需要用户来调用的，当通过start方法启动一个线程之后，当线程获得了CPU执行时间，便进入run方法体去执行具体的任务。注意，继承Thread类必须重写run方法，在run方法中定义具体要执行的任务。</p></blockquote><h2 id="getId"><a href="#getId" class="headerlink" title="getId()"></a>getId()</h2><blockquote><p>getId()的作用是取得线程的唯一标识</p></blockquote><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        Thread t= Thread.currentThread();</span><br><span class="line">        System.out.<span class="built_in">println</span>(t.getName()+<span class="string">" "</span>+t.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main 1</span></span><br></pre></td></tr></table></figure><h2 id="isAlive-方法"><a href="#isAlive-方法" class="headerlink" title="isAlive()方法"></a>isAlive()方法</h2><blockquote><p>方法isAlive()的功能是判断当前线程是否处于活动状态</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>  <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"run="</span>+<span class="keyword">this</span>.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread myThread=<span class="keyword">new</span> MyThread();</span><br><span class="line">        System.out.println(<span class="string">"begin =="</span>+myThread.isAlive());</span><br><span class="line">        myThread.start();</span><br><span class="line">        System.out.println(<span class="string">"end =="</span>+myThread.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//begin ==false</span></span><br><span class="line"><span class="comment">//run=true</span></span><br><span class="line"><span class="comment">//end ==false</span></span><br></pre></td></tr></table></figure><blockquote><p>方法isAlive()的作用是测试线程是否偶处于活动状态。什么是活动状态呢？活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备开始运行的状态，就认为线程是“存活”的。</p></blockquote><p><strong>有个需要注意的地方</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"end =="</span>+myThread.isAlive());</span><br></pre></td></tr></table></figure><p>虽然上面的实例中打印的值是true,但此值是不确定的。打印true值是因为myThread线程还未执行完毕，所以输出true。如果代码改成下面这样，加了个sleep休眠：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    MyThread myThread=<span class="keyword">new</span> MyThread();</span><br><span class="line">    System.out.println(<span class="string">"begin =="</span>+myThread.isAlive());</span><br><span class="line">    myThread.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(<span class="string">"end =="</span>+myThread.isAlive());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>则上述代码运行的结果输出为false,因为mythread对象已经在1秒之内执行完毕。</p></blockquote><h2 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h2><blockquote><p>在很多情况下，主线程创建并启动了线程，如果子线程中药进行大量耗时运算，主线程往往将早于子线程结束之前结束。这时，如果主线程想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到join()方法了。方法join()的作用是等待线程对象销毁。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread4</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread4</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">"  "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 启动子进程</span></span><br><span class="line">        <span class="keyword">new</span> Thread4(<span class="string">"new thread"</span>).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                Thread4 th = <span class="keyword">new</span> Thread4(<span class="string">"joined thread"</span>);</span><br><span class="line">                th.start();</span><br><span class="line">                th.join();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">由上可以看出main主线程等待joined thread线程先执行完了才结束的。如果把th.join()这行注释掉，运行结果如下：</span></span><br><span class="line"><span class="comment">main  0</span></span><br><span class="line"><span class="comment">main  1</span></span><br><span class="line"><span class="comment">main  2</span></span><br><span class="line"><span class="comment">main  3</span></span><br><span class="line"><span class="comment">main  4</span></span><br><span class="line"><span class="comment">new thread  0</span></span><br><span class="line"><span class="comment">new thread  1</span></span><br><span class="line"><span class="comment">new thread  2</span></span><br><span class="line"><span class="comment">new thread  3</span></span><br><span class="line"><span class="comment">new thread  4</span></span><br><span class="line"><span class="comment">joined thread  0</span></span><br><span class="line"><span class="comment">joined thread  1</span></span><br><span class="line"><span class="comment">joined thread  2</span></span><br><span class="line"><span class="comment">joined thread  3</span></span><br><span class="line"><span class="comment">joined thread  4</span></span><br><span class="line"><span class="comment">main  5</span></span><br><span class="line"><span class="comment">main  6</span></span><br><span class="line"><span class="comment">main  7</span></span><br><span class="line"><span class="comment">main  8</span></span><br><span class="line"><span class="comment">main  9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="getName和setName"><a href="#getName和setName" class="headerlink" title="getName和setName"></a>getName和setName</h2><p>用来得到或者设置线程名称。</p><h2 id="getPriority和setPriority"><a href="#getPriority和setPriority" class="headerlink" title="getPriority和setPriority"></a>getPriority和setPriority</h2><p>用来获取和设置线程优先级。此方法不常用,这种方式不可靠</p><h2 id="setDaemon和isDaemon"><a href="#setDaemon和isDaemon" class="headerlink" title="setDaemon和isDaemon"></a>setDaemon和isDaemon</h2><p>用来设置线程是否成为守护线程和判断线程是否是守护线程。</p><p>守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。在JVM中，像垃圾收集器线程就是守护线程。</p><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="线程和进程有什么区别？"><a href="#线程和进程有什么区别？" class="headerlink" title="线程和进程有什么区别？"></a>线程和进程有什么区别？</h2><blockquote><p>答：一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。</p></blockquote><h2 id="如何在Java中实现线程？"><a href="#如何在Java中实现线程？" class="headerlink" title="如何在Java中实现线程？"></a>如何在Java中实现线程？</h2><p>答：创建线程有两种方式：</p><ol><li>继承 Thread 类，扩展线程。</li><li>实现 Runnable 接口。</li><li>Callable接口</li></ol><h2 id="启动一个线程是调用run-还是start-方法？"><a href="#启动一个线程是调用run-还是start-方法？" class="headerlink" title="启动一个线程是调用run()还是start()方法？"></a>启动一个线程是调用run()还是start()方法？</h2><p>答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法</p><h2 id="Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别"><a href="#Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别" class="headerlink" title="Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?"></a>Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</h2><blockquote><p>sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，<code>将执行机会（CPU）让给其他线程，但是对象的锁依然保持</code>，因此休眠时间结束后会自动恢复。wait()是Object类的方法，调用对象的wait()方法导致当前线程<code>放弃对象的锁</code>（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</p></blockquote><h2 id="线程的sleep-方法和yield-方法有什么区别？"><a href="#线程的sleep-方法和yield-方法有什么区别？" class="headerlink" title="线程的sleep()方法和yield()方法有什么区别？"></a>线程的sleep()方法和yield()方法有什么区别？</h2><ol><li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</li><li>线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；</li><li>sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；</li><li>sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。</li></ol><h2 id="请说出与线程同步以及线程调度相关的方法。"><a href="#请说出与线程同步以及线程调度相关的方法。" class="headerlink" title="请说出与线程同步以及线程调度相关的方法。"></a>请说出与线程同步以及线程调度相关的方法。</h2><ul><li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</li><li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；</li><li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；</li><li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</li></ul><h1 id="小伙伴一起加油吧"><a href="#小伙伴一起加油吧" class="headerlink" title="小伙伴一起加油吧"></a>小伙伴一起加油吧</h1><p><strong><a href="http://www.zeze.info">博主主页</a></strong></p><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java高并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的map和reduce</title>
      <link href="/java/concurrent/j2/"/>
      <url>/java/concurrent/j2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote><p>虽然目前处理器核心数已经发展到很大数目，但是按任务并发处理并不能完全充分的利用处理器资源，因为一般的应用程序没有那么多的并发处理任务。基于这种现状，考虑把一个任务拆分成多个单元，每个单元分别得到执行，最后合并每个单元的结果。</p></blockquote><blockquote><p><code>Fork/Join</code>框架是<code>JAVA7</code>提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架</p></blockquote><h1 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h1><blockquote><p>指的是某个线程从其他队列里窃取任务来执行。使用的场景是一个大任务拆分成多个小任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列中，并且每个队列都有单独的线程来执行队列里的任务，线程和队列一一对应。但是会出现这样一种情况：A线程处理完了自己队列的任务，B线程的队列里还有很多任务要处理。A是一个很热情的线程，想过去帮忙，但是如果两个线程访问同一个队列，会产生竞争，所以A想了一个办法，从双端队列的尾部拿任务执行。而B线程永远是从双端队列的头部拿任务执行（任务是一个个独立的小任务），这样感觉A线程像是小偷在窃取B线程的东西一样。</p></blockquote><p><strong>工作窃取算法的优点：</strong><br><code>利用了线程进行并行计算，减少了线程间的竞争。</code></p><p><strong>工作窃取算法的缺点：</strong></p><ol><li>如果双端队列中只有一个任务时，线程间会存在竞争。</li><li>窃取算法消耗了更多的系统资源，如会创建多个线程和多个双端队列。</li></ol><h1 id="框架设计"><a href="#框架设计" class="headerlink" title="框架设计"></a>框架设计</h1><p>Fork/Join中两个重要的类：</p><ol><li>ForkJoinTask：使用该框架，需要创建一个ForkJoin任务，它提供在任务中执行fork和join操作的机制。一般情况下，我们并不需要直接继承ForkJoinTask类，只需要继承它的子类，它的子类有两个：<br> a、RecursiveAction:用于没有返回结果的任务。<br> b、RecursiveTask:用于有返回结果的任务。</li><li>ForkJoinPool：任务ForkJoinTask需要通过ForkJoinPool来执行。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">//阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断任务是否足够小</span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line">        <span class="keyword">if</span>(canCompute)&#123;</span><br><span class="line">            <span class="comment">//如果小于阈值，就进行运算</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=end; i++)&#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果大于阈值，就再进行任务拆分</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + end)/<span class="number">2</span>;</span><br><span class="line">            CountTask leftTask = <span class="keyword">new</span>  CountTask(start,middle);</span><br><span class="line">            CountTask rightTask = <span class="keyword">new</span>  CountTask(middle+<span class="number">1</span>,end);</span><br><span class="line">            <span class="comment">//执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            <span class="comment">//等待子任务执行完，并得到执行结果</span></span><br><span class="line">            <span class="keyword">int</span> leftResult = leftTask.join();</span><br><span class="line">            <span class="keyword">int</span> rightResult = rightTask.join();</span><br><span class="line">            <span class="comment">//合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>,<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//执行一个任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ExecutionException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>这个程序是将1+2+3+4+5+6拆分成1+2；3+4；5+6三个部分进行子程序进行计算后合并。</code></p><h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><p>leftTask.fork();</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">            ((ForkJoinWorkerThread)t).workQueue.push(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ForkJoinPool.common.externalPush(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>fork方法内部会先判断当前线程是否是ForkJoinWorkerThread的实例，如果满足条件，则将task任务push到当前线程所维护的双端队列中。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p;</span><br><span class="line">    <span class="keyword">int</span> b = base, s = top, n;</span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span>) &#123;    <span class="comment">// ignore if queue removed</span></span><br><span class="line">        <span class="keyword">int</span> m = a.length - <span class="number">1</span>;     <span class="comment">// fenced write for task visibility</span></span><br><span class="line">        U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);</span><br><span class="line">        U.putOrderedInt(<span class="keyword">this</span>, QTOP, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((n = s - b) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = pool) != <span class="keyword">null</span>)</span><br><span class="line">                p.signalWork(p.workQueues, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= m)</span><br><span class="line">            growArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在push方法中，会调用ForkJoinPool的signalWork方法唤醒或创建一个工作线程来异步执行该task任务。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过doJoin方法返回的任务状态来判断，如果不是NORMAL，则抛异常：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportException</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (s == CANCELLED) <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException(); </span><br><span class="line">     <span class="keyword">if</span> (s == EXCEPTIONAL) rethrow(getThrowableException()); </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>来看下doJoin方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        tryUnpush(<span class="keyword">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        wt.pool.awaitJoin(w, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>先查看任务状态，如果已经完成，则直接返回任务状态；如果没有完成，则从任务队列中取出任务并执行。</p></blockquote><h1 id="Java8-map和reduce"><a href="#Java8-map和reduce" class="headerlink" title="Java8 map和reduce"></a>Java8 map和reduce</h1><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">final</span> List&lt;Integer&gt; doubleNumbers = numbers.stream()</span><br><span class="line">                .map(number -&gt; number * <span class="number">2</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>结果：[2, 4, 6, 8]</p><p>也可以搞成其他的类型，初始List是Integer，也可以变成String</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">       <span class="keyword">final</span> List&lt;String&gt; numberIndex = numbers.stream()</span><br><span class="line">               .map(number -&gt; <span class="string">"#"</span> + number)</span><br><span class="line">               .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>结果：[#1, #2, #3, #4]</p><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><ol><li>不提供初始值的reduce，返回值是Optional，表示可能为空，使用orElseGet可以返回一个null时的默认值</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">final</span> Optional&lt;Integer&gt; sum = numbers.stream()</span><br><span class="line">                .reduce((a, b) -&gt; a + b);</span><br><span class="line">sum.orElseGet(() -&gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>结果：10<br>这里的<code>(a, b) -&gt; a + b</code>的类型其实是<code>BinaryOperator</code>，它接受两个类型相同的参数<br>当把<code>numbers</code>改为<code>Arrays.asList()</code>时，结果为0。</p><ol start="2"><li>使用初始值的reduce，因为提供了初始值，所以返回值不再是<code>Optional</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="keyword">final</span> Integer sum = numbers.stream() .reduce(<span class="number">0</span>, (a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure><p>结果：10</p><p><strong><a href="http://www.zeze.info">博主主页</a></strong></p><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java高并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结!Java8增强的Future:CompletableFuture</title>
      <link href="/java/concurrent/j1/"/>
      <url>/java/concurrent/j1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java8增强的Future-CompletableFuture"><a href="#Java8增强的Future-CompletableFuture" class="headerlink" title="Java8增强的Future:CompletableFuture"></a>Java8增强的Future:CompletableFuture</h1><blockquote><p>CompletableFuture是Java8新增的一个超大型工具类,为什么说她大呢?因为一方面它实现了Future接口,更重要的是,它实现了CompletionStage接口.这个接口也是Java8新增加的,而CompletionStage拥有多达约40种方法,</p></blockquote><p>通过CompletableFuture提供进一步封装,我们很容易实现Future模式那样的异步调用,例如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">cale</span><span class="params">(Integer para)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> para * para;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; cale(<span class="number">50</span>));</span><br><span class="line">    System.out.println(future.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码中CompletableFuture.supplyAsync()方法构造了一个CompletableFuture实例,在supplyAsync()函数中,他会在一个新的线程中,执行传入的参数.在这里,他会执行calc()方法,而calc()方法的执行可能是比较慢的,但是不影响CompletableFuture实例的构造速度,因此supplyAsync()会立即返回,他返回的CompletableFuture对象实例就可以作为这次调用的契约,在将来任何场合,用于获得最终的计算结果.在CompletableFuture中,类似的工厂方法有以下几个:</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier,Executor executor)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable,Executor executor)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>其中<code>supplyAsync()</code>方法用于那些需要返回值的场景,比如计算某个数据,而<code>runAsync()</code>方法用于没有返回值的场景,比如,仅仅是简单地执行某一个异步动作.</p></blockquote><blockquote><p>首先说明一下已<code>Async</code>结尾的方法都是可以异步执行的，如果指定了线程池，会在指定的线程池中执行，如果没有指定，默认会在<code>ForkJoinPool.commonPool()</code>中执行</p></blockquote><blockquote><p>在这两对方法中,都有一个方法可以接手一个<code>Executor</code>参数,这使我们可以让<code>Supplier&lt;U&gt;</code>或者<code>Runnable</code>在指定的线程池工作,如果不指定,则在默认的系统公共的<code>ForkJoinPool.common</code>线程池中执行.</p></blockquote><h1 id="流式调用"><a href="#流式调用" class="headerlink" title="流式调用"></a>流式调用</h1><blockquote><p>在前文中我已经简单的提到<code>CompletionStage</code>的约40个接口为函数式编程做准备的,在这里,就让我们看一下,如果使用这些接口进行函数式的流式API调用</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">cale</span><span class="params">(Integer para)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> para * para;</span><br><span class="line">&#125;</span><br><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture</span><br><span class="line">        .supplyAsync(() -&gt; cale(<span class="number">50</span>))</span><br><span class="line">        .thenApply(i -&gt; Integer.toString(i))</span><br><span class="line">        .thenApply(str -&gt; <span class="string">"\""</span> + str + <span class="string">"\""</span>)</span><br><span class="line">        .thenAccept(System.out::println);</span><br><span class="line">future.get();</span><br></pre></td></tr></table></figure><blockquote><p>上述代码中,使用<code>supplyAsync()</code>函数执行了一个异步任务,接着连续使用流式调用对任务处理结果进行在加工,直到最后的结果输出:</p></blockquote><h1 id="CompletableFuture中的异常处理"><a href="#CompletableFuture中的异常处理" class="headerlink" title="CompletableFuture中的异常处理"></a>CompletableFuture中的异常处理</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">cale</span><span class="params">(Integer para)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> para * para;</span><br><span class="line">&#125;</span><br><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture</span><br><span class="line">        .supplyAsync(() -&gt; cale(<span class="number">50</span>))</span><br><span class="line">        .exceptionally(ex -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"ex.toString() = "</span> + ex.toString());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .thenApply(i -&gt; Integer.toString(i))</span><br><span class="line">        .thenApply(str -&gt; <span class="string">"\""</span> + str + <span class="string">"\""</span>)</span><br><span class="line">        .thenAccept(System.out::println);</span><br><span class="line">future.get()</span><br></pre></td></tr></table></figure><h1 id="组合多个CompletableFuture"><a href="#组合多个CompletableFuture" class="headerlink" title="组合多个CompletableFuture"></a>组合多个CompletableFuture</h1><blockquote><p><code>CompletableFuture</code>还允许你将多个<code>CompletableFuture</code>进行组合,一种方法是使用<code>thenCompose()</code>,它的方法签名如下:</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt;CompletableFuture&lt;U&gt;thenCompose(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture</span><br><span class="line">        .supplyAsync(() -&gt; cale(<span class="number">50</span>))</span><br><span class="line">        .thenCompose(i -&gt; CompletableFuture</span><br><span class="line">                .supplyAsync(() -&gt; cale(i)))</span><br><span class="line">        .thenApply(i -&gt; Integer.toString(i))</span><br><span class="line">        .thenApply(str -&gt; <span class="string">"\""</span> + str + <span class="string">"\""</span>)</span><br><span class="line">        .thenAccept(System.out::println);</span><br><span class="line">future.get();</span><br></pre></td></tr></table></figure><blockquote><p>另外一种组和多个<code>CompletableFuture</code>的方法是<code>thenCombine()</code>它的签名如下:</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombine</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*方法thenCombine()首先完成当前CompletableFuture和other的执行,</span></span></span><br><span class="line"><span class="function"><span class="comment">接着,将这两者的执行结果传递给BiFunction(该接口接受两个参数,并有一个返回值),</span></span></span><br><span class="line"><span class="function"><span class="comment">并返回代表BiFuntion实例的CompletableFuture对象:*/</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;Integer&gt; future1 </span>= CompletableFuture.supplyAsync(() -&gt; cale(<span class="number">50</span>));</span><br><span class="line">CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; cale(<span class="number">25</span>));</span><br><span class="line">CompletableFuture&lt;Void&gt; fu = future1.thenCombine(future2, (i, j) -&gt; (i + j))</span><br><span class="line">        .thenApply(str -&gt; <span class="string">"\""</span> + str + <span class="string">"\""</span>)</span><br><span class="line">        .thenAccept(System.out::println);</span><br><span class="line">fu.get();</span><br></pre></td></tr></table></figure><h1 id="实现异步API"><a href="#实现异步API" class="headerlink" title="实现异步API"></a>实现异步API</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calculatePrice(product);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步计算商品价格的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> product 商品名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 价格</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">calculatePrice</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">    delay();</span><br><span class="line">    <span class="keyword">return</span> random.nextDouble() * product.charAt(<span class="number">0</span>) + product.charAt(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟计算,查询数据库等耗时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步计算商品的价格.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> product 商品名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 价格</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Double&gt; <span class="title">getPriceAsync</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Double&gt; futurePrice = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">double</span> price = calculatePrice(product);</span><br><span class="line">        futurePrice.complete(price);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">return</span> futurePrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="将同步方法装换为异步方法"><a href="#将同步方法装换为异步方法" class="headerlink" title="将同步方法装换为异步方法"></a>将同步方法装换为异步方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步计算商品的价格.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> product 商品名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 价格</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Double&gt; <span class="title">getPriceAsync</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Double&gt; futurePrice = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">double</span> price = calculatePrice(product);</span><br><span class="line">        futurePrice.complete(price);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">return</span> futurePrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用异步API 模拟客户端</span><br><span class="line">Shop shop = <span class="keyword">new</span> Shop(<span class="string">"BestShop"</span>);</span><br><span class="line"><span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">Future&lt;Double&gt; futurePrice = shop.getPriceAsync(<span class="string">"my favorite product"</span>);</span><br><span class="line"><span class="keyword">long</span> incocationTime = (System.nanoTime() - start) / <span class="number">1_000_000</span>;</span><br><span class="line">System.out.println(<span class="string">"执行时间:"</span> + incocationTime + <span class="string">" msecs"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Double price = futurePrice.get();</span><br><span class="line">    System.out.printf(<span class="string">"Price is %.2f%n"</span>, price);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> retrievalTime = (System.nanoTime() - start) / <span class="number">1_000_000</span>;</span><br><span class="line">System.out.println(<span class="string">"retrievalTime:"</span> + retrievalTime + <span class="string">" msecs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//&gt;执行时间:37 msecs</span></span><br><span class="line"><span class="comment">//&gt;Price is 125.79</span></span><br><span class="line"><span class="comment">//&gt;retrievalTime:1055 msecs</span></span><br></pre></td></tr></table></figure><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><blockquote><p>上述代码,如果没有意外,可以正常工作,但是如果价格计算过程中生产了错误会怎样呢?非常不幸,这种情况下你会得到一个相当糟糕的结果:</p></blockquote><blockquote><p>用于提示错误的异常会限制在视图计算商品的价格的当前线程的范围内,最终会杀死该线程,而这会导致等待get方法放回结果的客户端永久的被阻塞,而这会导致等待get方法放回结果的客户端永久的被阻塞, 为了让客户端能了解商店无法提供请求商品价格的原因.我们对代码优化,!</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步计算商品的价格.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> product 商品名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 价格</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Double&gt; <span class="title">getPriceAsync</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Double&gt; futurePrice = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> price = calculatePrice(product);</span><br><span class="line">            futurePrice.complete(price);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//否则就抛出异常,完成这次future操作</span></span><br><span class="line">            futurePrice.completeExceptionally(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">return</span> futurePrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用工厂方法supplyAsync创建CompletableFuture"><a href="#使用工厂方法supplyAsync创建CompletableFuture" class="headerlink" title="使用工厂方法supplyAsync创建CompletableFuture"></a>使用工厂方法supplyAsync创建CompletableFuture</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步计算商品的价格.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> product 商品名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 价格</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Double&gt; <span class="title">getPriceAsync</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* CompletableFuture&lt;Double&gt; futurePrice = new CompletableFuture&lt;&gt;();</span></span><br><span class="line"><span class="comment">    new Thread(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            double price = calculatePrice(product);</span></span><br><span class="line"><span class="comment">            futurePrice.complete(price);</span></span><br><span class="line"><span class="comment">        &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">            //否则就抛出异常,完成这次future操作</span></span><br><span class="line"><span class="comment">            futurePrice.completeExceptionally(e);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;).start();</span></span><br><span class="line"><span class="comment">    return futurePrice;*/</span></span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; calculatePrice(product));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="让代码免受阻塞之苦"><a href="#让代码免受阻塞之苦" class="headerlink" title="让代码免受阻塞之苦"></a>让代码免受阻塞之苦</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例:最佳价格查询器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Shop&gt; shops = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Shop(<span class="string">"BestPrice"</span>),</span><br><span class="line">        <span class="keyword">new</span> Shop(<span class="string">":LetsSaveBig"</span>),</span><br><span class="line">        <span class="keyword">new</span> Shop(<span class="string">"MyFavoriteShop"</span>),</span><br><span class="line">        <span class="keyword">new</span> Shop(<span class="string">"BuyItAll"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最佳价格查询器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> product 商品</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">findprices</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> shops</span><br><span class="line">            .stream()</span><br><span class="line">            .map(shop -&gt; String.format(<span class="string">"%s price is %.2f"</span>, shop.getName(), shop.getPrice(product)))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证findprices的正确性和执行性能</span></span><br><span class="line"><span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">System.out.println(findprices(<span class="string">"myPhones27s"</span>));</span><br><span class="line"><span class="keyword">long</span> duration = (System.nanoTime() - start) / <span class="number">1_000_000</span>;</span><br><span class="line">System.out.println(<span class="string">"Done in "</span> + duration+<span class="string">" msecs"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[BestPrice price is 197.76, :</span></span><br><span class="line"><span class="comment">LetsSaveBig price is 155.39, </span></span><br><span class="line"><span class="comment">MyFavoriteShop price is 124.21,</span></span><br><span class="line"><span class="comment">BuyItAll price is 139.23]</span></span><br><span class="line"><span class="comment">Done in 4071 msecs</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="使用平行流对请求进行并行操作"><a href="#使用平行流对请求进行并行操作" class="headerlink" title="使用平行流对请求进行并行操作"></a>使用平行流对请求进行并行操作</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最佳价格查询器(并行流)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> product 商品</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parallelFindprices</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> shops</span><br><span class="line">            .parallelStream()</span><br><span class="line">            .map(shop -&gt; String.format(<span class="string">"%s price is %.2f"</span>, shop.getName(), shop.getPrice(product)))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[BestPrice price is 201.41, :</span></span><br><span class="line"><span class="comment">LetsSaveBig price is 153.64,</span></span><br><span class="line"><span class="comment">MyFavoriteShop price is 224.65, </span></span><br><span class="line"><span class="comment">BuyItAll price is 211.83]</span></span><br><span class="line"><span class="comment">Done in 1064 msecs</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>相当不错,看起来这是个简单有效的主意,对4个不同商店的查询实现了并行.所有完成操作的总耗时只有1秒多一点,让我们尝试使用<code>CompletableFuture</code>,将<code>findprices</code>方法中对不同商店的同步调用替换为异步调用.</p></blockquote><h1 id="使用CompletableFuture发起异步请求"><a href="#使用CompletableFuture发起异步请求" class="headerlink" title="使用CompletableFuture发起异步请求"></a>使用CompletableFuture发起异步请求</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最佳价格查询器(异步调用实现)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> product 商品</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">asyncFindprices</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用这种方式,你会得到一个List&lt;CompletableFuture&lt;String&gt;&gt;,</span></span><br><span class="line">    <span class="comment">//列表中的每一个CompletableFuture对象在计算完成后都包含商店的String类型的名称.</span></span><br><span class="line">    <span class="comment">//但是,由于你用CompletableFuture实现了asyncFindprices方法要求返回一个List&lt;String&gt;.</span></span><br><span class="line">    <span class="comment">//你需要等待所有的future执行完毕,将其包含的值抽取出来,填充到列表中才能返回</span></span><br><span class="line">    List&lt;CompletableFuture&lt;String&gt;&gt; priceFuture = shops</span><br><span class="line">            .stream()</span><br><span class="line">            .map(shop -&gt;CompletableFuture.supplyAsync(() -&gt;</span><br><span class="line">     String.format(<span class="string">"%s price is %.2f"</span>, shop.getName(), shop.getPrice(product))))</span><br><span class="line">                 .collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//为了实现这个效果,我门可以向最初的List&lt;CompletableFuture&lt;String&gt;&gt;</span></span><br><span class="line">    <span class="comment">//施加第二个map操作,对list中的每一个future对象执行join操作,一个接一个地等待他们允许结束,join和get方法</span></span><br><span class="line">    <span class="comment">//有相同的含义,不同的在于join不会抛出任何检测到的异常</span></span><br><span class="line">    <span class="keyword">return</span> priceFuture</span><br><span class="line">            .stream()</span><br><span class="line">            .map(CompletableFuture::join)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line">[BestPrice price is <span class="number">187.24</span>, :</span><br><span class="line">LetsSaveBig price is <span class="number">158.26</span>, </span><br><span class="line">MyFavoriteShop price is <span class="number">169.78</span>, </span><br><span class="line">BuyItAll price is <span class="number">170.59</span>]</span><br><span class="line">Done in <span class="number">1061</span> msecs</span><br></pre></td></tr></table></figure><blockquote><p>结果让我们失望了.我们采用异步调用新版方法,和并行差不多</p></blockquote><h1 id="寻找更好的方案"><a href="#寻找更好的方案" class="headerlink" title="寻找更好的方案"></a>寻找更好的方案</h1><blockquote><p>经过我增加商店数量,然后使用三种方式反复的测试,发现了一个问题,并行流和异步调用的性能不分伯仲,究其原因都一样,它们内部采用的是同样的通用线程池,默认都使用固定数目的线程,具体线程数取决于<code>Runtime.getRuntime.availableProcessors()</code>反回值,然而,<code>CompletableFuture</code>具有一定的优势,因为它允许你对执行器进行配置,尤其是线程池的大小,让它以适合应用需求的方式进行配置,满足程序的要求,而这是并行流API无法提供的.</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor executor = Executors.newFixedThreadPool(Math.min(shops.size(), <span class="number">100</span>));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最佳价格查询器(异步调用实现,自定义执行器)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> product 商品</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">asyncFindpricesThread</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">    List&lt;CompletableFuture&lt;String&gt;&gt; priceFuture = shops</span><br><span class="line">            .stream()</span><br><span class="line">            .map(shop -&gt; CompletableFuture.supplyAsync(</span><br><span class="line">() -&gt; shop.getName() + <span class="string">" price is "</span> + shop.getPrice(product), executor))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> priceFuture</span><br><span class="line">            .stream()</span><br><span class="line">            .map(CompletableFuture::join)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>经过测试处理5个商店 是1秒多,处理9个商店也是1秒多</p></blockquote><h1 id="并行–使用流还是CompletableFutures"><a href="#并行–使用流还是CompletableFutures" class="headerlink" title="并行–使用流还是CompletableFutures?"></a>并行–使用流还是CompletableFutures?</h1><blockquote><p>目前为止,我们已经知道对集合进行并行计算有两种方式,要么将其转化为并行流,利用map这样的操作开展工作,要么枚举出集合中的每一个元素,创建新的线程,在CompletableFuture内对其进行操作,后者提供了更多的灵活性,你可以调整线程池大小,二者能帮助你确保整体计算机不会因为线程都在等待I/O而发生阻塞 我们使用这些API的建议如下:</p></blockquote><ol><li>如果你进行的是计算密集型的操作,并且没有I/O,那么推荐使用Stream接口,因为实现简单,同时效率也可能是最高的</li><li>反之,如果你并行的工作单元还涉及等待I/O的操作(包括网络连接等待).那么使用CompletableFuture是灵活性更好,你可以像前面讨论的那样,依据等待/计算,或者W/C的比率设定需要使用的线程数,</li></ol><p><strong><a href="http://www.zeze.info">博主主页</a></strong></p><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java高并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>都在这里!!Java(GC)垃圾收集器和收集算法</title>
      <link href="/java/jvm/j4/"/>
      <url>/java/jvm/j4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol><li>垃圾收集<code>Garbage Collection</code>通常被称为“<code>GC</code>”，它诞生于1960年<code>MIT</code>的<code>Lisp</code>语言，经过半个多世纪，目前已经十分成熟了。</li><li>Jvm中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的</li></ol><h1 id="对象存活的判断"><a href="#对象存活的判断" class="headerlink" title="对象存活的判断"></a>对象存活的判断</h1><p>判断对象是否存活一般有两种方式：</p><ol><li>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</li><li>可达性分析（<code>Reachability Analysis</code>）：从<code>GC Roots</code>开始向下搜索，搜索所走过的路径称为引用链。当一个对象到<code>GC Roots</code>没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</li></ol><p>在Java语言中，GC Roots包括：</p><ul><li>虚拟机栈中引用的对象。</li><li>方法区中类静态属性实体引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI引用的对象。</li></ul><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h2><blockquote><p>“标记-清除“（<code>mark-Sweep</code>）算法，如他的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。</p></blockquote><blockquote><p>它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/java/jvm/20191224180226.png!www.zeze.info" alt="标记清除"></p><h2 id="复制收集算法"><a href="#复制收集算法" class="headerlink" title="复制收集算法"></a>复制收集算法</h2><blockquote><p>复制（<code>Copying</code>）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p></blockquote><blockquote><p>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低。</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/java/jvm/20191224180338.png!www.zeze.info" alt="复制"></p><h2 id="标记-压缩算法"><a href="#标记-压缩算法" class="headerlink" title="标记-压缩算法"></a>标记-压缩算法</h2><blockquote><p>标记-压缩算法复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p></blockquote><blockquote><p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/java/jvm/20191224180723.png!www.zeze.info" alt="标记压缩算法"></p><h2 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h2><blockquote><p>GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。</p></blockquote><blockquote><p>“分代收集”（<code>Generational Collection</code>）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收</p></blockquote><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><blockquote><p>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现</p></blockquote><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><ul><li>串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会<code>Stop The World</code>（服务暂停）</li><li>参数控制：<code>-XX:+UseSerialGC</code>  串行收集器</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/java/jvm/20191224180954.png!www.zeze.info" alt="Serial收集器"></p><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><ul><li>ParNew收集器其实就是<code>Serial</code>收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩</li><li>参数控制：<code>-XX:+UseParNewGC  ParNew</code>收集器</li><li><code>-XX:ParallelGCThreads</code>限制线程数量</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/java/jvm/20191224181046.png!www.zeze.info" alt="ParNew收集器"></p><h2 id="Parallel收集器"><a href="#Parallel收集器" class="headerlink" title="Parallel收集器"></a>Parallel收集器</h2><ul><li><code>Parallel Scavenge</code>收集器类似<code>ParNew</code>收集器，<code>Parallel</code>收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩</li><li>参数控制：<code>-XX:+UseParallelGC</code>  使用<code>Parallel</code>收集器+ 老年代串行</li></ul><h2 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h2><ul><li><code>Parallel Old</code>是<code>Parallel Scavenge</code>收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供</li><li>参数控制：<code>-XX:+UseParallelOldGC</code>使用<code>Parallel</code>收集器+ 老年代并行</li></ul><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><ol><li><code>CMS（Concurrent Mark Sweep）</code>收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</li><li>从名字（包含“<code>Mark Sweep</code>”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：<ul><li>初始标记（CMS initial mark）</li><li>并发标记（CMS concurrent mark）</li><li>重新标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ul></li></ol><blockquote><p>其中初始标记、重新标记这两个步骤仍然需要“<code>Stop The World</code>”。初始标记仅仅只是标记一下<code>GC Roots</code>能直接关联到的对象，速度很快，并发标记阶段就是进行<code>GC Roots Tracing</code>的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 </p></blockquote><blockquote><p>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用<code>ParNew</code>）</p></blockquote><blockquote><p>优点:并发收集、低停顿 <br>缺点：产生大量空间碎片、并发阶段会降低吞吐量</p></blockquote><blockquote><p>参数控制：</p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:+UseConcMarkSweepGC</span>  使用<span class="selector-tag">CMS</span>收集器</span><br><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:+</span> <span class="selector-tag">UseCMSCompactAtFullCollection</span> <span class="selector-tag">Full</span> <span class="selector-tag">GC</span>后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长</span><br><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:+CMSFullGCsBeforeCompaction</span>  设置进行几次<span class="selector-tag">Full</span> <span class="selector-tag">GC</span>后，进行一次碎片整理</span><br><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:ParallelCMSThreads</span>  设定<span class="selector-tag">CMS</span>的线程数量（一般情况约等于可用<span class="selector-tag">CPU</span>数量）</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/java/jvm/20191224181654.png!www.zeze.info" alt="CMS收集器"></p><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><blockquote><p>G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：</p></blockquote><ol><li><p>空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</p></li><li><p>可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p></li></ol><blockquote><p>上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/java/jvm/20191224181908.png!www.zeze.info" alt="G1收集器"></p><p>收集步骤：</p><ol><li>标记阶段，首先初始标记(<code>Initial-Mark</code>),这个阶段是停顿的(<code>Stop the World Event</code>)，并且会触发一次普通<code>Mintor GC</code>。对应<code>GC log:GC pause (young) (inital-mark)</code></li><li><code>Root Region Scanning</code>，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</li><li><code>Concurrent Marking</code>，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/java/jvm/20191224182034.png!www.zeze.info" alt></li><li><code>Remark</code>, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:<code>snapshot-at-the-beginning (SATB)</code>。</li><li><code>Copy/Clean up</code>，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/java/jvm/20191224182151.png!www.zeze.info" alt></li><li>复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/java/jvm/20191224182232.png!www.zeze.info" alt></li></ol><h1 id="常用的收集器组合"><a href="#常用的收集器组合" class="headerlink" title="常用的收集器组合"></a>常用的收集器组合</h1><table><thead><tr><th align="center">————</th><th align="left">新生GC代策略</th><th align="left"><strong>年老代GC策略</strong></th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">组合1</td><td align="left">Serial</td><td align="left">Serial Old</td><td align="left">Serial和Serial Old都是单线程进行GC，特点就是GC时暂停所有应用线程。</td></tr><tr><td align="center">组合2</td><td align="left">Serial</td><td align="left">CMS+Serial Old</td><td align="left">CMS（Concurrent Mark Sweep）是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程。另外，当CMS进行GC失败时，会自动使用Serial Old策略进行GC。</td></tr><tr><td align="center">组合3</td><td align="left">ParNew</td><td align="left">cms</td><td align="left">使用<code>-XX:+UseParNewGC</code>选项来开启。<code>ParNew</code>是<code>Serial</code>的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量。可以使用<code>-XX:ParallelGCThreads</code>选项指定GC的线程数。<br>如果指定了选项<code>-XX:+UseConcMarkSweepGC</code>选项，则新生代默认使用<code>ParNew GC</code>策略。</td></tr><tr><td align="center">组合4</td><td align="left">ParNew</td><td align="left">Serial Old</td><td align="left">使用-XX:+UseParNewGC选项来开启。新生代使用ParNew GC策略，年老代默认使用Serial Old GC策略。</td></tr><tr><td align="center">组合5</td><td align="left">Parallel Scavenge</td><td align="left">Serial Old</td><td align="left">Parallel Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC时间)，可见这会使得CPU的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。</td></tr><tr><td align="center">组合6</td><td align="left">Parallel Scavenge</td><td align="left">Parallel Old</td><td align="left">Parallel Old是Serial Old的并行版本</td></tr><tr><td align="center">组合7</td><td align="left">G1GC</td><td align="left">G1GC</td><td align="left">-XX:+UnlockExperimentalVMOptions -XX:+UseG1GC #开启<br>-XX:MaxGCPauseMillis =50 #暂停时间目标<br>-XX:GCPauseIntervalMillis =200 #暂停间隔目标<br>-XX:+G1YoungGenSize=512m #年轻代大小<br>-XX:SurvivorRatio=6 #幸存区比例</td></tr></tbody></table><h1 id="JDK8版本"><a href="#JDK8版本" class="headerlink" title="JDK8版本"></a>JDK8版本</h1><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/java/jvm/20191224182844.png!www.zeze.info" alt="JDK8"></p><blockquote><p>JDK8中把存放元数据中的永久内存从堆内存中移到了本地内存(native memory)中，这样永久内存就不再占用堆内存，它可以通过自动增长来避免JDK7以及前期版本中常见的永久内存错误(java.lang.OutOfMemoryError: PermGen)。</p></blockquote><blockquote><p>JDK8也提供了一个新的设置Matespace内存大小的参数：<code>-XX:MaxMetaspaceSize=128m</code></p></blockquote><p>注意：如果不设置JVM将会根据一定的策略自动增加本地元内存空间。如果你设置的元内存空间过小，你的应用程序可能得到以下错误：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span>: <span class="selector-tag">Metadata</span> <span class="selector-tag">space</span></span><br></pre></td></tr></table></figure><p><strong>不稳定参数语法规则：</strong>  </p><ol><li>布尔类型参数值<br> <code>-XX:+&lt;option&gt;</code> ‘+’表示启用该选项<br> <code>-XX:-&lt;option&gt;</code> ‘-‘表示关闭该选项  </li><li>数字类型参数值：<br> <code>-XX:&lt;option&gt;=&lt;number&gt;</code>给选项设置一个数字类型值，可跟随单位，例如：’m’或’M’表示兆字节;’k’或’K’千字节;’g’或’G’千兆字节。32K与32768是相同大小的。  </li><li>字符串类型参数值：<br> <code>-XX:&lt;option&gt;=&lt;string&gt;</code>给选项设置一个字符串类型值，通常用于指定一个文件、路径或一系列命令列表。例如：<code>-XX:HeapDumpPath=./dump.core</code></li></ol><p><strong><a href="http://www.zeze.info">博主主页</a></strong></p><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>有助于提高“锁”性能的几点建议</title>
      <link href="/java/jvm/j3/"/>
      <url>/java/jvm/j3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="有助于提高”锁”性能的几点建议"><a href="#有助于提高”锁”性能的几点建议" class="headerlink" title="有助于提高”锁”性能的几点建议"></a>有助于提高”锁”性能的几点建议</h1><blockquote><p>最近阅读《java高并发编程一书》大概总结几条，也是书中的内容</p></blockquote><h1 id="减小锁持有的时间"><a href="#减小锁持有的时间" class="headerlink" title="减小锁持有的时间"></a>减小锁持有的时间</h1><blockquote><p>比如100个人去银行办理业务，要填一百张表，但是只有一支笔，那么很显然，每个人用笔的时间越短，效率也就月高：看代码：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">othercode1和othercode2很耗时间,里面没有涉及资源同步,只有mutexMethod方法要对资源同步,</span></span><br><span class="line"><span class="comment">所有优化代码让持有锁时间尽量短</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        othercode1();</span><br><span class="line">        mutexMethod();</span><br><span class="line">        othercode2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        othercode1();</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">            mutexMethod();</span><br><span class="line">        &#125;</span><br><span class="line">        othercode2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在jdk源码里面也很容易找到这种手段,比如处理正则表达式的Pattern类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Matcher <span class="title">matcher</span><span class="params">(CharSequence input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!compiled) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compiled)</span><br><span class="line">                    compile();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Matcher m = <span class="keyword">new</span> Matcher(<span class="keyword">this</span>, input);</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只有在表达式未编译的时候进行局部加锁,这种方法大大提高了matcher的执行效率和可靠性</span></span><br></pre></td></tr></table></figure><p>注意:<code>减少锁的持有时间有助于降低锁冲突的可能性,进而提升系统的并发能力</code></p><h1 id="减小锁的力度"><a href="#减小锁的力度" class="headerlink" title="减小锁的力度"></a>减小锁的力度</h1><blockquote><p><code>concurrentHashMap</code>的实现,他的内部被分为了若干个小的<code>hashmap</code>,称之为段(<code>SEGMENT</code>),默认是16段</p></blockquote><blockquote><p>减小锁粒度会引入一个新的问题,当需要获取全局锁的时候,其消耗的资源会较多,不如<code>concurrenthashMap</code>的<code>size()</code>方法.可以看到计算size的时候需要计算全部有效的段的锁</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>事实上计算size的时候会先使用无锁的方式计算,如果失败会采用这个方法,但是在高并发的场合<code>concurrenthashmap</code>的<code>size</code>依然要差于同步的<code>hashmap</code>.因此在类似于<code>size</code>获取全局信息方法调用不频繁的情况下,这种减小粒度的的方法才是真正意义上的提高系统并发量</p></blockquote><p>注意:<code>所谓减小锁粒度,就是指缩小锁定对象的范围,从而减小锁冲突的可能性,进而提高系统性能</code></p><h1 id="读写分离来替换独占锁"><a href="#读写分离来替换独占锁" class="headerlink" title="读写分离来替换独占锁"></a>读写分离来替换独占锁</h1><blockquote><p>在读多写少的情况下,使用读写锁可以有效的提高系统性能<code>ReadWriteLock</code>可以提高系统性能</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.high.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: www.zeze.info</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 8:43 2018/4/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock readLock =readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock writeLock = readWriteLock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handleRead</span><span class="params">(Lock lock)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(Lock lock,<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            value =index;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReadWriteLockDemo demo = <span class="keyword">new</span> ReadWriteLockDemo();</span><br><span class="line">        Runnable readRunnale = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    demo.handleRead(lock);</span><br><span class="line">                    <span class="comment">//demo.handleRead(readLock);</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable write = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//demo.handleWrite(writeLock,new Random().nextInt());</span></span><br><span class="line">                    demo.handleWrite(lock,<span class="keyword">new</span> Random().nextInt());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">18</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(readRunnale).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">18</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(write).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h1><blockquote><p>以<code>LinkedBlockingQueue</code>为例,<code>take</code>函数和<code>put</code>函数分别实现了从队列取和往队列加数据，虽然两个方法都对队列进项了修改，但是<code>LinkedBlockingQueue</code>是基于链表的所以一个操作的是头，一个是队列尾端，从理论情况下将并不冲突</p></blockquote><blockquote><p>如果使用独占锁则<code>take</code>和<code>put</code>就不能完成真正的并发，所以jdk并没有才用这种方式取而代之的是两把不同的锁分离了put和take的操作，下面看源码</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();<span class="comment">//take函数需要持有takeLock</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();<span class="comment">//put函数需要持有putLock</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        E x;</span><br><span class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">        takeLock.lockInterruptibly(); <span class="comment">//不能有两个线程同时取数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123; <span class="comment">//如果当前没有可用数据,一直等待</span></span><br><span class="line">                notEmpty.await();      <span class="comment">//等待,put操作的通知</span></span><br><span class="line">            &#125;</span><br><span class="line">            x = dequeue();         <span class="comment">//取得第一个数据</span></span><br><span class="line">            c = count.getAndDecrement();<span class="comment">//数量减一,原子操作因为回合put同时访问count.注意变量c是count减一</span></span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();  <span class="comment">//通知其他take操作</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock(); <span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == capacity)</span><br><span class="line">            signalNotFull(); <span class="comment">//通知put,已有空余空间</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></span><br><span class="line">        <span class="comment">// holding count negative to indicate failure unless set.</span></span><br><span class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        putLock.lockInterruptibly();<span class="comment">//不能有两个线程同时进行put</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Note that count is used in wait guard even though it is</span></span><br><span class="line"><span class="comment">             * not protected by lock. This works because count can</span></span><br><span class="line"><span class="comment">             * only decrease at this point (all other puts are shut</span></span><br><span class="line"><span class="comment">             * out by lock), and we (or some other waiting put) are</span></span><br><span class="line"><span class="comment">             * signalled if it ever changes from capacity. Similarly</span></span><br><span class="line"><span class="comment">             * for all other uses of count in other wait guards.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">while</span> (count.get() == capacity) &#123; <span class="comment">//如果队列已满</span></span><br><span class="line">                notFull.await();   <span class="comment">//等待</span></span><br><span class="line">            &#125;</span><br><span class="line">            enqueue(node);  <span class="comment">//插入数据</span></span><br><span class="line">            c = count.getAndIncrement(); <span class="comment">//更新总数,变量c是count加1前的值</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                notFull.signal();   <span class="comment">//有足够的空间,通知其他线程</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            putLock.unlock();  <span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            signalNotEmpty();  <span class="comment">//插入成功后,通知take操作</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h1><blockquote><p>虚拟机在遇到一连串地对同一锁不断进行请求和释放的操作时,便会把所有的锁操作整合成对锁的一次请求,从而减小对锁的请求同步次数,这个操作叫锁粗话,比如</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:<code>性能优化就是根据运行时的真实情况对各个资源点进行权衡折中的过程,锁粗话的思想和减少锁持有时间是相反的,但是在不同的场合,他们的效果并不相同,所以大家要根据实际情况,进行权衡</code></p><h1 id="java虚拟机对锁优化所做的努力"><a href="#java虚拟机对锁优化所做的努力" class="headerlink" title="java虚拟机对锁优化所做的努力"></a>java虚拟机对锁优化所做的努力</h1><h2 id="锁偏向"><a href="#锁偏向" class="headerlink" title="锁偏向"></a>锁偏向</h2><blockquote><p>偏向锁，简单的讲，就是在锁对象的对象头中有个<code>ThreaddId</code>字段，这个字段如果是空的，第一次获取锁的时候，就将自身的<code>ThreadId</code>写入到锁的<code>ThreadId</code>字段内，将锁头内的是否偏向锁的状态位置1.这样下次获取锁的时候，直接检查<code>ThreadId</code>是否和自身线程<code>Id</code>一致，如果一致，则认为当前线程已经获取了锁，因此不需再次获取锁，略过了轻量级锁和重量级锁的加锁阶段。提高了效率。</p></blockquote><blockquote><p>但是偏向锁也有一个问题，就是当锁有竞争关系的时候，需要解除偏向锁，使锁进入竞争的状态</p></blockquote><blockquote><p>参数<code>-XX:+UseBiasedLocking</code></p></blockquote><blockquote><p><code>Java</code>偏向锁(<code>Biased Locking</code>)是<code>Java6</code>引入的一项多线程优化。它通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会尝试消除它身上的偏向锁，将锁恢复到标准的轻量级锁。(偏向锁只能在单线程下起作用)因此 流程是这样的 <code>偏向锁</code>-&gt;<code>轻量级锁</code>-&gt;<code>重量级锁</code></p></blockquote><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><blockquote><p>轻量级锁加锁：线程在执行同步块之前，<code>JVM</code>会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的<code>Mark Word</code>复制到锁记录中，官方称为<code>Displaced Mark Word</code>。</p></blockquote><blockquote><p>然后线程尝试使用<code>CAS</code>将对象头中的<code>Mark Word</code>替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p></blockquote><blockquote><p>轻量级锁解锁：轻量级解锁时，会使用原子的<code>CAS</code>操作来将<code>Displaced Mark Word</code>替换回到对象头，如果成功，则表示没有竞争发生。</p></blockquote><blockquote><p>如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p></blockquote><p>注：<code>轻量级锁会一直保持，唤醒总是发生在轻量级锁解锁的时候，因为加锁的时候已经成功CAS操作；而CAS失败的线程，会立即锁膨胀，并阻塞等待唤醒。</code>（详见下图）</p><p>下图是两个线程同时争夺锁，导致锁膨胀的流程图。<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/java/jvm/2a.png!www.zeze.info" alt="轻量级锁会"><br>锁不会降级</p><blockquote><p>自旋其实就是虚拟机为了避免线程真实的在操作系统层挂起,虚拟机让当前线程做空轮询或许是几个cpu时间周期,如果还没办法获取锁则在挂起.</p></blockquote><blockquote><p>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。</p></blockquote><blockquote><p>当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p></blockquote><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><blockquote><p>锁消除是Java虚拟机在JIT编译是，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过锁消除，可以节省毫无意义的请求锁时间</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLockEliminate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(s1);</span><br><span class="line">        sb.append(s2);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> tsStart = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            getString(<span class="string">"TestLockEliminate "</span>, <span class="string">"Suffix"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"一共耗费："</span> + (System.currentTimeMillis() - tsStart) + <span class="string">" ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>getString()</code>方法中的<code>StringBuffer</code>数以函数内部的局部变量，进作用于方法内部，不可能逃逸出该方法，因此他就不可能被多个线程同时访问，也就没有资源的竞争，但是<code>StringBuffer</code>的<code>append</code>操作却需要执行同步操作:</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        toStringCache = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">super</span>.append(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>逃逸分析和锁消除分别可以使用参数<code>-XX:+DoEscapeAnalysis</code>和<code>-XX:+EliminateLocks</code>(锁消除必须在-server模式下)开启。使用如下参数运行上面的程序：</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/java/jvm/10095500_qzEz.jpg!www.zeze.info" alt></p><p>使用如下命令运行程序：<code>-XX:+DoEscapeAnalysis -XX:+EliminateLocks</code></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/java/jvm/10095500_eji9.jpg!www.zeze.info" alt></p><h2 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h2><table><thead><tr><th align="center">锁</th><th align="left">优点</th><th align="left">缺点</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="center">偏向锁</td><td align="left">加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td align="left">如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td align="left">适用于只有一个线程访问同步块场景。</td></tr><tr><td align="center">轻量级锁</td><td align="left">竞争的线程不会阻塞，提高了程序的响应速度。如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td align="left">追求响应时间。<br>同步块执行速度非常快。</td><td align="left"></td></tr><tr><td align="center">重量级锁</td><td align="left">线程竞争不使用自旋，不会消耗CPU。</td><td align="left">线程阻塞，响应时间缓慢。</td><td align="left">追求吞吐量。<br>同步块执行速度较长。</td></tr></tbody></table><p>👍 👍 👍</p><p>👍<strong><a href="http://www.zeze.info">博主主页</a></strong>👍</p><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>经常被问到Java虚拟机调优,看完这篇不足200字的文章能帮到你</title>
      <link href="/java/jvm/j2/"/>
      <url>/java/jvm/j2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JVM大体结构"><a href="#JVM大体结构" class="headerlink" title="JVM大体结构"></a>JVM大体结构</h1><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/java/jvm/1.jpg!www.zeze.info" alt="JVM大体结构"></p><blockquote><p>class 文件 加载-验证-准备-解析-初始化-使用-卸载 一个线程一个栈，一个方法一个栈帧</p></blockquote><h1 id="如何确定垃圾"><a href="#如何确定垃圾" class="headerlink" title="如何确定垃圾"></a>如何确定垃圾</h1><ul><li>引用计数<ul><li>会有循环引用的问题</li></ul></li><li>正向可达<ul><li>从roots对象计数可以达到的对象</li></ul></li></ul><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><blockquote><p>详情<a href="http://www.zeze.info/java/jvm/j4/#垃圾收集算法">这里有最详细的GC算法</a></p></blockquote><ul><li>标记清除（缺点：内存碎片化，没有连续的内存）</li><li>Copying (缺点：浪费内存 一般用在新生代<code>new</code>)</li><li>标记压缩 (比copying慢一点 一般用在老年代<code>tenured</code>)</li><li>new<ul><li>存活对象少</li><li>使用copying,占用的内存空间也不大，效率也高</li></ul></li><li>old<ul><li>垃圾少</li><li>一般使用mark-compact</li></ul></li></ul><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><blockquote><p>详情<a href="http://www.zeze.info/java/jvm/j4/#垃圾收集器">这里有最详细的垃圾收集器</a></p></blockquote><ul><li>Serial Collector<ul><li>XX:+UseSerialGC</li><li>单线程</li></ul></li><li>Parallel Collector<ul><li>并行量大，不过每次垃圾收集，JVM会停顿</li><li>CMS Collector</li><li>并发分区来完成，停顿时间短</li></ul></li><li>G1<ul><li>不仅停顿短，同事并发大。仅仅是个平衡点</li><li>有人说建议Java9用这个</li></ul></li></ul><h1 id="JVM-参数"><a href="#JVM-参数" class="headerlink" title="JVM 参数"></a>JVM 参数</h1><ul><li><code>-</code>标准参数，所有jvm 都应该支持</li><li><code>-X</code>非标，每一个jvm实现都不同</li><li><code>-XX</code>不稳定参数，下一个版本可能会取消</li></ul><h1 id="java-对象的分配"><a href="#java-对象的分配" class="headerlink" title="java 对象的分配"></a>java 对象的分配</h1><blockquote><p>不开<a href="http://www.zeze.info/java/jvm/j3/#锁消除">逃逸分析</a>不会先分配在栈上</p></blockquote><ul><li><p>栈上分配</p><ul><li>线程私有小对象</li><li>无逃逸（-XX:+DoEscapeAnalysis开启逃逸分析 默认是开启的）</li><li>支持标量替换<br>优化方案：<code>无需调整</code></li></ul></li><li><p>线程本地分配TLAB（Thread Locla Allacation Buffer）在堆上也是eden区，这样做的目的是有一部分数据可以不加锁</p><ul><li>占用eden,默认1%</li><li>多线程的时候不用竞争eden就可以申请空间，提高效率</li><li>小对象<br>优化方案：<code>无需调整</code></li></ul></li><li><p>老年代</p><ul><li>大对象</li></ul></li><li><p>eden</p></li><li><p>堆:</p><ul><li><code>-XX:HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=tmp/jvm.dump -XX:PrintGCDetails</code></li><li><code>-Xms10M -Xmx10M</code>直接调大最大，避免中途分析和垃圾回收的计算</li></ul></li><li><p>栈 +Xss128k<br>优化方案：<br>调大：线程递归调用可以很深<br>调小：线程并发数量可以特别多</p></li></ul><p><strong><a href="http://www.zeze.info">博主主页</a></strong></p><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题,看了这篇你还不懂JVM 中的类加载机制？</title>
      <link href="/java/jvm/j1/"/>
      <url>/java/jvm/j1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="开门见山"><a href="#开门见山" class="headerlink" title="开门见山"></a>开门见山</h1><blockquote><p>首先引入一道面试题</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single single = <span class="keyword">new</span> Single();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count1++;</span><br><span class="line">        count2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Single single = Single.getInstance();</span><br><span class="line">        System.out.println(<span class="string">"count1="</span> + single.count1);</span><br><span class="line">        System.out.println(<span class="string">"count2="</span> + single.count2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>错误答案：<code>count1=1;count2=1</code><br>正确答案：<code>count1=1;count2=0</code></p></blockquote><p>为神马？为神马？这要从java的类加载时机说起。</p><p><strong>本来是准备把分析结果写在最下面的但是怕大家没有耐心看到最后.我这边先大概分析下，如果看不懂下面的分析。建议大家能看到最后，文章不算长。</strong></p><ol><li><code>Single single = Single.getInstance();</code>调用了类的<code>Single</code>调用了类的静态方法，触发类的初始化</li><li>类加载的时候在准备过程中为类的静态变量分配内存并初始化默认值 <code>single=null count1=0,count2=0</code></li><li>类初始化化，为类的静态变量赋值和执行静态代码快。<code>single</code>赋值为<code>new Single()</code>调用类的构造方法</li><li>调用类的构造方法后<code>count=1;count2=1</code></li><li>继续为<code>count1</code>与<code>count2</code>赋值,此时<code>count1</code>没有赋值操作,所有<code>count1</code>为1,但是<code>count2</code>执行赋值操作就变为0</li></ol><h1 id="类的加载时机"><a href="#类的加载时机" class="headerlink" title="类的加载时机"></a>类的加载时机</h1><blockquote><p>类从被加载到虚拟机内存中开始，直到卸载出内存为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）。</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/java/jvm/1.png!www.zeze.info" alt="类的加载"></p><blockquote><p>其中加载、验证、准备、初始化和卸载五个步骤的顺序都是确定的，解析阶段在某些情况下有可能发生在初始化之后，这是为了支持 Java 语言的运行期绑定的特性。</p></blockquote><h1 id="何时开始类的初始化"><a href="#何时开始类的初始化" class="headerlink" title="何时开始类的初始化"></a>何时开始类的初始化</h1><blockquote><p>什么情况下需要开始类加载过程的第一个阶段:”加载”。虚拟机规范中并没强行约束，这点可以交给虚拟机的的具体实现自由把握，但是对于初始化阶段虚拟机规范是严格规定了如下几种情况，如果类未初始化会对类进行初始化。</p></blockquote><ol><li><strong>创建类的实例</strong></li><li><strong>访问类的静态变量(除常量【被final修辞的静态变量】原因:常量一种特殊的变量，因为编译器把他们当作值(value)而不是域(field)来对待。如果你的代码中用到了常变量(<code>constant variable</code>)，编译器并不会生成字节码来从对象中载入域的值，而是直接把这个值插入到字节码中。这是一种很有用的优化，但是如果你需要改变final域的值那么每一块用到那个域的代码都需要重新编译。</strong></li><li><strong>访问类的静态方法</strong></li><li><strong>反射如(<code>Class.forName(&quot;my.xyz.Test&quot;)</code>)</strong></li><li><strong>当初始化一个类时，发现其父类还未初始化，则先出发父类的初始化</strong></li><li><strong>虚拟机启动时，定义了main()方法的那个类先初始化</strong></li></ol><ul><li>主动引用：<strong>上面这些种行为称为对一个类的的主动引用，会触发类的初始化</strong></li><li>被动引用：<strong>除上面五种主动引用之外，其他引用类的方式都不会触发类的初始化，称为类的被动引用</strong></li></ul><blockquote><p>接口的加载过程与类的加载过程稍有不同。接口中不能使用<code>static{}</code>块。当一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有真正在使用到父接口时（例如引用接口中定义的常量）才会初始化。</p></blockquote><h1 id="被动引用例子"><a href="#被动引用例子" class="headerlink" title="被动引用例子"></a>被动引用例子</h1><h2 id="被动引用示例一"><a href="#被动引用示例一" class="headerlink" title="被动引用示例一"></a>被动引用示例一</h2><p><strong>对于静态字段，只有直接定义这个字段的类会被初始化，如果是通过子类引用父类的字段，父类会被初始化，子类不一定会被初始化，子类会不会被初始化 JVM 虚拟机规范并没有明确规定，取决于虚拟机的具体实现</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"The value is "</span> + Subclass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码运行之后输出结果如下所示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SuperClass init!</span><br><span class="line">The value is <span class="number">24</span></span><br></pre></td></tr></table></figure><h2 id="被动引用示例二"><a href="#被动引用示例二" class="headerlink" title="被动引用示例二"></a>被动引用示例二</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SubClass[] subClassArray = <span class="keyword">new</span> SubClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码运行之后，并不会输出 “<code>SubClass init!</code>“，因为在上面<code>Demo#main()</code>方法中，并没有初始化<code>SubClass</code>类，而是初始化了一个<code>SubClass[]</code>数组类，<code>SubClass[]</code>数组类代表了一个元素类型为<code>SubClass</code>的一维数组，继承自<code>Object</code>类，由<code>newarray</code>字节码创建。</p><h3 id="被动引用示例三"><a href="#被动引用示例三" class="headerlink" title="被动引用示例三"></a>被动引用示例三</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constant</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Constant init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String VALUE = <span class="string">"Hello World!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(Constant.VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码运行之后也并不会输出”<code>Constant init!</code>“，因为这涉及到一个概念 —- “常量传播优化”。虽然在代码中<code>Demo</code>类引用了<code>Constant</code>类中的常量<code>VALUE</code>，但是在编译阶段，会将<code>VALUE</code>的实际值”<code>Hello World!</code>“放到<code>Demo</code>类中的常量池中，<code>Demo</code>类每次使用”<code>Hello World!</code>“常量的时候都会从自己的常量池中去找。<code>Demo</code>类不会持有<code>Constant</code>类的符号引用，所以<code>Constant</code>类也并不会被初始化。</p><h1 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h1><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>在加载阶段有三个步骤：</p><ol><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>将二进制字节流所代表的静态存储结构转换为方法区中的运行时数据结构</li><li>在内存中生成一个代表此类的<code>java.lang.Class</code>的对象，作为方法区这些数据的访问入口<br>在这个阶段，有两点需要注意：</li><li>并没有规定从哪里获取二进制字节流。我们可以从<code>.class</code>静态存储文件中获取，也可以从<code>zip、jar</code>等包中读取，可以从数据库中读取，也可以从网络中获取，甚至我们自己可以在运行时自动生成。</li><li>在内存中实例化一个代表此类的<code>java.lang.Class</code>对象之后，并没有规定此<code>Class</code>对象是方法<code>Java</code>堆中的，有些虚拟机就会将<code>Class</code>对象放到方法区中，比如<code>HotSpot</code>。</li></ol><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一个步骤，验证的目的是为了确保<code>.class</code>文件中的字节流所包含的信息是符合当前虚拟机的要求，并且不会危害到虚拟机自身的安全的。</p><blockquote><p><code>Java</code>语言本身是相对安全的语言，使用Java编码是无法做到如访问数组边界以外的数据、将一个对象转型为它并未实现的类型等，如果这样做了，编译器将拒绝编译。但是，<code>Class</code>文件并不一定是由<code>Java</code>源码编译而来，可以使用任何途径，包括用十六进制编辑器(如<code>UltraEdit</code>)直接编写。如果直接编写了有害的“代码”(字节流)，而虚拟机在加载该Class时不进行检查的话，就有可能危害到虚拟机或程序的安全。</p></blockquote><p>不同的虚拟机，对类验证的实现可能有所不同，但大致都会完成下面四个阶段的验证：文件格式验证、元数据验证、字节码验证和符号引用验证。</p><ol><li>文件格式验证，是要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。如验证魔数是否0xCAFEBABE；主、次版本号是否正在当前虚拟机处理范围之内；常量池的常量中是否有不被支持的常量类型……该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区中，经过这个阶段的验证后，字节流才会进入内存的方法区中存储，所以后面的三个验证阶段都是基于方法区的存储结构进行的。</li><li>元数据验证，是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。可能包括的验证如：这个类是否有父类；这个类的父类是否继承了不允许被继承的类；如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法……</li><li>字节码验证，主要工作是进行数据流和控制流分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。</li><li>符号引用验证，发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在“解析阶段”中发生。验证符号引用中通过字符串描述的权限定名是否能找到对应的类；在指定类中是否存在符合方法字段的描述符及简单名称所描述的方法和字段；符号引用中的类、字段和方法的访问性(<code>private、protected、public、default</code>)是否可被当前类访问</li></ol><p>验证阶段对于虚拟机的类加载机制来说，不一定是必要的阶段。如果所运行的全部代码确认是安全的，可以使用<code>-Xverify：none</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载时间。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p><p>有几点需要注意：</p><ol><li>在方法区中分配内存的只有类变量（被<code>static</code>修饰的变量），而不包括实例变量，实例变量将会跟随着对象在 Java 堆中为其分配内存</li><li>初始化类变量的时候，是将类变量初始化为其类型对应的<code>0</code>值，比如有如下类变量，在准备阶段完成之后<code>val</code>的值是<code>0</code>而不是 <code>123</code>，为 <code>val</code>复制为<code>123</code>，是在后面要讲的初始化阶段之后<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> val=<span class="number">123</span>;<span class="comment">//在准备阶段value初始值为0 。在初始化阶段才会变为123 。</span></span><br></pre></td></tr></table></figure></li><li>对于常量，其对应的值会在编译阶段就存储在字段表的<code>ConstantValue</code>属性当中，所以在准备阶段结束之后，常量的值就是<code>ConstantValue</code>所指定的值了，比如如下，在准备阶段结束之后，<code>val</code>的值就是<code>123</code>了。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> val = <span class="number">123</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。<br>符号引用（Symbolic Reference）：<strong>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</strong><br>直接引用（Direct Reference）：<strong>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，如果有了直接引用，那么引用的目标必定已经在内存中存在。</strong></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>类的初始化阶段才是真正开始执行类中定义的 Java 程序代码。初始化说白了就是调用类构造器<code>&lt;clinit&gt;()</code>的过程，在类的构造器中会为类变量初始化定义的值，会执行静态代码块中的内容。下面将介绍几点和开发者关系较为紧密的注意点</p><ol><li>类构造器<code>&lt;clinit&gt;()</code>是由编译器自动收集类中出现的类变量、静态代码块中的语句合并产生的，收集的顺序是在源文件中出现的顺序决定的，静态代码块可以访问出现在静态代码块之前的类变量，出现的静态代码块之后的类变量，只可以赋值，但是不能访问，比如如下代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String before = <span class="string">"before"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">            after = <span class="string">"after"</span>;                    <span class="comment">// 赋值合法</span></span><br><span class="line">            System.out.println(before);         <span class="comment">// 访问合法，因为出现在 static&#123;&#125; 之前</span></span><br><span class="line">            System.out.println(after);          <span class="comment">// 访问不合法，因为出现在 static&#123;&#125; 之后</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String after;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>&lt;clinit&gt;()</code>类构造器和<code>&lt;init&gt;()</code>实例构造器不同，类构造器不需要显示的父类的类构造，在子类的类构造器调用之前，会自动的调用父类的类构造器。因此虚拟机中第一个被调用的<code>&lt;clinit&gt;()</code>方法是 <code>java.lang.Object</code>的类构造器</li><li>由于父类的类构造器优先于子类的类构造器执行，所以父类中的<code>static{}</code>代码块也优先于子类的<code>static{}</code>执行</li><li>类构造器<code>&lt;clinit&gt;()</code>对于类来说并不是必需的，如果一个类中没有类变量，也没有<code>static{}</code>，那这个类不会有类构造器<code>&lt;clinit&gt;()</code></li><li>接口中不能有<code>static{}</code>，但是接口中也可以有类变量，所以接口中也可以有类构造器 <code>&lt;clinit&gt;{}</code>，但是接口的类构造器和类的类构造器有所不同，接口在调用类构造器的时候，如果不需要，不用调用父接口的类构造器，除非用到了父接口中的类变量，接口的实现类在初始化的时候也不会调用接口的类构造器</li><li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的类构造器<code>&lt;clinit&gt;()</code>，其他线程会被阻塞，直到活动线程执行完类构造器<code>&lt;clinit&gt;()</code>方法</li></ol><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>看到这里不容易了，大家应该都理解类加载的流程了吧，希望以后遇到这样的面试题能想起这篇文章</p><p><strong><a href="http://www.zeze.info">博主主页</a></strong></p><p><strong>可以加博主微信一起交流：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin"></strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 原型总结六 继承</title>
      <link href="/javaScript/oop/o6/"/>
      <url>/javaScript/oop/o6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="为何用“继承”为标题，而不用“原型链”？"><a href="#为何用“继承”为标题，而不用“原型链”？" class="headerlink" title="为何用“继承”为标题，而不用“原型链”？"></a>为何用“继承”为标题，而不用“原型链”？</h1><blockquote><p>原型链如果解释清楚了很容易理解，不会与常用的java/C#产生混淆。而“继承”确实常用面向对象语言中最基本的概念，但是java中的继承与javascript中的继承又完全是两回事儿。因此，这里把“继承”着重拿出来，就为了体现这个不同。</p></blockquote><blockquote><p>javascript中的继承是通过原型链来体现的。先看几句代码</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</span><br><span class="line">f1.a = <span class="number">10</span>;</span><br><span class="line">Foo.prototype.a = <span class="number">100</span>;</span><br><span class="line">Foo.prototype.b = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">console</span>.info(f1.a)</span><br><span class="line"><span class="built_in">console</span>.info(f2.a)</span><br></pre></td></tr></table></figure><blockquote><p>以上代码中，f1是Foo函数new出来的对象，f1.a是f1对象的基本属性，f1.b是怎么来的呢？——从Foo.prototype得来，因为f1.<strong>proto</strong>指向的是Foo.prototype</p></blockquote><p><strong>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着<strong>proto</strong>这条链向上找，这就是原型链。</strong></p><p>看图说话：<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/js/oop/20191219173658.png!www.zeze.info" alt="继承"></p><blockquote><p>上图中，访问f1.b时，f1的基本属性中没有b，于是沿着<strong>proto</strong>找到了Foo.prototype.b。那么我们在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢？大家可能都知道答案了——hasOwnProperty，特别是在for…in…循环中，一定要注意。</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/js/oop/20191219173758.png!www.zeze.info" alt="继承"></p><blockquote><p>等等，不对！ f1的这个hasOwnProperty方法是从哪里来的？ f1本身没有，Foo.prototype中也没有，哪儿来的？</p></blockquote><blockquote><p>它是从Object.prototype中来的，请看图：</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/js/oop/20191219173829.png!www.zeze.info" alt="继承"></p><blockquote><p>对象的原型链是沿着<strong>proto</strong>这条线走的，因此在查找f1.hasOwnProperty属性时，就会顺着原型链一直查找到Object.prototype。</p></blockquote><blockquote><p>说一个函数的例子吧。<br>我们都知道每个函数都有call，apply方法，都有length，arguments，caller等属性。为什么每个函数都有？这肯定是“继承”的。函数由Function函数创建，因此继承的Function.prototype中的方法。不信可以请webstrom老师给我们验证一下：</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/js/oop/20191219173946.png!www.zeze.info" alt></p><blockquote><p>看到了吧，有call、length等这些属性。那怎么还有hasOwnProperty呢？——那是Function.prototype继承自Object.prototype的方法。有疑问可以看看上一节将instanceof时候那个大图，看看Function.prototype.<strong>proto</strong>是否指向Object.prototype。原型、原型链，大家都明白了吗？可以关注我的微信订阅号</p></blockquote><p><strong>有疑问或者商业合作可以加博主微信：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin">。一起交流</strong></p>]]></content>
      
      
      <categories>
          
          <category> js面向对象基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> js面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 原型总结五 Instanceof</title>
      <link href="/javaScript/oop/o5/"/>
      <url>/javaScript/oop/o5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><blockquote><p>对于值类型，你可以通过typeof判断，string/number/boolean都很清楚，但是typeof在判断到引用类型的时候，返回值只有object/function，你不知道它到底是一个object对象，还是数组，还是new Number等等。这个时候就需要用到instanceof。例如：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f1=<span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.info(f1 <span class="keyword">instanceof</span> Foo);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.info(f1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//f1这个对象是被Foo创建，但是“f1 instanceof Object”为什么是true呢</span></span><br></pre></td></tr></table></figure><blockquote><p>至于为什么过会儿再说，先把instanceof判断的规则告诉大家。根据以上代码看下图：</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/js/oop/20191219172826.png!www.zeze.info" alt="js原型"></p><blockquote><p>Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B.Instanceof的判断队则是：沿着A的<strong>proto</strong>这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false</p></blockquote><blockquote><p>按照以上规则，大家看看“ f1 instanceof Object ”这句代码是不是true？ 根据上图很容易就能看出来，就是true。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.info(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.info(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.info(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><blockquote><p>这里也接上了咱们上一节说的“乱”</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/js/oop/20191219173059.png!www.zeze.info" alt="js"></p><blockquote><p>看这个图片，千万不要嫌烦，必须一条线一条线挨着分析。如果上一节你看的比较仔细，再结合刚才咱们介绍的instanceof的概念，相信能看懂这个图片的内容。看看这个图片，你也就知道为何上面三个看似混乱的语句返回的是true了。问题又出来了。Instanceof这样设计，到底有什么用？到底instanceof想表达什么呢？<code>重点就这样被这位老朋友给引出来了——继承——原型链instanceof表示的就是一种继承关系，或者原型链的结构</code></p></blockquote><p>请看下一节<a href="http://www.zeze.info/javaScript/oop/o6/">&lt;JavaScript 原型总结六 继承&gt;</a></p><p><strong>有疑问或者商业合作可以加博主微信：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin">。一起交流</strong></p>]]></content>
      
      
      <categories>
          
          <category> js面向对象基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> js面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 原型总结四 隐式原型</title>
      <link href="/javaScript/oop/o4/"/>
      <url>/javaScript/oop/o4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="隐式原型"><a href="#隐式原型" class="headerlink" title="隐式原型"></a>隐式原型</h1><blockquote><p>上节已经提到，每个函数function都有一个prototype，即原型。这里再加一句话——每个对象都有一个<strong>proto</strong>，可成为隐式原型。</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/js/oop/20191219171632.png!www.zeze.info" alt="prototype"></p><p><strong>obj这个对象本质上是被Object函数创建的，因此obj.<strong>proto</strong>=== Object.prototype。我们可以用一个图来表示。</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/js/oop/20191219171748.png!www.zeze.info" alt="prototype"></p><p><strong>每个对象都有一个_proto_属性,像该构造函数的prototype</strong></p><p>在说明“Object prototype”之前，先说一下自定义函数的prototype。自定义函数的prototype本质上就是和 <code>var obj = {}</code> 是一样的，都是被Object创建，所以它的<code>__proto__</code>指向的就是<code>Object.prototype</code>。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/js/oop/20191219172046.png!www.zeze.info" alt="prototype"></p><p>函数也是一种对象，函数也有<strong>proto</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.info(fn(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"x"</span>,<span class="string">"y"</span>,<span class="string">"return x+y;"</span>);</span><br><span class="line"><span class="built_in">console</span>.info(fn1(<span class="number">5</span>,<span class="number">6</span>));</span><br></pre></td></tr></table></figure><p>以上代码中，第一种方式是比较传统的函数创建方式，地二种是用<code>new Function</code>创建。首先根本不推荐用第二种方式。这里只是像大家演示，函数是被Function创建的。</p><ol><li>根据上面说的一句话——对象的<strong>proto</strong>指向的是创建它的函数的prototype，就会出现：Object.<strong>proto</strong> === Function.prototype</li><li>Function也是一个函数，函数是一种对象，也有<strong>proto</strong>属性。既然是函数，那么它一定是被Function创建。所以——Function是被自身创建的。所以它的<strong>proto</strong>指向了自身的Prototype</li><li>Function.prototype指向的对象也是一个普通的被Object创建的对象，所以也遵循基本的规则,是一个环形结构</li></ol><p>下一节<a href="http://www.zeze.info/javaScript/oop/o5/">&lt;原JavaScript 原型总结五 instanceof&gt;</a></p><p><strong>有疑问或者商业合作可以加博主微信：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin">。一起交流</strong></p>]]></content>
      
      
      <categories>
          
          <category> js面向对象基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> js面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 原型总结三 函数和对象的关系</title>
      <link href="/javaScript/oop/o3/"/>
      <url>/javaScript/oop/o3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="既typeof之后的另一位老朋友！"><a href="#既typeof之后的另一位老朋友！" class="headerlink" title="既typeof之后的另一位老朋友！"></a>既typeof之后的另一位老朋友！</h1><blockquote><p>在咱们的上一节<a href="http://www.zeze.info/javaScript/oop/o2/">JavaScript 原型总结二 一切皆对象之typeof</a>中说道，函数也是一种对象。他也是属性的集合，你也可以对函数进行自定义属性。</p></blockquote><blockquote><p>不用等咱们去试验，javascript自己就先做了表率，人家就默认的给函数一个属性——prototype。对，每个函数都有一个属性叫做prototype。</p></blockquote><blockquote><p>这个prototype的属性值是一个对象（属性的集合，再次强调！），默认的只有一个叫做constructor的属性，指向这个函数本身。</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/js/oop/20191219163540.png!www.zeze.info" alt="js原型"><br>如上图，SuperType是是一个函数，右侧的方框就是它的原型。</p><blockquote><p>原型既然作为对象，属性的集合，不可能就只弄个constructor来玩玩，肯定可以自定义的增加许多属性。例如这位Object大哥，人家的prototype里面，就有好几个其他属性。</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/js/oop/20191219163625.png!www.zeze.info" alt="js原型"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Fn.prototype.name = <span class="string">'www.zeze.info'</span>;</span><br><span class="line">Fn.prototype.getYear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(fn.name);</span><br><span class="line"><span class="built_in">console</span>.log(fn.getYear());</span><br><span class="line"><span class="comment">//即，Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。</span></span><br><span class="line"><span class="comment">//因为每个对象都有一个隐藏的属性——“__proto__”，这个属性引用了创建这个对象的函数的prototype。</span></span><br><span class="line"><span class="comment">//即：fn.__proto__ === Fn.prototype</span></span><br></pre></td></tr></table></figure><p><strong>说到底:对象是由函数创建的.JavaScript的继承离不开prototype.这也是问什么函数的typeof为什么是Function类型了,原则上就是形成了一个原型环链,可能这里讲的不叫抽象,这是必要要注意对象的”<em>proto</em>“</strong></p><p>这里的”<strong>proto</strong>“成为“隐式原型”，下一节<a href="http://www.zeze.info/javaScript/oop/o4/">&lt;JavaScript 原型总结四 隐式原型&gt;</a>。另外本人的订阅号和微信</p><p><strong>有疑问或者商业合作可以加博主微信：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin">。一起交流</strong></p>]]></content>
      
      
      <categories>
          
          <category> js面向对象基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> js面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 原型总结二 一切皆对象之Typeof</title>
      <link href="/javaScript/oop/o2/"/>
      <url>/javaScript/oop/o2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="javascript中一个常用的运算符——typeof"><a href="#javascript中一个常用的运算符——typeof" class="headerlink" title="javascript中一个常用的运算符——typeof"></a>javascript中一个常用的运算符——typeof</h1><p>“一切都是对象”这句话的重点在于如何去理解“对象”这个概念。</p><p>——当然，也不是所有的都是对象，值类型就不是对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x);    <span class="comment">// undefined  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">10</span>);   <span class="comment">// number  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'abc'</span>); <span class="comment">// string  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);  <span class="comment">// boolean  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;);  <span class="comment">//function  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> [<span class="number">1</span>, <span class="string">'a'</span>, <span class="literal">true</span>]);  <span class="comment">//object  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;);  <span class="comment">//object  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);  <span class="comment">//object  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>));  <span class="comment">//object</span></span><br></pre></td></tr></table></figure><blockquote><p>以上代码列出了typeof输出的集中类型标识，其中上面的四种（undefined, number, string, boolean）属于简单的值类型，不是对象。剩下的几种情况——函数、数组、对象、null、new Number(10)都是对象。他们都是引用类型。</p></blockquote><blockquote><p>判断一个变量是不是对象非常简单。值类型的类型判断用typeof，引用类型的类型判断用instanceof。(这个方法也可以Object.prototype.toString.call(“引用对象”))</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(fn <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>java或者C#中的对象都是new一个class出来的，而且里面有字段、属性、方法，规定的非常严格。但是javascript就比较随意了——数组是对象，函数是对象，对象还是对象。对象里面的一切都是属性，只有属性，没有方法。那么这样方法如何表示呢？——方法也是一种属性。因为它的属性表示为键值对的形式。看下面代码</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    a:<span class="number">10</span>,</span><br><span class="line">    b:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    c:&#123;</span><br><span class="line">        name:<span class="string">"www.zeze.info"</span>,</span><br><span class="line">        year:<span class="string">"xxx"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上代码中，obj是一个自定义的对象，其中a、b、c就是它的属性，而且在c的属性值还是一个对象，它又有name、year两个属性。</p></blockquote><blockquote><p>这个可能比较好理解，那么函数和数组也可以这样定义属性吗？——当然不行，但是它可以用另一种形式，总之函数/数组之流，只要是对象，它就是属性的集合。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="number">100</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        fn.a = <span class="number">10</span>;</span><br><span class="line">        fn.b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="number">123</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        fn.c = &#123;</span><br><span class="line">            name: <span class="string">"张泽立"</span>,</span><br><span class="line">            year: <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="comment">//上段代码中，函数就作为对象被赋值了a、b、c三个属性——很明显，这就是属性的集合吗。你或许会问,这样有用吗?</span></span><br><span class="line"><span class="comment">//可以看看jQuery源码</span></span><br><span class="line"><span class="comment">//在jQuery源码中，“jQuery”或者“$”，这个变量其实是一个函数，不信你可以叫咱们的老朋友typeof验证一下。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> $);  <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log($.trim(<span class="string">" ABC "</span>));</span><br><span class="line"><span class="comment">//很明显，这就是在$或者jQuery函数上加了一个trim属性，属性值是函数，作用是截取前后空格。</span></span><br></pre></td></tr></table></figure><blockquote><p>而且，更加好玩的事，javascript中的对象可以任意的扩展属性，没有class的约束。这个大家应该都知道，就不再强调了。javascript与java/C#相比，首先最需要解释的就是弱类型，因为弱类型是最基本的用法，而且最常用，就不打算做一节来讲。其次要解释的就是本文的内容——一切（引用类型）都是对象，对象是属性的集合。最需要了解的就是对象的概念，和java/C#完全不一样。所以，切记切记！</p></blockquote><blockquote><p>在typeof的输出类型中，function和object都是对象为何却要输出两种答案呢？都叫做object不行吗？——当然不行。具体原因，且听下回分解<a href="http://www.zeze.info/javaScript/oop/o3/">&lt;JavaScript 原型总结三 函数和对象的关系&gt;</a>！</p></blockquote><p><strong>有疑问或者商业合作可以加博主微信：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin">。一起交流</strong></p>]]></content>
      
      
      <categories>
          
          <category> js面向对象基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> js面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 原型总结一 一切皆对象</title>
      <link href="/javaScript/oop/o1/"/>
      <url>/javaScript/oop/o1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="对象都是通过函数创建的"><a href="#对象都是通过函数创建的" class="headerlink" title="对象都是通过函数创建的"></a>对象都是通过函数创建的</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = <span class="string">'www.zeze.info'</span>;</span><br><span class="line">            <span class="keyword">this</span>.year = <span class="number">1995</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="comment">//对于下列你可能会有疑问,但是其实下面只是一种语法糖通是过字面量来创建的底层是词法解析(早期其实解析成构造函数)</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>, <span class="string">'x'</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure><h3 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h3><table><thead><tr><th align="left">本地对象</th><th align="left">构造函数</th><th align="left">字面量</th></tr></thead><tbody><tr><td align="left">Array</td><td align="left">new Array()</td><td align="left">[]</td></tr><tr><td align="left">Boolean</td><td align="left">new Boolean()</td><td align="left">true/false</td></tr><tr><td align="left">String</td><td align="left">new String()</td><td align="left">“”</td></tr><tr><td align="left">Number</td><td align="left">new Number()</td><td align="left">1</td></tr><tr><td align="left">Date</td><td align="left">new Date()</td><td align="left">Date对象会自动把当前日期和时间保存为其初始值</td></tr><tr><td align="left">RegExp</td><td align="left">new RegExp(p,a)</td><td align="left">/pattern/attributes  比如:/is/g</td></tr><tr><td align="left">Math</td><td align="left">没有构造函数</td><td align="left">Math对象并不像Date, String 那样是对象的类，因此没有构造函数</td></tr></tbody></table><p>这些都是JavaScript对象,其中Math为内置对象,一切皆对象</p><p>首先咱们还是先看看javascript中一个常用的运算符——typeof。typeof应该算是咱们的老朋友，还有谁没用过它？请看下节<a href="http://www.zeze.info/javaScript/oop/o2/">&lt;JavaScript 原型总结二 一切皆对象之typeof&gt;</a></p><p><strong>有疑问或者商业合作可以加博主微信：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin">。一起交流</strong></p>]]></content>
      
      
      <categories>
          
          <category> js面向对象基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> js面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript原型和原型链</title>
      <link href="/javaScript/js3/"/>
      <url>/javaScript/js3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入javascript之原型和原型链"><a href="#深入javascript之原型和原型链" class="headerlink" title="深入javascript之原型和原型链"></a>深入javascript之原型和原型链</h1><blockquote><p>我们知道在js中，万物皆对象，对象可以说是重中之重了。每一个对象都拥有自己的属性。但是在这个世界中有很多东西都是相似的，可以归为一类，他们有共同的方法和属性。不可能让每一个对象都定义一个属性吧。那样太消耗内存了。所以，在js中怎么才能让多个对象共享一个或多个方法呢？原型的出现就是为了解决这个问题。</p></blockquote><blockquote><p>在js中每个对象都有一个与它关联的对象，叫做原型对象。每一次获取对象属性都是一次查询过程，当在对象的自有属性中找不到时就会去查找它的原型对象。</p></blockquote><blockquote><p>在js中函数也是一个对象。每个函数都有一个prototype属性（只有函数才有prototype属性），这是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。其中原型对象会自动获得一个constructor属性，这个属性指向prototype属性所在的指针。如下面的Man.prototype.constructor指向Man。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Man(<span class="string">"张三"</span>,<span class="string">"18"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Man(<span class="string">"李四"</span>,<span class="string">"19"</span>);</span><br><span class="line">Man.prototype.sex = <span class="string">"男"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.sex); <span class="comment">//男</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.sex); <span class="comment">//男</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>每个男孩共有的属性就是他的性别都是男，所以我们可以将此属性添加到实例的原型对象中去。这样每个实例都可以共享这个属性。</p></blockquote><blockquote><p>我们前面说了每个函数都有prototype属性，指向函数的原型对象。他的实例对象可以共享这个属性，那我们怎么将实例对象和原型对象关联起来呢？在js中，任何对象都有一个属性叫<strong>proto</strong>（[[prototype]]），它也是一个指针，指向构造函数的原型对象，就是我们所能共享信息的那个对象。现在我们可以画出一幅图，展示他们之间的关系。</p></blockquote><blockquote><blockquote><p>注意: 理解对象的原型（可以通过<code>Object.getPrototypeOf(obj)</code>或者已被弃用的<strong>proto</strong>属性获得）与构造函数的prototype属性之间的区别是很重要的。前者是每个实例上都有的属性，后者是构造函数的属性。也就是说，<code>Object.getPrototypeOf(new Foobar())</code>和<code>Foobar.prototype</code>指向着同一个对象。</p></blockquote></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/js/20191218164428.png!www.zeze.info" alt="原型"></p><blockquote><p>原型链是什么呢，根据字面意思我们可以这样理解，就是将原型连成一条链。我们上面讲过，js每一次获取对象中的属性都是一次查询过程，如果在自有属性中找不到就会去原型对象中查找，如果原型对象中还查不到，就回去原型对象的原型中查找，也就是按照原型链查找，直到查找到原型链的顶端，也就是Object的原型。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FutherType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">FutherType.prototype.getFutherValue - <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SonType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.sonproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">SonType.prototype = <span class="keyword">new</span> FutherType();</span><br><span class="line">SonType.prototype.getSonValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.sonproperty;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SonType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getFutherValue()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>原型对象之间的关系如下图：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/js/20191218165210.png!www.zeze.info" alt="原型对象"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> js原型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript实现接口的三种经典方式</title>
      <link href="/javaScript/js2/"/>
      <url>/javaScript/js2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript实现接口的三种经典方式"><a href="#JavaScript实现接口的三种经典方式" class="headerlink" title="JavaScript实现接口的三种经典方式"></a>JavaScript实现接口的三种经典方式</h1><blockquote><p>tip:看此片文章之前建议先了解<a href="https://my.oschina.net/u/3703858/blog/1614102" target="_blank" rel="external nofollow noopener noreferrer">JavaScript原型</a></p></blockquote><h2 id="注释描述接口"><a href="#注释描述接口" class="headerlink" title="注释描述接口"></a>注释描述接口</h2><p>注释描述接口： <strong>不推荐</strong></p><ul><li>优点：利用注解，给出参考</li><li>缺点：纯文档约束，是一个假接口，程序不能检查实现接口对象是否实现所有接口方法<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* interface Composite&#123;</span></span><br><span class="line"><span class="comment">*         function a();</span></span><br><span class="line"><span class="comment">*         function b();</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">var</span> CompositeImpl = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">CompositeImpl.prototype.a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="comment">//业务逻辑</span></span><br><span class="line">&#125;;</span><br><span class="line">CompositeImpl.prototype.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//业务逻辑</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="属性检测接口"><a href="#属性检测接口" class="headerlink" title="属性检测接口"></a>属性检测接口</h2><ul><li>优点：能够检测实现哪些接口</li><li>缺点：没有完全脱离文档，不能检测是否实现每个接口里的所有方法<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface Composite&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="title">interface</span> <span class="title">FormItem</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function">// <span class="title">CompositeImpl</span> <span class="title">implements</span> <span class="title">Composite</span>,<span class="title">FormItem</span></span></span><br><span class="line"><span class="function"> <span class="title">var</span> <span class="title">interfacesImpl</span> = <span class="title">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//在实现类内部用一个数组保存要实现的方法名</span></span><br><span class="line">    <span class="comment">//通常这个属性名是团队中规定好的</span></span><br><span class="line">    <span class="keyword">this</span>.implementsInterfaces = [<span class="string">"Composite"</span>,<span class="string">"FormItem"</span>];</span><br><span class="line">&#125;;</span><br><span class="line">CompositeImpl.prototype.a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="comment">//业务逻辑</span></span><br><span class="line">&#125;;</span><br><span class="line">CompositeImpl.prototype.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//业务逻辑</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//专门为这个实现对象写一个检测函数，传入实例对象，用于检查实力对象是否实现了所有接口</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkImplements</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//调用检查方法 obj是否实现两个接口，如果没有都实现则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span>(!isImplements(obj,<span class="string">"Composite"</span>,<span class="string">"FormItem"</span>))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"接口没有全部实现！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收一个参数obj是要检查的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isImplements</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//arguments对象能够获取实际传入函数的所有参数的数组</span></span><br><span class="line">        <span class="comment">//传入的第0个参数是要检查的对象，所以从1开始检查</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length ; i++)&#123;</span><br><span class="line">            <span class="comment">//接收接口中每个接口的名字</span></span><br><span class="line">            <span class="keyword">var</span> interfaceName = <span class="built_in">arguments</span>[i];</span><br><span class="line">            <span class="comment">//一个标记，是否实现这个接口，默认没有</span></span><br><span class="line">            <span class="keyword">var</span> foundFlag = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//循环查询传入实例对象的实现接口数组 以检查是否全部实现</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span> ;j &lt;obj.implementsInterfaces.length;j++)&#123;</span><br><span class="line">                <span class="comment">//如果 实现了这个接口 就修改标记跳出循环</span></span><br><span class="line">                <span class="keyword">if</span>(obj.implementsInterfaces[j]==interfaceName)&#123;</span><br><span class="line">                    foundFlag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果遍历实现接口数组之后没找到 就返回false</span></span><br><span class="line">            <span class="keyword">if</span>(!foundFlag)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果都找到了 返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用实力对象并检测</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> interfacesImpl();</span><br><span class="line">checkImplements(o);    <span class="comment">//不会抛出异常 因为正确实现了两个接口</span></span><br><span class="line"><span class="comment">//如果在写interfacesImpl内的implementsInterfaces列表的时候少写了，那么就会在检查函数中抛出异常</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="鸭式辨型法-目前开发中使用的方式"><a href="#鸭式辨型法-目前开发中使用的方式" class="headerlink" title="鸭式辨型法(目前开发中使用的方式)"></a>鸭式辨型法(目前开发中使用的方式)</h2><blockquote><p>实现接口实际上是检测对象是否拥有接口定义的所有方法。接口只是用来定义某些方法名称，它并不需要实现这些方法</p></blockquote><ol><li><p>接口类 Class Interface</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口类需要的参数：</span></span><br><span class="line"><span class="comment"> * 1 接口的名字</span></span><br><span class="line"><span class="comment"> * 2 要实现方法名称的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> Interface = <span class="function"><span class="keyword">function</span>(<span class="params"> name , methods </span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断参数个数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length!=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"接口构造器参数必须是两个！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.methods = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;methods.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="keyword">typeof</span> methods[i] !== <span class="string">"string"</span> )&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"接口实现的函数名称必须是字符串！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.methods.push(methods[i]);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>准备工作：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.1 实例化接口对象    传入接口名 和 要实现的方法数组</span></span><br><span class="line"><span class="keyword">var</span> CompositeInterface = <span class="keyword">new</span> Interface(<span class="string">"CompositeInterface"</span>,[<span class="string">"add"</span>,<span class="string">"remove"</span>]);</span><br><span class="line"><span class="keyword">var</span> FormItemInterface = <span class="keyword">new</span> Interface(<span class="string">"FormItemInterface"</span>,[<span class="string">"update"</span>,<span class="string">"select"</span>]);</span><br><span class="line"><span class="comment">//  2.2 实现接口的类</span></span><br><span class="line"><span class="comment">//CompositeImpl implementes CompositeInterface ,FormItemInterface</span></span><br><span class="line"><span class="keyword">var</span> CompositeImpl = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  2.3 实现接口的方法</span></span><br><span class="line">CompositeImpl.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"add..."</span>);</span><br><span class="line">&#125;;</span><br><span class="line">CompositeImpl.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"remove..."</span>);</span><br><span class="line">&#125;;</span><br><span class="line">CompositeImpl.prototype.select = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"select..."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在这里少实现一个方法 下面检测是否全部实现了接口方法</span></span><br><span class="line"><span class="comment">// CompositeImpl.prototype.update = function(obj)&#123;</span></span><br><span class="line"><span class="comment">//     alert("update...");</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="comment">// 实例化   实现接口的对象</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> CompositeImpl();</span><br><span class="line"><span class="comment">//3 检验接口里的方法是否全部实现</span></span><br><span class="line"><span class="comment">// 如果检验通过 继续执行;如果不通过抛出异常;</span></span><br><span class="line">Interface.ensureImplements = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 如果接收到参数小于2 说明 传参出错了，只传入一个参数，，没有传入实现的接口</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"接口检查方法的参数必须多余两个！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得要见测的接口实现对象之后的参数 各个接口</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>,len = <span class="built_in">arguments</span>.length;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> instanceInterface = <span class="built_in">arguments</span>[i];    <span class="comment">//获取当前这个接口</span></span><br><span class="line">        <span class="comment">//判断接收到的是不是接口的对象  如果不是 抛出异常</span></span><br><span class="line">        <span class="keyword">if</span>( instanceInterface.constructor !== Interface)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"接口检测函数必须传入接口对象！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查实例化接口的对象是不是实现了接口里的所有方法</span></span><br><span class="line">        <span class="comment">// 当前接口对象里的每一个方法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span> ; j&lt;instanceInterface.methods.length;j++)&#123;</span><br><span class="line">            <span class="keyword">var</span> methodName = instanceInterface.methods[j]; <span class="comment">//接收到了字符串的方法名</span></span><br><span class="line">            <span class="comment">//如果obj里面没有有methodName这个方法 或者有这个属性但是不是函数 就抛出异常</span></span><br><span class="line">            <span class="keyword">if</span>(!obj[methodName] || <span class="keyword">typeof</span> obj[methodName] !== <span class="string">"function"</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"接口方法"</span>+ methodName +<span class="string">"没有实现！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//传入要检查的类，和他要实现的所有接口对象</span></span><br><span class="line">Interface.ensureImplements(c ,CompositeInterface ,FormItemInterface );</span><br><span class="line">c.add();</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> js原型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的JavaScript·作用域链</title>
      <link href="/javaScript/js1/"/>
      <url>/javaScript/js1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="作用域是什么"><a href="#作用域是什么" class="headerlink" title="作用域是什么"></a>作用域是什么</h1><blockquote><p>作用域是你的代码在运行时,某些特定部分中的变量,函数和对象的可访问性。换句话说，作用域决定了变量与函数的可访问范围，即<code>作用域控制着变量与函数的可见性和生命周期</code>。</p></blockquote><h2 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h2><div class="note default"> 在 JavaScript 中有两种作用域</div><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><blockquote><p>如果一个变量在函数外面或者大括号{}外声明,那么就定义了一个全局作用域<br>拥有全局作用域的对象可以在代码的任何地方访问到, 在js中一般有以下几种情形拥有全局作用域:<br>最外层的函数以及最外层变量:</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> globleVariable= <span class="string">'global'</span>;  <span class="comment">// 最外层变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">globalFunc</span>(<span class="params"></span>)</span>&#123;         <span class="comment">// 最外层函数</span></span><br><span class="line">    <span class="keyword">var</span> childVariable = <span class="string">'global_child'</span>;  <span class="comment">//函数内变量</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">childFunc</span>(<span class="params"></span>)</span>&#123;        <span class="comment">// 内层函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(childVariable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(globleVariable)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(globleVariable);  <span class="comment">// global</span></span><br><span class="line">globalFunc();                 <span class="comment">// global</span></span><br><span class="line"><span class="built_in">console</span>.log(childVariable)   <span class="comment">// childVariable is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(childFunc)       <span class="comment">// childFunc is not defined</span></span><br></pre></td></tr></table></figure><p>从上面代码中可以看到<code>globleVariable</code>和<code>globalFunc</code>在任何地方都可以访问到, 反之不具有全局作用域特性的变量只能在其作用域内使用。</p><blockquote><p>未定义直接赋值的变量(由于变量提升使之成为全局变量)</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    special = <span class="string">'special_variable'</span>;</span><br><span class="line">    <span class="keyword">var</span> normal = <span class="string">'normal_variable'</span>;</span><br><span class="line">&#125;</span><br><span class="line">func1();</span><br><span class="line"><span class="built_in">console</span>.log(special);    <span class="comment">//special_variable</span></span><br><span class="line"><span class="built_in">console</span>.log(normal)     <span class="comment">// normal is not defined</span></span><br></pre></td></tr></table></figure><p>虽然我们可以在全局作用域中声明函数以及变量, 使之成为全局变量, 但是不建议这么做,因为这可能会和其他的变量名冲突,一方面如果我们再使用const或者let声明变量, 当命名发生冲突时会报错。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量冲突</span></span><br><span class="line"><span class="keyword">var</span> globleVariable = <span class="string">"person"</span>;</span><br><span class="line"><span class="keyword">let</span> globleVariable = <span class="string">"animal"</span>; <span class="comment">// Error, thing has already been declared</span></span><br></pre></td></tr></table></figure><p>另一方面如果你使用var申明变量，第二个申明的同样的变量将覆盖前面的,这样会使你的代码很难调试。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'koala'</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'xiaoxiao'</span></span><br><span class="line"><span class="built_in">console</span>.log(name);  <span class="comment">// xiaoxiao</span></span><br></pre></td></tr></table></figure><h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><blockquote><p>在ES6之前局部作用域只包含了函数作用域,ES6为我们提供的块级作用域,也属于局部作用域</p></blockquote><h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><div class="note default">     定义在函数中的变量就在函数作用域中。并且函数在每次调用时都有一个不同的作用域。这意味着同名变量可以用在不同的函数中。因为这些变量绑定在不同的函数中，拥有不同作用域，彼此之间不能访问。</div><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//全局作用域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">9</span>;</span><br><span class="line">    <span class="comment">// 内部可以访问</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"test中："</span>+num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//test外部不能访问</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"test外部:"</span>+num);</span><br></pre></td></tr></table></figure><div class="note default"> 注意点：如果在函数中定义变量时,如果不添加var关键字,造成变量提升，这个变量成为一个全局变量。</div><blockquote><p>任何一对花括号<code>｛...｝</code>中的语句集都属于一个块, 在es6之前，在块语句中定义的变量将保留在它已经存在的作用域中：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'www.zeze.info'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'&#123;&#125;外部:'</span>+i);</span><br><span class="line"><span class="comment">// 0 1 2 3 4  &#123;&#125;外部:5</span></span><br></pre></td></tr></table></figure><blockquote><p>我们可以看到变量name和变量i是同级作用域。</p></blockquote><h4 id="在ES6块级作用域未讲解之前注意点"><a href="#在ES6块级作用域未讲解之前注意点" class="headerlink" title="在ES6块级作用域未讲解之前注意点"></a>在ES6块级作用域未讲解之前注意点</h4><div class="note default"> 变量提升英文名字hoisting,MDN中对它的解释是变量申明是在任意代码执行前处理的，在代码区中任意地方申明变量和在最开始（最上面）的地方申明是一样的。也就是说，看起来一个变量可以在申明之前被使用！这种行为就是所谓的“hoisting”，也就是变量提升，看起来就像变量的申明被自动移动到了函数或全局代码的最顶上。看一段代码：</div><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(tmp);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> tmp=<span class="string">'hello'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这道题应该很多小伙伴在面试中遇到过，有人会认为输出的是当前日期。但是正确的结果是undefined。这就是由于变量提升造成的，在这里<strong>申明提升了，定义的内容并不会提升</strong>，提升后对应的代码如下：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp;</span><br><span class="line">    <span class="built_in">console</span>.log(tmp);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        tmp=<span class="string">'hello'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><blockquote><p>console在输出的时候，tmp变量仅仅申明了但未定义。所以输出undefined。虽然能够输出，但是并不推荐这种写法推荐的做法是在申明变量的时候，将所用的变量都写在作用域（全局作用域或函数作用域）的最顶上，这样代码看起来就会更清晰，更容易看出来哪个变量是来自函数作用域的，哪个又是来自作用域链</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'koloa'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// koala</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'www.zeze.info'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// 程序员成长指北</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 程序员成长指北</span></span><br></pre></td></tr></table></figure><blockquote><p>虽然看起来里面name申明了两次，但上面说了，js的var变量只有全局作用域和函数作用域两种，且申明会被提升，因此实际上name只会在最顶上开始的地方申明一次，var name=’程序员成长指北’的申明会被忽略，仅用于赋值。也就是说上面的代码实际上跟下面是一致的。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'koloa'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// koala</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    name = <span class="string">'程序员成长指北'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// 程序员成长指北</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 程序员成长指北</span></span><br></pre></td></tr></table></figure><blockquote><p>变量和函数同时出现的提升:如果有函数和变量同时声明了，会出现什么情况呢？看下面但代码</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="keyword">var</span> foo =<span class="string">'i am koala'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果是undefined<br>对两种结果进行分析说明：<br>第一种：函数申明。就是上面第一种，function foo(){}这种形式<br>另一种：函数表达式。就是上面第二种，var foo=function(){}这种形式<br>第二种形式其实就是var变量的声明定义，因此上面的第二种输出结果为undefined应该就能理解了。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="keyword">var</span> foo =<span class="string">'i am koala'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>原因是：<br>函数声明被提升到最顶上；<br>申明只进行一次，因此后面var foo=’i am koala’的申明会被忽略。<br>函数申明的优先级优于变量申明，且函数声明会连带定义一起被提升（这里与变量不同）</p></blockquote><h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><blockquote><p>ES6新增了let和const命令，可以用来创建块级作用域变量，使用let命令声明的变量只在let命令所在代码块内有效。<br>let 声明的语法与 var 的语法一致。你基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：<br>变量不会提升到代码块顶部且不允许从外部访问块级作用域内部变量</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(bar);<span class="comment">//抛出`ReferenceErro`异常: 某变量 `is not defined`</span></span><br><span class="line"><span class="keyword">let</span> bar=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i =<span class="number">0</span>; i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">//抛出`ReferenceErro`异常: 某变量 `is not defined`</span></span><br></pre></td></tr></table></figure><blockquote><p>其实这个特点带来了许多好处，开发者需要检查代码时候，可以避免在作用域外意外但使用某些变量，而且保证了变量不会被混乱但复用，提升代码的可维护性。就像代码中的例子，一个只在for循环内部使用的变量i不会再去污染整个作用域。</p></blockquote><blockquote><p>不允许反复声明<br>ES6的let和const不允许反复声明，与var不同</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'koloa'</span>;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'www.zeze.info'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// 程序员成长指北</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let || const</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name =<span class="string">'koloa'</span>;</span><br><span class="line">    <span class="keyword">let</span> name= <span class="string">'www.zeze.info'</span>; </span><br><span class="line">    <span class="comment">// Uncaught SyntaxError: Identifier 'count' has already been declared</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里是不是感觉到了块级作用域的出现还是很有必要的。</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><h3 id="JavaScript是如何执行的？"><a href="#JavaScript是如何执行的？" class="headerlink" title="JavaScript是如何执行的？"></a>JavaScript是如何执行的？</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/js/20191217155049.png!www.zeze.info" alt="作用域链"></p><p>JavaScript代码执行分为两个阶段：</p><h4 id="分析阶段"><a href="#分析阶段" class="headerlink" title="分析阶段"></a>分析阶段</h4><ul><li>分析函数参数</li><li>分析变量声明</li><li>分析函数声明</li></ul><h4 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h4><p>分析阶段分析成功后，会把给<code>AO(Active Object</code> 活动对象)给执行阶段</p><ul><li>引擎询问作用域，作用域中是否有这个叫X的变量</li><li>如果作用域有X变量，引擎会使用这个变量</li><li>如果作用域中没有，引擎会继续寻找（向上层作用域），如果到了最后都没有找到这个变量，引擎会抛出错误。</li></ul><p>执行阶段的核心就是找,具体怎么找，后面会讲解LHS查询与RHS查询。</p><h4 id="JavaScript执行举例说明"><a href="#JavaScript执行举例说明" class="headerlink" title="JavaScript执行举例说明"></a>JavaScript执行举例说明</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">20</span></span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">age</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line">a(<span class="number">18</span>);</span><br></pre></td></tr></table></figure><p>首先进入分析阶段<br>前面已经提到了，函数运行的瞬间，创建一个<code>AO (Active Object 活动对象)</code></p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">AO</span> = &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>第一步：分析函数参数：</strong></p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">形式参数：<span class="module-access"><span class="module"><span class="identifier">AO</span>.</span></span>age = undefined</span><br><span class="line">实参：<span class="module-access"><span class="module"><span class="identifier">AO</span>.</span></span>age = <span class="number">18</span></span><br></pre></td></tr></table></figure><p><strong>第二步，分析变量声明：</strong></p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第3行代码有var age</span></span><br><span class="line"><span class="comment">// 但此前第一步中已有AO.age = 18, 有同名属性,不做任何事</span></span><br><span class="line">即<span class="module-access"><span class="module"><span class="identifier">AO</span>.</span></span>age = <span class="number">18</span></span><br></pre></td></tr></table></figure><p><strong>第三步，分析函数声明：</strong></p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">// 第<span class="number">5</span>行代码有函数age</span><br><span class="line">// 则将<span class="function"><span class="keyword">function</span> <span class="title">age</span><span class="params">()</span></span>&#123;&#125;付给AO.age</span><br><span class="line">AO.age = <span class="function"><span class="keyword">function</span> <span class="title">age</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>函数声明注意点：AO上如果有与函数名同名的属性,则会被此函数覆盖。但是一下面这种情况</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'25'</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>声明的函数并不会覆盖AO链中同名的属性<br><strong>进入执行阶段</strong><br>分析阶段分析成功后，会把给<code>AO(Active Object 活动对象)</code>给执行阶段，引擎会询问作用域，找的过程。所以上面那段代码AO链中最初应该是</p><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">age</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="作用域链概念"><a href="#作用域链概念" class="headerlink" title="作用域链概念"></a>作用域链概念</h3><p>看了前面一个完整的javascript函数执行过程，让我们来说下作用域链的概念吧。<code>JavaScript上每一个函数执行时，会先在自己创建的AO上找对应属性值。若找不到则往父函数的AO上找，再找不到则再上一层的AO,直到找到大boss:window（全局作用域）。 而这一条形成的“AO链” 就是JavaScript中的作用域链。</code></p><h2 id="JavaScript中的LHS和RHS查询"><a href="#JavaScript中的LHS和RHS查询" class="headerlink" title="JavaScript中的LHS和RHS查询"></a>JavaScript中的LHS和RHS查询</h2><h3 id="简述编译原理"><a href="#简述编译原理" class="headerlink" title="简述编译原理"></a>简述编译原理</h3><blockquote><p>通常，把 JavaScript 归类为 “  动态 ” 或 “ 解释执行 ” 的语言，但是事实上它是一门 <strong>编译语言</strong>，不提前编译，编译结果也不在分布式系统中进行移植。JavaScript 引擎进行编译的步骤和传统的编译语言非常相似，在某些环节比它要复杂。传统编译语言，在执行之前的三个步骤，统称为 “ 编译  ” 。</p></blockquote><h4 id="分词-词法分析（-Tokenizing-Lexing-）"><a href="#分词-词法分析（-Tokenizing-Lexing-）" class="headerlink" title="分词/词法分析（ Tokenizing/Lexing ）"></a>分词/词法分析（ Tokenizing/Lexing ）</h4><blockquote><p>将有字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元( token )。<code>var a = 2;</code>复制代码被分解成词法单元：<code>var 、a、 =、2、;</code>。空格在该语言中有意义，则会被当做词法单元，否则不是。</p></blockquote><h4 id="解析-语法分析（-Parsing-）"><a href="#解析-语法分析（-Parsing-）" class="headerlink" title="解析/语法分析（ Parsing ）"></a>解析/语法分析（ Parsing ）</h4><blockquote><p>将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的 “ 抽象语法树   ”（ Abstract Syntax Tree , AST ）。<code>var a = 2;</code>复制代码以上代码的抽象语法树如下所示：</p></blockquote><ul><li>VariableDeclaration  顶级节点<ul><li>Identifer 子节点，值为  a</li><li>AssignmentExpression  子节点<ul><li>NumericLiteral  子节点，值为 2</li></ul></li></ul></li></ul><h4 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h4><blockquote><p>将 <code>AST</code>转换为可执代码的过程被称为代码生成。这个过程与语言、目标平台等相关。即通过某种方法，将  <code>var a = 2 ;</code>  的 AST 转化为一组机器指令，用来创建一个变量  <code>a</code> ，并将值存储在 <code>a</code> 中。引擎，可以根据需要创建并存储变量。</p></blockquote><blockquote><p>与其他语言不同，JavaScript的编译过程不是发生在构建之前的。对于JavaScript来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短）的时间内。</p></blockquote><blockquote><p>举个栗子，var a = 2; JavaScript引擎会将它分为几步完成呢？<br>答案是两步，JavaScript 会将其看成两句声明：var a; 和 a = 2;。第一个定义声明在编译阶段进行，第二个赋值声明会被留在原地等待执行阶段。<br>变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在引用域中查找该变量，如果能够找到就会对它赋值。</p></blockquote><h1 id="JavaScript中的LHS和RHS查询-1"><a href="#JavaScript中的LHS和RHS查询-1" class="headerlink" title="JavaScript中的LHS和RHS查询"></a>JavaScript中的LHS和RHS查询</h1><h2 id="LHS-和-RHS"><a href="#LHS-和-RHS" class="headerlink" title="LHS 和 RHS"></a>LHS 和 RHS</h2><blockquote><p>LHS(<code>Left-hand Side</code>)引用和RHS(<code>Right-hand Side</code>)引用。通常是指等号（赋值运算）的左右边的引用。</p></blockquote><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(a);</span><br></pre></td></tr></table></figure><blockquote><p>这里对a的引用是一个<code>RHS引用</code>，因为这里a并没有赋予任何值，我们只是想<code>查找并取得a的值</code>，然后将它打印出来。</p></blockquote><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">a</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p>这里对a的引用是一个<code>LHS引用</code>，因为我们并不关心当前的值是什么，只是想要为赋值操作找到目标。</p></blockquote><div class="note default"> ### 注LHS和RHS的含义是“赋值操作的左侧和右侧”并不一定意味这就是"="的左侧和右侧。赋值操作还有其他几种形式，因此在概念上最好将其理解为“`赋值操作的目标是谁（LHS）`”以及“`谁是赋值操作的源头（RHS）`”</div><p>这里再举一个较复杂的例子：（找出所有的LHS查询和所有的RHS查询）</p><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = foo(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>这里一共有3个LHS查询和4个RHS查询，这里我们都来做个分析。</p><p><strong>LHS</strong></p><ol><li>第6行的 <code>c = ...</code>，c 在赋值操作的左边，所以对 c 需要 LHS 查询。</li><li>隐藏着的 <code>a = 2</code>（隐式变量分配）,在调用 foo(2) 时，需要将实参2赋值给形参a，所以对 a 需要 LHS 查询。</li><li>第2行的<code>b = ...</code>, 解释同 1。</li></ol><p><strong>RHS</strong></p><ol><li>第6行的<code>c = foo(2)</code>，foo(2) 在赋值操作的右边，需要知道 foo(2)的值，对 foo(2) 需要 RHS 查询。</li><li>第2行的<code>b = a</code>， a 在赋值操作的右边，需要知道 a的值，对 a 需要 RHS 查询。</li><li>第3行的<code>reutrn a + b</code>;， 需要知道 a 和 b 的值， 分别对 a 和 b 都进行 RHS 查询。</li></ol><div class="note default"> ### 小结：如果查找的目的是对变量进行赋值，那么就会使用LHS查询；如果目的是获取变量的值，就会使用RHS查询。</div> <h2 id="区分-LHS-和-RHS-的重要性"><a href="#区分-LHS-和-RHS-的重要性" class="headerlink" title="区分 LHS 和 RHS 的重要性"></a>区分 LHS 和 RHS 的重要性</h2><blockquote><p>因为在变量还没有声明(在任何作用域中都无法找到该变量)情况下，这两种查询行为是不一样的。</p></blockquote><blockquote><p>LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说他们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一次作用域，最后抵达全局作用域，无论找到或没找到都将停止。</p></blockquote><blockquote><p>借用一张图，将作用域链比喻成一个建筑，在对上面的论述进行一次转换。<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/js/20191217161153.png!www.zeze.info" alt="作用域链"></p></blockquote><p>这个建筑代表储蓄中的嵌套作用域链。第一层楼代表当前的执行作用域，也就是你所在的位置。建筑的顶层代表全局作用域。</p><p>LHS 和 RHS 引用都会在当前楼层进行查找，如果没有找到，就会坐电梯前往上一层楼，如果还是没有找到就继续向上，以此类推。一旦抵达顶层（全局作用域），可能找到了你所需的变量，也可能没找到，但无论如何查找过程都将停止。</p><div class="note default"> ### 总结:不成功的RHS引用会导致抛出 ReferenceError 异常。不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用LHS引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）。</div> ]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中 With的用法</title>
      <link href="/javaScript/js-with/"/>
      <url>/javaScript/js-with/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>说起js中的with关键字，很多小伙伴们的第一印象可能就是with关键字的作用在于改变作用域，然后最关键的一点是不推荐使用with关键字。听到不推荐with关键字后，我们很多人都会忽略掉with关键字，认为不要去管它用它就可以了。但是有时候，我们在看一些代码或者面试题的时候，其中会有with关键字的相关问题，很多坑是你没接触过的，所以还是有必要说说with这一个关键字。</p></blockquote><h1 id="with的基本用法"><a href="#with的基本用法" class="headerlink" title="with的基本用法"></a>with的基本用法</h1><blockquote><p>with 语句的原本用意是为逐级的对象访问提供命名空间式的速写方式. 也就是在指定的代码区域, 直接通过节点名称调用对象。with 通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。比如，目前现在有一个这样的对象：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">a: <span class="number">1</span>,</span><br><span class="line">b: <span class="number">2</span>,</span><br><span class="line">c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>如果想要改变 obj 中每一项的值，一般写法可能会是这样：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重复写了3次的“obj”</span></span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line">obj.b = <span class="number">3</span>;</span><br><span class="line">obj.c = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><blockquote><p>而用了 with 的写法，会有一个简单的快捷方式</p></blockquote><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">with</span> (obj) &#123;</span><br><span class="line"><span class="attribute">a</span> = <span class="number">3</span>;</span><br><span class="line"><span class="attribute">b</span> = <span class="number">4</span>;</span><br><span class="line"><span class="attribute">c</span> = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这段代码中，使用了 with 语句关联了 obj 对象，这就以为着在 with 代码块内部，每个变量首先被认为是一个局部变量，如果局部变量与 obj 对象的某个属性同名，则这个局部变量会指向 obj 对象属性。</p></blockquote><h1 id="with的弊端"><a href="#with的弊端" class="headerlink" title="with的弊端"></a>with的弊端</h1><blockquote><p>在上面的例子中，我们可以看到，with 可以很好地帮助我们简化代码。但是为什么不推荐使用呢？下面我们来说说with的缺点：</p></blockquote><h2 id="导致数据泄漏"><a href="#导致数据泄漏" class="headerlink" title="导致数据泄漏"></a>导致数据泄漏</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">a: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = &#123;</span><br><span class="line">b: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(o1);</span><br><span class="line"><span class="built_in">console</span>.log(o1.a);<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">foo(o2);</span><br><span class="line"><span class="built_in">console</span>.log(o2.a);<span class="comment">//underfined</span></span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//a被泄漏到全局作用域上</span></span><br></pre></td></tr></table></figure><blockquote><p>首先，我们来分析上面的代码。例子中创建了 o1 和 o2 两个对象。其中一个有 a 属性，另外一个没有。foo(obj) 函数接受一个 obj 的形参，该参数是一个对象引用，并对该对象引用执行了 <code>with(obj) {...}。</code>在 with 块内部，对 a 有一个词法引用，实际上是一个 <a href="http://www.zeze.info/javaScript/js1/#JavaScript%E4%B8%AD%E7%9A%84LHS%E5%92%8CRHS%E6%9F%A5%E8%AF%A2-1">LHS引用</a>，将 2 赋值给了它。</p></blockquote><blockquote><p>当我们将 o1 传递进去，a = 2 赋值操作找到了 o1.a 并将 2 赋值给它。而当 o2 传递进去，o2 并没有 a 的属性，因此不会创建这个属性，o2.a 保持 undefined。</p></blockquote><blockquote><p>但为什么对 o2的操作会导致数据的泄漏呢？</p></blockquote><blockquote><p>这里需要回到对 LHS查询 的机制问题（<a href="http://www.zeze.info/javaScript/js1/#JavaScript%E4%B8%AD%E7%9A%84LHS%E5%92%8CRHS%E6%9F%A5%E8%AF%A2-1">详情可移步 JavaScript中的LHS和RHS查询</a>)）。</p></blockquote><blockquote><p>当我们传递 o2 给 with 时，with 所声明的作用域是 o2, 从这个作用域开始对 a 进行 LHS查询。o2 的作用域、foo(…) 的作用域和全局作用域中都没有找到标识符 a，因此在非严格模式下，会自动在全局作用域创建一个全局变量），在严格模式下，会抛出ReferenceError 异常。</p></blockquote><div class="note warning">另一个不推荐 with 的原因是。在严格模式下，with 被完全禁止，间接或非安全地使用 eval(…) 也被禁止了。</div><h1 id="性能下降"><a href="#性能下降" class="headerlink" title="性能下降"></a>性能下降</h1><blockquote><p>with 会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。with 可以使代码更具有扩展性，虽然有着上面的数据泄漏的可能，但只要稍加注意就可以避免，难道不是可以创造出很好地功能吗？答案是否定的，具体原因我们先来看下面的这部分代码。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">"func"</span>);</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">a: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> v = obj.a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"func"</span>);</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcWith</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">"funcWith"</span>);</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">a: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">with</span>(obj) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line"><span class="keyword">var</span> v = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"funcWith"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcWith();</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/js/20191217114621.png!www.zeze.info" alt="js"></p><blockquote><p>在处理相同逻辑的代码中，没用 with 的运行时间仅为 4.63 ms。而用 with 的运用时间长达 81.87ms。这是为什么呢？</p></blockquote><blockquote><p>原因是 JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但如果引擎在代码中发现了 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。</p></blockquote><blockquote><p>最悲观的情况是如果出现了 with ，所有的优化都可能是无意义的。因此引擎会采取最简单的做法就是完全不做任何优化。如果代码大量使用 with 或者 eval()，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢的事实。</p></blockquote><p><strong>有疑问或者商业合作可以加博主微信：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin">。一起交流</strong></p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven打包同时引入本地jar包</title>
      <link href="/java/java-maven/"/>
      <url>/java/java-maven/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="方法一-pom文件指定jar包目录进行引入"><a href="#方法一-pom文件指定jar包目录进行引入" class="headerlink" title="方法一(pom文件指定jar包目录进行引入)"></a>方法一(pom文件指定jar包目录进行引入)</h1><ol><li>修改手动引入的包放在项目目录下，如lib目录</li></ol><blockquote><p>修改pom文件，引入依赖并且将scope设置为system</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/java/maven/20191216184231.png!www.zeze.info" alt="maven" title="www.zeze.info"></p><ol start="2"><li>同时配置maven打包插件</li></ol><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/java/maven/20191216184337.png!www.zeze.info" alt="maven" title="www.zeze.info"></p><h1 id="方法二（将jar包安装至本地仓库后使用pom文件直接引入）"><a href="#方法二（将jar包安装至本地仓库后使用pom文件直接引入）" class="headerlink" title="方法二（将jar包安装至本地仓库后使用pom文件直接引入）"></a>方法二（将jar包安装至本地仓库后使用pom文件直接引入）</h1><ol><li>将需要引入的jar包安装到本地maven仓库中；</li></ol><blockquote><p>使用一般方法引入依赖即可</p></blockquote><ol start="2"><li>先进入需要引入jar目录下，执行以下命令:<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn install:install-file -Dfile=chainsql-1.4.5.jar -DgroupId=org.peersafe -DartifactId=chainsql -Dversion=1.4.5 -Dpackaging=jar</span><br><span class="line">mvn install:install-file -Dfile=abi_chainsql.jar -DgroupId=org.peersafe -DartifactId=abi_chainsql -Dversion=1.0 -Dpackaging=jar</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>执行后在本地仓库中看到如下文件，说明安装成功</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/java/maven/20191216184519.png!www.zeze.info" alt="maven"></p><blockquote><p>这里需要注意Maven 安装 JAR 包的命令是：</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn install:install-file</span><br><span class="line">-Dfile=jar包的位置</span><br><span class="line">-DgroupId=pom文件里的groupId</span><br><span class="line">-DartifactId=pom文件里的artifactId</span><br><span class="line">-Dversion=pom文件里的version</span><br><span class="line">-Dpackaging=jar</span><br><span class="line"><span class="comment"># 例如这里chainsql-1.4.5.jar 文件放在了”D:\mytest\”中</span></span><br><span class="line"><span class="comment"># 则命令为：</span></span><br><span class="line">mvn install:install-file -Dfile=D:\mytest\chainsql-1.4.5.jar -DgroupId=org.peersafe -DartifactId=chainsql -Dversion=1.4.5 -Dpackaging=jar</span><br></pre></td></tr></table></figure><ol start="3"><li><p>pom文件添加依赖，即可成功引入jar包</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.peersafe<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>chainsql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.peersafe<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>abi_chainsql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>打包测试即可</p></li></ol><hr><p>去年今日此门中，人面桃花相映红。——崔护《题都城南庄》</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot</title>
      <link href="/springboot/springboot1/"/>
      <url>/springboot/springboot1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Boot学习-码云地址"><a href="#Spring-Boot学习-码云地址" class="headerlink" title="Spring Boot学习 码云地址"></a><strong><a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master" target="_blank" rel="external nofollow noopener noreferrer">Spring Boot学习</a></strong> 码云地址</h1><h2 id="工程配置"><a href="#工程配置" class="headerlink" title="工程配置"></a>工程配置</h2><ul><li><strong>demo_01</strong> : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_01" target="_blank" rel="external nofollow noopener noreferrer">自定义属性、随机数、多环境配置等</a></li><li><strong>demo_02</strong> : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_02" target="_blank" rel="external nofollow noopener noreferrer">2.0 新特性（一）：配置绑定全解析</a></li><li><strong>demo_03</strong> : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_03" target="_blank" rel="external nofollow noopener noreferrer">2.0 新特性（二）：新增事件ApplicationStartedEvent</a></li></ul><h2 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h2><ul><li><strong>demo_04</strong> : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_04" target="_blank" rel="external nofollow noopener noreferrer">构建一个较为复杂的RESTful API以及单元测试</a></li><li><strong>demo_05</strong> : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_05" target="_blank" rel="external nofollow noopener noreferrer">使用Thymeleaf模板引擎渲染web视图</a></li><li><strong>demo_06</strong> : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_06" target="_blank" rel="external nofollow noopener noreferrer">使用Freemarker模板引擎渲染web视图</a></li><li><strong>demo_07</strong> : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_07" target="_blank" rel="external nofollow noopener noreferrer">使用Velocity模板引擎渲染web视图</a></li><li><strong>demo_08</strong> : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_08" target="_blank" rel="external nofollow noopener noreferrer">使用beetle模板引擎渲染web视图</a></li><li><strong>demo_09</strong> : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_09" target="_blank" rel="external nofollow noopener noreferrer">使用Swagger2构建RESTful API</a></li><li><strong>demo_10</strong> : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_10" target="_blank" rel="external nofollow noopener noreferrer">统一异常处理</a></li></ul><h2 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h2><ul><li><strong>demo_11</strong> : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_11" target="_blank" rel="external nofollow noopener noreferrer">使用JdbcTemplate</a></li><li><strong>demo_12</strong> : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_12" target="_blank" rel="external nofollow noopener noreferrer">使用Spring-data-jpa简化数据访问层</a></li><li><strong>demo_13</strong> : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_13" target="_blank" rel="external nofollow noopener noreferrer">多数据源配置（一）：JdbcTemplate</a></li><li><strong>demo_14</strong> : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_14" target="_blank" rel="external nofollow noopener noreferrer">多数据源配置（二）：Spring-data-jpa</a></li><li><strong>demo_15</strong> : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_15" target="_blank" rel="external nofollow noopener noreferrer">使用redis</a></li><li><strong>demo_16</strong> : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_16" target="_blank" rel="external nofollow noopener noreferrer">MyBatis注解配置详解/事物</a></li></ul><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><ul><li><strong>demo_17</strong> : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_17" target="_blank" rel="external nofollow noopener noreferrer">使用@Scheduled创建定时任务</a></li><li><strong>demo_18</strong> : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_18" target="_blank" rel="external nofollow noopener noreferrer">使用@Async实现异步调用</a></li><li><strong>demo_19</strong> : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_19" target="_blank" rel="external nofollow noopener noreferrer">使用@Async实现异步调用：自定义线程池</a></li></ul><h2 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h2><ul><li><strong>demo_20</strong> : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_20" target="_blank" rel="external nofollow noopener noreferrer">使用AOP统一处理Web请求日志</a></li><li><strong>demo_21</strong>  : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_21" target="_blank" rel="external nofollow noopener noreferrer">使用log4j记录日志到MongoDB</a><h2 id="缓存支持"><a href="#缓存支持" class="headerlink" title="缓存支持"></a>缓存支持</h2></li><li><strong>demo_22</strong>  : <a href="https://gitee.com/zhangzeli/look_at_springboot/tree/master/demo_22" target="_blank" rel="external nofollow noopener noreferrer">注解配置与EhCache使用</a></li></ul><h2 id="待续-请持续关注"><a href="#待续-请持续关注" class="headerlink" title="待续 请持续关注"></a>待续 请持续关注</h2><h1 id="理想，能给天下不幸者以欢乐。-——-高尔基"><a href="#理想，能给天下不幸者以欢乐。-——-高尔基" class="headerlink" title="理想，能给天下不幸者以欢乐。 —— 高尔基"></a>理想，能给天下不幸者以欢乐。 —— 高尔基</h1><h1 id="博主博客点击观赏"><a href="#博主博客点击观赏" class="headerlink" title="博主博客点击观赏"></a><a href="http://www.zeze.info">博主博客点击观赏</a></h1><p><strong>有疑问或者商业合作可以加博主微信：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin">。一起交流</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七牛Robots正确的写法</title>
      <link href="/seo/index1/"/>
      <url>/seo/index1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="七牛云robots的正确写法"><a href="#七牛云robots的正确写法" class="headerlink" title="七牛云robots的正确写法"></a>七牛云robots的正确写法</h2><blockquote><p>配置了七牛静态存储，我们通常要修改一下robots.txt，目的是禁止蜘蛛抓取我们二级域名如img.zeze.info,而不让百度等搜索引擎收录我们的img.zeze.info的页面和文章，从而降低主域名zeze.com的权重。但是，我们又希望蜘蛛能抓取到我们的图片，如 </p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;img.zeze.info&#x2F;img&#x2F;qiniu&#x2F;qiniu.png!www.zeze.info</span><br></pre></td></tr></table></figure><p><code>本文中的robots.txt都是七牛绑定域名（七牛空间存储）根目录里的，不是你网站根目录啊</code></p><h2 id="七牛刷新预取（清除缓存的意思）并填写刷新文件"><a href="#七牛刷新预取（清除缓存的意思）并填写刷新文件" class="headerlink" title="七牛刷新预取（清除缓存的意思）并填写刷新文件"></a>七牛刷新预取（清除缓存的意思）并填写刷新文件</h2><blockquote><p>博主当初修改这个文件的时候，尴尬死了，删除了，重新上传，试了无数遍，都没改成功。后来才知道是缓存的原因，点击刷新预取</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/seo/20191212184258.png!www.zeze.info" alt="七牛云plus"></p><h2 id="修改robots-txt"><a href="#修改robots-txt" class="headerlink" title="修改robots.txt"></a>修改robots.txt</h2><blockquote><p>方法很简单，删除之前的robots.txt，重新上传新的robots.txt</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User-agent: Baiduspider</span><br><span class="line">Allow: &#x2F;img&#x2F;*</span><br><span class="line">Disallow: &#x2F;</span><br><span class="line">User-agent: 360Spider</span><br><span class="line">Allow: &#x2F;img&#x2F;*</span><br><span class="line">Disallow: &#x2F;</span><br><span class="line">User-agent: Baiduspider-image</span><br><span class="line">Allow: &#x2F;img&#x2F;*</span><br><span class="line">Disallow: &#x2F;</span><br><span class="line">User-agent: 360Spider-Image</span><br><span class="line">Allow: &#x2F;img&#x2F;*</span><br><span class="line">Disallow: &#x2F;</span><br><span class="line">User-agent: *</span><br><span class="line">Disallow: &#x2F;</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码，很明显，这里就不废话了。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># robots.txt generated at http:&#x2F;&#x2F;portal.qiniu.com</span><br><span class="line">User-agent: Baiduspider</span><br><span class="line">Allow: &#x2F;img*</span><br><span class="line">Disallow: &#x2F;</span><br><span class="line">User-agent: Sosospider</span><br><span class="line">Allow: &#x2F;img*</span><br><span class="line">Disallow: &#x2F;</span><br><span class="line">User-agent: sogou spider</span><br><span class="line">Allow: &#x2F;img*</span><br><span class="line">Disallow: &#x2F;</span><br><span class="line">User-agent: YodaoBot</span><br><span class="line">Allow: &#x2F;img*</span><br><span class="line">Disallow: &#x2F;</span><br><span class="line">User-agent: Googlebot</span><br><span class="line">Allow: &#x2F;img*</span><br><span class="line">Disallow: &#x2F;</span><br><span class="line">User-agent: Bingbot</span><br><span class="line">Allow: &#x2F;img*</span><br><span class="line">Disallow: &#x2F;</span><br><span class="line">User-agent: Slurp</span><br><span class="line">Allow: &#x2F;img*</span><br><span class="line">Disallow: &#x2F;</span><br><span class="line">User-agent: MSNBot</span><br><span class="line">Allow: &#x2F;img*</span><br><span class="line">Disallow: &#x2F;</span><br><span class="line">User-agent: googlebot-image</span><br><span class="line">Allow: &#x2F;img*</span><br><span class="line">Disallow: &#x2F;</span><br><span class="line">User-agent: googlebot-mobile</span><br><span class="line">Allow: &#x2F;img*</span><br><span class="line">Disallow: &#x2F;</span><br><span class="line">User-agent: yahoo-blogs&#x2F;v3.9</span><br><span class="line">Allow: &#x2F;img*</span><br><span class="line">Disallow: &#x2F;</span><br><span class="line">User-agent: psbot</span><br><span class="line">Allow: &#x2F;img*</span><br><span class="line">Disallow: &#x2F;</span><br><span class="line">User-agent: *</span><br><span class="line">Allow: &#x2F;img*</span><br><span class="line">Disallow: &#x2F;</span><br></pre></td></tr></table></figure><h2 id="百度站长平台检测"><a href="#百度站长平台检测" class="headerlink" title="百度站长平台检测"></a>百度站长平台检测</h2><blockquote><p>先进入<a href="https://ziyuan.baidu.com/linksubmit/index?site=http://www.zeze.info/" target="_blank" rel="external nofollow noopener noreferrer">百度站长平台</a><br> ，  没有添加链接的，先添加（博主添加了<a href="http://www.zeze.info）" target="_blank" rel="external nofollow noopener noreferrer">www.zeze.info）</a> 。</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/seo/20191212190356.png!www.zeze.info" alt="站长"></p><p>进去之后，点击检测并更新，多点几次，直到出现下面界面</p>]]></content>
      
      
      <categories>
          
          <category> SEO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七牛云图床搭建</title>
      <link href="/tuchuang/index/"/>
      <url>/tuchuang/index/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="七牛云图床和Markdown使用"><a href="#七牛云图床和Markdown使用" class="headerlink" title="七牛云图床和Markdown使用"></a>七牛云图床和Markdown使用</h1><h2 id="图床是什么"><a href="#图床是什么" class="headerlink" title="图床是什么"></a>图床是什么</h2><blockquote><p>图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。来自百度百科</p></blockquote><h2 id="为什么要使用图床？"><a href="#为什么要使用图床？" class="headerlink" title="为什么要使用图床？"></a>为什么要使用图床？</h2><blockquote><p>目前的网站、博客等站点中，除了大型网站，官方网站等会自建图片、视频等专用于存放文件的服务器。其他站点如果是这类文件很多，而且具有较强的依赖性质(服务迁移等情况)的话，那么将是一件复杂的事情，因为每个站点的文件存储方式不同。目前主流站点文章的写作方案是Markdown格式，Markdown是一种纯文本格式的标记语言。通过简单的标记语法,它可以使普通文本内容具有一定的格式。编写Markdown格式的文章，往文章中插入图片等资源是一个问题，因为如果你使用了本地的存储，那么文章发表后，图片链接都需要调整。基于上述情况，我们有了一种只要有网络，就能实现图片文件固定链接访问的需求。因此，图床服务是较完美的选择，</p></blockquote><p><strong>图床对比：</strong></p><ul><li>微博图床类，获取url方式：经济实惠，但稳定性差，近期微博图床开启了防盗链，大拨外链图片不能正常使用</li><li>cdn加速，公有云类：需要购买云存储空间，例如阿里云对象存储oss、腾讯云对象存储cos、微博图床、七牛云图床、又拍云图床等</li><li>自建图床：如果是仅仅个人使用的话会费劲又费钱</li><li>国外图床：例如像Github图床这类，既不收费用户也多，但唯一的不足就是墙墙墙！</li></ul><h2 id="七牛云图床介绍"><a href="#七牛云图床介绍" class="headerlink" title="七牛云图床介绍"></a>七牛云图床介绍</h2><blockquote><p>选择七牛云图床在于七牛云是专注于打造数据为核心的场景化Pass服务商，在静态资源的资源分发，加载速度、只能压缩方面可能会相对好一些，当然各个大厂都有其专注点，本文没有针对性。对于小站点来说，建议选择的是七牛云，七牛云推出了更多的<a href="https://blog.qiniu.com/archives/8874" target="_blank" rel="external nofollow noopener noreferrer">CDN回源优惠政策</a>，有10G免费空间可以选择（少花钱当然更好）</p></blockquote><h2 id="七牛云图床的使用"><a href="#七牛云图床的使用" class="headerlink" title="七牛云图床的使用"></a>七牛云图床的使用</h2><h3 id="账号注册"><a href="#账号注册" class="headerlink" title="账号注册"></a>账号注册</h3><blockquote><p>使用前需要注册一个七牛云的账号并进行实名认证，实名认证需要一定的审核时间，注册地址为：<a href="https://portal.qiniu.com/signup?code=1hjd1b4ulyyqa" target="_blank" rel="external nofollow noopener noreferrer">邀请连接</a></p></blockquote><h3 id="创建存储服务"><a href="#创建存储服务" class="headerlink" title="创建存储服务"></a>创建存储服务</h3><blockquote><p>登录到控制台，新建一个存储空间，输入存储空间的名称，选择存储区域，本存储空间是用于站点图床，所以选择访问控制类型为公开空间，如下所示</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/qiniu/%E6%96%B0%E5%BB%BA%E7%A9%BA%E9%97%B4.png!www.zeze.info" alt="七牛云新建"></p><h3 id="配置域名解析"><a href="#配置域名解析" class="headerlink" title="配置域名解析"></a>配置域名解析</h3><blockquote><p>配置完成后跳转到域名管理界面，显示了一个cname记录，这就是配置好七牛云存储提供的的cdn加速域名，zeze.info的域名服务器是阿里云旗下的万网，这里配置的img.zeze.info域名和对应的cname记录需要在阿里云的域名控制台中添加一条解析记录</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/qiniu/cname.png!www.zeze.info" alt="域名解析"></p><blockquote><p>解析记录添加完成后，需要等待一段时间才能生效</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/qiniu/ping.png!www.zeze.info" alt="ping测试"></p><h3 id="配置外链默认域名"><a href="#配置外链默认域名" class="headerlink" title="配置外链默认域名"></a>配置外链默认域名</h3><blockquote><p>在存储空间列表，内容管理，选择外链默认域名为配置的域名而不是测试域名</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info//picgo.png!www.zeze.info" alt="picgo"></p><blockquote><p>其中图床的存储区域代号，可以参照<a href="https://developer.qiniu.com/kodo/manual/1671/region-endpoint" target="_blank" rel="external nofollow noopener noreferrer">七牛云存储区域说明填写</a></p></blockquote><table><thead><tr><th align="center">存储区域</th><th align="center">地域简称</th><th align="center">上传域名</th></tr></thead><tbody><tr><td align="center">华东</td><td align="center">z0</td><td align="center">服务器端上传：http(s)://up.qiniup.com <br>客户端上传： http(s)://upload.qiniup.com</td></tr><tr><td align="center">华北</td><td align="center">z1</td><td align="center">服务器端上传：http(s)://up-z1.qiniup.com<br>客户端上传：http(s)://upload-z1.qiniup.com</td></tr><tr><td align="center">华南</td><td align="center">z2</td><td align="center">服务器端上传：http(s)://up-z2.qiniup.com<br>客户端上传：http(s)://upload-z2.qiniup.com</td></tr><tr><td align="center">北美</td><td align="center">na0</td><td align="center">服务器端上传：http(s)://up-na0.qiniup.com<br>客户端上传：http(s)://upload-na0.qiniup.com</td></tr><tr><td align="center">东南亚</td><td align="center">as0</td><td align="center">服务器端上传：http(s)://up-as0.qiniup.com<br>客户端上传：http(s)://upload-as0.qiniup.com</td></tr></tbody></table><p>配置完成后，在上传区点击选择图片或者拖拽进行上传，链接格式选择Markdown</p><h2 id="小结👍-👍"><a href="#小结👍-👍" class="headerlink" title="小结👍 👍"></a>小结👍 👍</h2><blockquote><p>图床很好的解决了Markdown文件图片存储的问题，而且还能有效减少我们自己站点服务器的资源</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 图床 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>站点提交搜索引擎</title>
      <link href="/hexo/hexo2/"/>
      <url>/hexo/hexo2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="seo优化"><a href="#seo优化" class="headerlink" title="seo优化"></a>seo优化</h2><p>推广是一个烦人的事情啊喂，特别是对于我们搞技术的来说，可能就不擅长推广，那么怎么才能让别人知道我们呢，我们就要想办法让别人通过搜索就可以搜索到你博客的内容，给我们带来自然流量，这就需要seo优化,让我们的站点变得对搜索引擎友好</p><blockquote><p>SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”。SEO是指通过站内优化比如网站结构调整、网站内容建设、网站代码优化等以及站外优化。</p></blockquote><h2 id="让Google和百度收录你的站点"><a href="#让Google和百度收录你的站点" class="headerlink" title="让Google和百度收录你的站点"></a>让Google和百度收录你的站点</h2><blockquote><p>我们首先要做的就是让各大搜索引擎收录你的站点，我们在刚建站的时候各个搜索引擎是没有收录我们网站的，在搜索引擎中输入<code>site:&lt;域名&gt;</code>,如果如下图所示就是说明我们的网站并没有被百度收录。我们可以直接点击下面的“网址提交”来提交我们的网站</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/seo/baidu.png!www.zeze.info" alt="seo"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/seo/google.png!www.zeze.info" alt></p><h2 id="验证网站所有权"><a href="#验证网站所有权" class="headerlink" title="验证网站所有权"></a>验证网站所有权</h2><blockquote><p>登录<a href="https://ziyuan.baidu.com/linksubmit/index" target="_blank" rel="external nofollow noopener noreferrer">百度站长平台</a>只要有百度旗下的账号就可以登录，登录成功之后在站点管理中点击添加网站然后输入你的站点地址，建议输入的网站为www开头的</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/seo/20191213104214.png!www.zeze.info" alt="提交站点"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/seo/20191213104422.png!www.zeze.info" alt="google-console"></p><blockquote><p>cname验证。在DNS厂商那里选择按照要求配置解析规则</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/seo/20191213104505.png!www.zeze.info" alt="验证"></p><h2 id="生成网站地图"><a href="#生成网站地图" class="headerlink" title="生成网站地图"></a>生成网站地图</h2><blockquote><p>我们需要使用npm自动生成网站的sitemap，然后将生成的sitemap提交到百度和其他搜索引擎</p></blockquote><h2 id="向百度提交链接"><a href="#向百度提交链接" class="headerlink" title="向百度提交链接"></a>向百度提交链接</h2><ol><li>主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。</li><li>自动推送：最为便捷的提交方式，请将自动推送的JS代码部署在站点的每一个页面源代码中，部署代码的页面在每次被浏览时，链接会被自动推送给百度。可以与主动推送配合使用。</li><li>sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送。</li><li>手动提交：一次性提交链接给百度，可以使用此种方式。</li></ol><h2 id="优化你的URL"><a href="#优化你的URL" class="headerlink" title="优化你的URL"></a>优化你的URL</h2><p>seo搜索引擎优化认为，网站的最佳结构是<strong>用户从首页点击三次就可以到达任何一个页面</strong>这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章</p><h2 id="其他SEO优化"><a href="#其他SEO优化" class="headerlink" title="其他SEO优化"></a>其他SEO优化</h2><blockquote><p>SEO优化应该说是一个收益延迟的行为，可能你做的优化短期内看不到什么效果，但是一定要坚持，seo优化也是有很深的可以研究的东西，从我们最初的网站设计，和最基础的标签的选择都有很大的关系，网站设计就如我们刚刚说的，要让用户点击三次可以到达网站的任何一个页面，要增加高质量的外链，增加相关推荐（比如说我们经常见到右侧本站的最高阅读的排名列表），然后就是给每一个页面加上keyword和描述</p></blockquote><blockquote><p>在代码中，我们应该写出能让浏览器识别的语义化HTML，这样有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；并且对外链设置nofollow标签，避免spider爬着爬着就爬出去了（减少网站的跳出率），并且我们要尽量在一些比较大的网站增加我们站点的曝光率，因为spider会经常访问大站，比如我们在掘金等技术社区发表文章中带有我们的站点，这样spider是很有可能爬到我们中的站点的，so…</p></blockquote><ul><li>外链的推广度、数量和质量</li><li>网站的内链足够强大</li><li>网站的原创质量</li><li>网站的年龄时间</li><li>网站的更新频率（更新次数越多越好）</li><li>网站的服务器</li><li>网站的流量：流量越高网站的权重越高</li><li>网站的关键词排名：关键词排名越靠前，网站的权重越高</li><li>网站的收录数量：网站百度收录数量越多，网站百度权重越高</li><li>网站的浏览量及深度：用户体验越好，网站的百度权重越高</li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
          <category> SEO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx规则匹配优先级</title>
      <link href="/nginx/001-nginx/"/>
      <url>/nginx/001-nginx/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Location-匹配规则"><a href="#Location-匹配规则" class="headerlink" title="Location 匹配规则"></a>Location 匹配规则</h2><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">[=|~|~*|^~] /uri</span>/ &#123; … &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="right">模式</th><th align="right">含义</th></tr></thead><tbody><tr><td align="right">location = /uri</td><td align="right">= 表示精确匹配，只有完全匹配上才能生效</td></tr><tr><td align="right">location ^~ /uri</td><td align="right">^~ 开头对URL路径进行前缀匹配，并且在正则之前。</td></tr><tr><td align="right">location ~ pattern</td><td align="right">开头表示区分大小写的正则匹配</td></tr><tr><td align="right">location ~* pattern</td><td align="right">开头表示不区分大小写的正则匹配</td></tr><tr><td align="right">location /uri</td><td align="right">不带任何修饰符，也表示前缀匹配，但是在正则匹配之后</td></tr><tr><td align="right">location /</td><td align="right">通用匹配，任何未匹配到其它location的请求都会匹配到，相当于switch中的default</td></tr></tbody></table><p><code>前缀匹配时，Nginx 不对 url 做编码，因此请求为 /static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）</code></p><h2 id="多个-location-配置的情况下匹配顺序为"><a href="#多个-location-配置的情况下匹配顺序为" class="headerlink" title="多个 location 配置的情况下匹配顺序为:"></a>多个 location 配置的情况下匹配顺序为:</h2><ul><li>首先精确匹配 =</li><li>其次前缀匹配 ^~</li><li>其次是按文件中顺序的正则匹配</li><li>然后匹配不带任何修饰的前缀匹配。</li><li>最后是交给 / 通用匹配</li></ul><p>当有匹配成功时候，停止匹配，按当前匹配规则处理请求<br><strong>注意</strong>：前缀匹配，如果有包含关系时，按最大匹配原则进行匹配。比如在前缀匹配：location /dir01与location /dir01/dir02，如有请求<a href="http://localhost/dir01/dir02/file" target="_blank" rel="external nofollow noopener noreferrer">http://localhost/dir01/dir02/file</a> 将最终匹配到location /dir01/dir02</p><p>例子，有如下匹配规则：</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">= / &#123;</span></span><br><span class="line"><span class="title">   echo</span> <span class="string">"规则A"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">location</span> <span class="title">= /login</span> &#123;</span><br><span class="line">   echo <span class="string">"规则B"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">location</span> <span class="title">^~ /static</span>/ &#123;</span><br><span class="line">   echo <span class="string">"规则C"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">location</span> <span class="title">^~ /static</span>/files &#123;</span><br><span class="line">    echo <span class="string">"规则X"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">location</span> <span class="title">~ \.(gif</span>|jpg|png|js|css)$ &#123;</span><br><span class="line">   echo <span class="string">"规则D"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">location</span> <span class="title">~* \.png</span>$ &#123;</span><br><span class="line">   echo <span class="string">"规则E"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">location</span> <span class="title">/img</span> &#123;</span><br><span class="line">    echo <span class="string">"规则Y"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">location</span> <span class="title">/ &#123;</span></span><br><span class="line"><span class="title">   echo</span> <span class="string">"规则F"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么产生的效果如下：</p><ul><li>访问根目录 /，比如 <a href="http://localhost/" target="_blank" rel="external nofollow noopener noreferrer">http://localhost/</a> 将匹配 规则A</li><li>访问<a href="http://localhost/login将匹配" target="_blank" rel="external nofollow noopener noreferrer">http://localhost/login将匹配</a> 规则B，<a href="http://localhost/register则匹配" target="_blank" rel="external nofollow noopener noreferrer">http://localhost/register则匹配</a> 规则F</li><li>访问 <a href="http://localhost/static/a.html" target="_blank" rel="external nofollow noopener noreferrer">http://localhost/static/a.html</a> 将匹配 规则C</li><li>访问<a href="http://localhost/static/files/a.exe将匹配" target="_blank" rel="external nofollow noopener noreferrer">http://localhost/static/files/a.exe将匹配</a> 规则X，虽然 规则C也能匹配到，但因为最大匹配* 原则，最终选中了 规则X。你可以测试下，去掉规则 X ，则当前 URL 会匹配上 规则C。</li><li>访问 <a href="http://localhost/a.gif" target="_blank" rel="external nofollow noopener noreferrer">http://localhost/a.gif</a>, <a href="http://localhost/b.jpg将匹配" target="_blank" rel="external nofollow noopener noreferrer">http://localhost/b.jpg将匹配</a> 规则D 和 规则 E ，但是 规则 D 顺序* 优先，规则 E 不起作用，而<a href="http://localhost/static/c.png" target="_blank" rel="external nofollow noopener noreferrer">http://localhost/static/c.png</a> 则优先匹配到 规则 C</li><li>访问<a href="http://localhost/a.PNG则匹配" target="_blank" rel="external nofollow noopener noreferrer">http://localhost/a.PNG则匹配</a> 规则 E ，而不会匹配 规则 D ，因为 规则 E不区分大小写。</li><li>访问 <a href="http://localhost/img/a.gif" target="_blank" rel="external nofollow noopener noreferrer">http://localhost/img/a.gif</a> 会匹配上 规则D,虽然 规则Y 也可以匹配上，但是因为正则匹配优先，而忽略了 规则Y。</li><li>访问 <a href="http://localhost/img/a.tiff会匹配上规则Y。" target="_blank" rel="external nofollow noopener noreferrer">http://localhost/img/a.tiff会匹配上规则Y。</a></li><li>访问<a href="http://localhost/category/id/1111" target="_blank" rel="external nofollow noopener noreferrer">http://localhost/category/id/1111</a> 则最终匹配到规则 F ，因为以上规则都不匹配，这个时候应该是 Nginx 转发请求给后端应用服务器，比如 FastCGI（php），tomcat（jsp），Nginx 作为反向代理服务器存在。</li></ul><p>所以实际使用中，笔者觉得至少有三个匹配规则定义，如下：</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。</span></span><br><span class="line"><span class="comment"># 这里是直接转发给后端应用服务器了，也可以是一个静态首页</span></span><br><span class="line"><span class="comment"># 第一个必选规则</span></span><br><span class="line"><span class="keyword">location</span> <span class="title">= / &#123;</span></span><br><span class="line"><span class="title">    proxy_pass</span> http://tomcat:<span class="number">8080</span>/index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个必选规则是处理静态文件请求，这是 nginx 作为 http 服务器的强项</span></span><br><span class="line"><span class="comment"># 有两种配置模式，目录匹配或后缀匹配，任选其一或搭配使用</span></span><br><span class="line"><span class="keyword">location</span> <span class="title">^~ /static</span>/ &#123;</span><br><span class="line">    root /webroot/static/;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">location</span> <span class="title">~* \.(gif</span>|jpg|jpeg|png|css|js|ico)$ &#123;</span><br><span class="line">    root /webroot/res/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三个规则就是通用规则，用来转发动态请求到后端应用服务器</span></span><br><span class="line"><span class="comment"># 非静态文件请求就默认是动态请求，自己根据实际把握</span></span><br><span class="line"><span class="comment"># 毕竟目前的一些框架的流行，带.php、.jsp后缀的情况很少了</span></span><br><span class="line"><span class="keyword">location</span> <span class="title">/ &#123;</span></span><br><span class="line"><span class="title">    proxy_pass</span> http://tomcat:<span class="number">8080</span>/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rewrite-语法"><a href="#rewrite-语法" class="headerlink" title="rewrite 语法"></a>rewrite 语法</h2><ul><li>last – 基本上都用这个 Flag</li><li>break – 中止 Rewirte，不再继续匹配</li><li>redirect – 返回临时重定向的 HTTP 状态 302</li><li>permanent – 返回永久重定向的 HTTP 状态 301</li></ul><ol><li>下面是可以用来判断的表达式：<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">-f 和 <span class="title">!-f</span> 用来判断是否存在文件</span><br><span class="line">-d 和 <span class="title">!-d</span> 用来判断是否存在目录</span><br><span class="line">-e 和 <span class="title">!-e</span> 用来判断是否存在文件或目录</span><br><span class="line">-<span class="keyword">x</span> 和 <span class="title">!-x</span> 用来判断文件是否可执行</span><br></pre></td></tr></table></figure></li><li>下面是可以用作判断的全局变量<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">例：http:<span class="comment">//localhost:88/test1/test2/test.php?k=v</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$host</span>：localhost</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$server</span>_port：88</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$request</span>_uri：/test1/test2/test.php?k=v</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$document</span>_uri：/test1/test2/test.php</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$document</span>_root：D:\nginx/html</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$request</span>_filename：D:\nginx/html/test1/test2/test.php</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="redirect-语法"><a href="#redirect-语法" class="headerlink" title="redirect 语法"></a>redirect 语法</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.zeze.<span class="literal">info</span>;</span><br><span class="line">    <span class="attribute">index</span> index.html index.php;</span><br><span class="line">    <span class="attribute">root</span> html;</span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$http_host</span> !<span class="regexp">~ "^star\.igrow\.cn$")</span> &#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^(.*)</span> http://star.igrow.cn<span class="variable">$1</span> <span class="literal">redirect</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* \.(gif|jpg|swf)$</span> &#123;</span><br><span class="line">    <span class="attribute">valid_referers</span> <span class="literal">none</span> <span class="literal">blocked</span> start.igrow.cn sta.igrow.cn;</span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$invalid_referer</span>) &#123;</span><br><span class="line">       <span class="attribute">rewrite</span><span class="regexp"> ^/</span> http://<span class="variable">$host</span>/logo.png;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="根据文件类型设置过期时间"><a href="#根据文件类型设置过期时间" class="headerlink" title="根据文件类型设置过期时间"></a>根据文件类型设置过期时间</h2><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">location ~* \.(js|<span class="type">css</span>|<span class="type">jpg</span>|<span class="type">jpeg</span>|<span class="type">gif</span>|<span class="type">png</span>|<span class="type">swf</span>)$ &#123;</span><br><span class="line">    <span class="keyword">if</span> (-f $request_filename) &#123;</span><br><span class="line">        expires <span class="number">1</span>h;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="禁止访问某个目录"><a href="#禁止访问某个目录" class="headerlink" title="禁止访问某个目录"></a>禁止访问某个目录</h2><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">~* \.(txt</span>|doc)$&#123;</span><br><span class="line">    root /data/www/wwwroot/linuxtone/test;</span><br><span class="line">    <span class="keyword">deny</span> all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整demo"><a href="#完整demo" class="headerlink" title="完整demo"></a>完整demo</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">upstream</span> appzuul &#123;</span><br><span class="line">   <span class="attribute">server</span> <span class="number">192</span>.<span class="number">168</span>.*.*:<span class="number">18600</span>;</span><br><span class="line">   <span class="attribute">server</span> <span class="number">192</span>.<span class="number">168</span>.*.*:<span class="number">18600</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">   <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">   <span class="attribute">server_name</span> a.cooper.com   b.cooper.com;</span><br><span class="line">   <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)$</span> https://a.cooper.com/<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>      <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> a.cooper.com b.cooper.com;</span><br><span class="line">    <span class="attribute">root</span>   /opt/web_html/auth.100credit.com;</span><br><span class="line">    <span class="attribute">index</span> login index.html index.htm login.html applicationMasterPage.html;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>      /opt/nginx-<span class="number">1</span>.<span class="number">4</span>.<span class="number">7</span>/conf/ssl/100credit.com.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  /opt/nginx-<span class="number">1</span>.<span class="number">4</span>.<span class="number">7</span>/conf/ssl/100credit.com.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span>   <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_protocols</span>  SSLv3 TLSv1;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span>  ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span> logs/a.cooper.com_access.log;</span><br><span class="line">    <span class="attribute">error_log</span>  logs/a.cooper.com_error.log;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span>  <span class="number">404</span>  /view/<span class="number">404</span>.html;</span><br><span class="line">    <span class="comment">#重定向首页</span></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ /base/</span>&#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/base/login\.html</span> /<span class="comment">#/login permanent;</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">#前端目录调整</span></span><br><span class="line">    location<span class="regexp"> ^~</span> /v/</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/v/(.*)$</span> /<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 静态资源配置方式一</span></span><br><span class="line">    <span class="attribute">location</span>  / &#123;</span><br><span class="line">        <span class="attribute">root</span> /opt/web_html/apiservice.100credit.com;</span><br><span class="line">        <span class="attribute">index</span>  index.html;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 静态资源配置方式二</span></span><br><span class="line">   <span class="comment"># location ~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|js|css|json|md|woff)$</span></span><br><span class="line">   <span class="comment"># &#123;</span></span><br><span class="line">    <span class="comment">#    root   /opt/web_html/auth.100credit.com;</span></span><br><span class="line">    <span class="comment">#    index  index.html index.htm applicationMasterPage.html;</span></span><br><span class="line">   <span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /api/</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>        Host  <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>        X-Real-IP  <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>        REMOTE-HOST <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>        X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span>              http://appzuul;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /zuul/api/</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>        Host  <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>        X-Real-IP  <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>        REMOTE-HOST <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>        X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span>              http://appzuul;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 网站搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彻底了解&quot;||&quot;和&quot;&amp;&amp;&quot;</title>
      <link href="/javaScript/cacl/cacl1/"/>
      <url>/javaScript/cacl/cacl1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="在if判断中的用法："><a href="#在if判断中的用法：" class="headerlink" title="在if判断中的用法："></a>在if判断中的用法：</h2><ol><li><p>||的用法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">2</span> &gt; <span class="number">1</span> || <span class="number">2</span> &gt; <span class="number">5</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'www.zeze.info'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“<strong>||</strong>”的用法是如果前面的表达式满足了那么就不会再走到下一个表达式，之间就会进入到if的执行语句中。（PS：{}里面的内容为执行语句内容）<br>如果说俩个条件都不满足那么就不会走进这个执行语句当中去。</p></li><li><p>&amp;&amp;的用法：</p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">2</span> &gt; <span class="number">1</span> &amp;&amp; <span class="number">2</span> &gt; <span class="number">6</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'wx:twobixiaoxin'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“<strong>&amp;&amp;</strong>”的用法是如果前面的表达式满足了，那么再去判断下一个，只有全部的表达式满足条件了才会进入到if的执行语句中。<br>上面的代码虽然2&gt;1是满足的，但是2&gt;6是不满足的，所以是不会进入到if的执行语句中的。</p><h2 id="简化三目运算符和if语句："><a href="#简化三目运算符和if语句：" class="headerlink" title="简化三目运算符和if语句："></a>简化三目运算符和if语句：</h2><p>实战场景模拟：</p><p>我们有一个变量是用来接收localStorage里面的数据的，但是如果说localStorage里面没有数据那么我们就给他赋予一个空数组。<br>用三目运算符我们可以这么来写：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> localStorageMessage = (localStorage.getItem(<span class="string">'test'</span>))? localStorage.getItem(<span class="string">'test'</span>): [];</span><br></pre></td></tr></table></figure><p>如果说用短路运算符我们可以这么写：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> localStorageMessage = localStorage.getItem(<span class="string">'test'</span>) || [];</span><br></pre></td></tr></table></figure><p>这样在前面一个值取回的为空的时候就会默认赋值为[]了。</p><p>关于“<strong>||</strong>”和“<strong>&amp;&amp;</strong>”妙用的秘诀大家只要记住它的执行顺序即可：  </p><ol><li>&amp;&amp;运算符在前一个表达式为true的时候才会继续往下一个走。否就止步于此。</li><li>||运算符在前一个表达式为true的时候就直接止步于此了。只有当前一个表达式为false的时候才会继续往下走。</li></ol><p>你如果还是记不住它的执行流程是如何的那也可以这样记：</p><ol><li>关于&amp;&amp;从前至后的顺序去遍历表达式，遇到false的表达式停止并返回此表达式。如果全都为true，那么就返回最后一个。</li><li>关于||从前至后的顺序去遍历表达式，遇到true的表达式停止并返回此表达式。如果全都为false，那么就返回最后一个。</li></ol><p><strong>有疑问或者商业合作可以加博主微信：<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img.zeze.info/img/about/wx.jpg!www.zeze.info" alt="twobixiaoxin">。一起交流</strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> js运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo(细节)： 一篇文章多个 Categories</title>
      <link href="/hexo/hexo_1/"/>
      <url>/hexo/hexo_1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  <br><code>在很多情况下，我们希望在 Hexo 中写的一篇文章能够同时属于多个分类，例如我写一篇 《Servlet笔记》，我既想将它放在 Java 这个分类中，又想将它放入 Servlet 这个分类。</code></p><h2 id="子分类"><a href="#子分类" class="headerlink" title="子分类"></a>子分类</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Java</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Servlet</span></span><br></pre></td></tr></table></figure><p>同样的作用我们也可以这样写。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span> <span class="string">[Java,</span> <span class="string">Servlet]</span></span><br></pre></td></tr></table></figure><p>上面两种方法最终效果一样，都是将文章放在了一个子分类的目录下，效果下。</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">├── <span class="keyword">java</span></span><br><span class="line"><span class="keyword">│ </span>  ├── Servlet</span><br></pre></td></tr></table></figure><h2 id="多个分类"><a href="#多个分类" class="headerlink" title="多个分类"></a>多个分类</h2><p>如果我们的要求是将文章同时分到多个不同的分类中呢，我们应该这样：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="string">-[Java]</span></span><br><span class="line">  <span class="string">-[Servlet]</span></span><br></pre></td></tr></table></figure><p>这样，就可以将上面的文章分类到 Java 和 Servlet 这两个不同的目录中了。<br>扩展一下，如果我们将其分类到 Java/Servlet 和 Programming 两个不同的目录下，我们应该如下写：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="string">-[Java,</span> <span class="string">Servlet]</span></span><br><span class="line">  <span class="string">-[Programming]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git(常用命令清单)</title>
      <link href="/git/gitcommand/"/>
      <url>/git/gitcommand/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="常用-Git-命令清单"><a href="#常用-Git-命令清单" class="headerlink" title="常用 Git 命令清单"></a>常用 Git 命令清单</h1><h2 id="1、增加-删除文件"><a href="#1、增加-删除文件" class="headerlink" title="1、增加/删除文件"></a>1、增加/删除文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [file1] [file2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加指定目录到暂存区，包括子目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [dir]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add -p</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm [file1] [file2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git mv [file-original] [file-renamed]</span></span><br></pre></td></tr></table></figure><h2 id="2、代码提交"><a href="#2、代码提交" class="headerlink" title="2、代码提交"></a>2、代码提交</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区的指定文件到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit [file1] [file2] ... -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交时显示所有diff信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend [file1] [file2] ...</span></span><br></pre></td></tr></table></figure><h2 id="3、分支"><a href="#3、分支" class="headerlink" title="3、分支"></a>3、分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支(*代表当前所在分支)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支和远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，但依然停留在当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch-name]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，并切换到该分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向指定commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch] [commit]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --track [branch] [remote-branch]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到指定分支，并更新工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [branch-name]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到上一个分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并指定分支到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge [branch]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择一个commit，合并进当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick [commit]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete [branch-name]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr [remote/branch]</span></span><br></pre></td></tr></table></figure><h2 id="4、标签"><a href="#4、标签" class="headerlink" title="4、标签"></a>4、标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在当前commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在指定commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag] [commit]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除本地tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -d [tag]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/[tagName]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看tag信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [tag]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交指定tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [tag]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交所有tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --tags</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向某个tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch] [tag]</span></span><br></pre></td></tr></table></figure><h2 id="5、查看信息"><a href="#5、查看信息" class="headerlink" title="5、查看信息"></a>5、查看信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示有变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的版本历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索提交历史，根据关键词</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -S [keyword]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，其<span class="string">"提交说明"</span>必须符合搜索条件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --grep feature</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --follow [file]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git whatchanged [file]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件相关的每一次diff</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p [file]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示过去5次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -5 --pretty --oneline</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git shortlog -sn</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git blame [file]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和工作区的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和上一个commit的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached [file]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示两次提交之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff [first-branch]...[second-branch]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示今天你写了多少行代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交的元数据和内容变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交发生变化的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show --name-only [commit]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交时，某个文件的内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]:[filename]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的最近几次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure><h2 id="6、远程同步"><a href="#6、远程同步" class="headerlink" title="6、远程同步"></a>6、远程同步</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载远程仓库的所有变动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch [remote]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个远程仓库的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show [remote]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加一个新的远程仓库，并命名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add [shortname] [url]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull [remote] [branch]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传本地指定分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [branch]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --force</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送所有分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --all</span></span><br></pre></td></tr></table></figure><h2 id="7、撤销"><a href="#7、撤销" class="headerlink" title="7、撤销"></a>7、撤销</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的指定文件到工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [file]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [commit] [file]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的所有文件到工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout .</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [file]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [commit]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard [commit]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --keep [commit]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git revert [commit]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> hexo </tag>
            
            <tag> Git常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 基本知识</title>
      <link href="/git/index/"/>
      <url>/git/index/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="git与github有什么区别呢"><a href="#git与github有什么区别呢" class="headerlink" title="git与github有什么区别呢?"></a>git与github有什么区别呢?</h1><ol><li>git(工具)是一个版本控制工具</li><li>github（社区）是一个用git做版本控制的项目托管平台，并附带交友分享功能。。类似的平台还有bitbucket、oschina的码云这里写图片描述（逗逼名字）。 这些平台基本都是以开源项目著称的，当然也提供一定的收费私有化托管服务。 当然（私有化），估计大家还听说过coding、gitlab、gogs，这些都是做一些私有化项目托管的平台。gitlab、gogs都是开源的git托管平台，可以自己私有化部署。</li></ol><h1 id="git和svn的区别"><a href="#git和svn的区别" class="headerlink" title="git和svn的区别"></a>git和svn的区别</h1><ol><li>svn是一个中心化的版本控制工具</li><li>git是一个去中心化的分布式版本控制工具</li></ol><h1 id="使用GitHub"><a href="#使用GitHub" class="headerlink" title="使用GitHub"></a>使用GitHub</h1><h2 id="1-注册账号"><a href="#1-注册账号" class="headerlink" title="1.注册账号"></a>1.注册账号</h2><p>使用github首先得 <a href="https://github.com/" target="_blank" rel="external nofollow noopener noreferrer">注册个账号</a>,具体的流程就不演示了</p><h2 id="2-新建仓库"><a href="#2-新建仓库" class="headerlink" title="2.新建仓库"></a>2.新建仓库</h2><p>点击New Repository菜单，进入创建仓库界面，下面的内容请看仔细：<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://www.zeze.info/images/git/new-repository.png" alt="github新建仓库"><br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://www.zeze.info/images/git/form-repository.png" alt="github新建仓库"></p><h1 id="Github-创建公钥-SSH-key"><a href="#Github-创建公钥-SSH-key" class="headerlink" title="Github 创建公钥 SSH key"></a>Github 创建公钥 SSH key</h1><h2 id="1-生产新的SSH-key-邮箱替换为自己注册github的注册邮箱"><a href="#1-生产新的SSH-key-邮箱替换为自己注册github的注册邮箱" class="headerlink" title="1.生产新的SSH key:(邮箱替换为自己注册github的注册邮箱)"></a>1.生产新的SSH key:(邮箱替换为自己注册github的注册邮箱)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen  -t   rsa   -C  <span class="string">"853089986@qq.com"</span></span><br></pre></td></tr></table></figure><h2 id="2-将生产好的key添加到github"><a href="#2-将生产好的key添加到github" class="headerlink" title="2.将生产好的key添加到github"></a>2.将生产好的key添加到github</h2><ol><li>登陆到你的Github，进入settings</li><li>如下如操作<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://www.zeze.info/images/git/ssh-git.png" alt="增加key"><br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://www.zeze.info/images/git/add-key.png" alt="增加key"></li><li><strong>title</strong>:可以顺便填名字<br><strong>key</strong>:在Key文本框里粘贴id_rsa.pub文件的内容<br>点击 <strong>add ssh key</strong> 配置完成  </li></ol><h2 id="3-测试是否配置成功"><a href="#3-测试是否配置成功" class="headerlink" title="3.测试是否配置成功"></a>3.测试是否配置成功</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line"><span class="comment">#配置成功标志</span></span><br><span class="line"><span class="comment">#Hi xxxxxx!You've successfully authenticated,but Gitub does not provide shell access.</span></span><br></pre></td></tr></table></figure><h1 id="使用git在本地建立的项目更新到Github"><a href="#使用git在本地建立的项目更新到Github" class="headerlink" title="使用git在本地建立的项目更新到Github"></a>使用git在本地建立的项目更新到Github</h1><h2 id="Git设置提交代码时的用户信息"><a href="#Git设置提交代码时的用户信息" class="headerlink" title="Git设置提交代码时的用户信息:"></a>Git设置提交代码时的用户信息:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"xxxxxx"</span></span><br><span class="line">git config --global user.email <span class="string">"xxxxxx@qq.com"</span></span><br></pre></td></tr></table></figure><h2 id="创建-git-仓库"><a href="#创建-git-仓库" class="headerlink" title="创建 git 仓库:"></a>创建 git 仓库:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir <span class="built_in">test</span>    <span class="comment"># 首先在本地新建文件夹</span></span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">test</span>       <span class="comment"># 进入这个文件夹</span></span><br><span class="line">git init     <span class="comment"># 在当前目录初始化一个git仓库</span></span><br><span class="line">//git init [project-name]   新建一个目录，将其初始化为Git代码库</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line">git remote add origin https://..../test.git    //将git本地仓库和Github远程仓库关联</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h2 id="已有项目"><a href="#已有项目" class="headerlink" title="已有项目"></a>已有项目</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> exist_git_demo</span><br><span class="line">git remote add origin https://..../test.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p><code>其中origin代表的是你远程的仓库</code></p><h2 id="修改仓库名"><a href="#修改仓库名" class="headerlink" title="修改仓库名"></a>修改仓库名</h2><p>一般来讲，默认情况下，在执行clone或者其他操作时，仓库名都是 origin 如果说我们想给他改改名字，比如我不喜欢origin这个名字，想改为 oschina 那么就要在仓库目录下执行命令:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote rename origin oschina</span><br></pre></td></tr></table></figure><p>这样 你的远程仓库名字就改成了<strong>oschina</strong>，同样，以后推送时执行的命令就不再是 <strong>git push origin master</strong> 而是 <strong>git push oschina master</strong> 拉取也是一样的</p><h2 id="添加一个仓库"><a href="#添加一个仓库" class="headerlink" title="添加一个仓库"></a>添加一个仓库</h2><p>在不执行克隆操作时，如果想将一个远程仓库添加到本地的仓库中，可以执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin 仓库地址</span><br></pre></td></tr></table></figure><p>注意: </p><ol><li>origin是你的仓库的别名 可以随便改，但请务必不要与已有的仓库别名冲突 </li><li>仓库地址一般来讲支持 http/https/ssh/git协议，其他协议地址请勿添加</li></ol><h2 id="查看当前仓库对应的远程仓库地址"><a href="#查看当前仓库对应的远程仓库地址" class="headerlink" title="查看当前仓库对应的远程仓库地址"></a>查看当前仓库对应的远程仓库地址</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>这条命令能显示你当前仓库中已经添加了的仓库名和对应的仓库地址，通常来讲，会有两条一模一样的记录，分别是fetch和push，其中fetch是用来从远程同步 push是用来推送到远程</p><h2 id="修改仓库对应的远程仓库地址"><a href="#修改仓库对应的远程仓库地址" class="headerlink" title="修改仓库对应的远程仓库地址"></a>修改仓库对应的远程仓库地址</h2><figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">git </span><span class="string">remote </span><span class="built_in">set-url</span> <span class="string">origin </span>仓库地址</span><br></pre></td></tr></table></figure><h1 id="公有库开发过程"><a href="#公有库开发过程" class="headerlink" title="公有库开发过程"></a>公有库开发过程</h1><ul><li>fork仓库<ul><li>通常fork公有库的Master分支作为当前的开发分支</li></ul></li><li>提交pr</li><li>pr审核</li><li>pr合并</li></ul><p>fork仓库 -&gt; 提交pr -&gt; pr审核 -&gt; pr合并</p><table><thead><tr><th align="left">1</th><th align="right">2</th></tr></thead><tbody><tr><td align="left">克隆仓库</td><td align="right">git clone https://…..git</td></tr><tr><td align="left">切换到dev分支</td><td align="right">git checkout dev</td></tr><tr><td align="left">创建分支</td><td align="right">git checkout -b [new-feature]</td></tr><tr><td align="left">提交分支</td><td align="right">git push origin [new-feature]</td></tr><tr><td align="left">本地分支合并</td><td align="right">查看分支：git branch <br> 创建分支：git branch <name> <br>切换分支：git checkout <name> <br>创建+切换分支：git checkout -b <name> <br>合并某分支到当前分支：git merge <name> <br>删除分支：git branch -d <name></name></name></name></name></name></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Git基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Hexo搭建个人网站不香吗?</title>
      <link href="/hexo/hexo1/"/>
      <url>/hexo/hexo1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="之前使用的建站工具的心得"><a href="#之前使用的建站工具的心得" class="headerlink" title="之前使用的建站工具的心得"></a>之前使用的建站工具的心得</h2><p><strong>之前在开源博客和CSDN上写过文章。也自己搭建过博客,后面觉得可定制化太差,不灵活,而且成本高,对于个人来说太麻烦。然后准备迁移到使用hexo</strong></p><hr><h2 id="选用hexo的理由"><a href="#选用hexo的理由" class="headerlink" title="选用hexo的理由"></a>选用hexo的理由</h2><ol><li>免费-github</li><li>快速-node运行环境</li><li>简洁-MarkDown</li><li>轻量-全部是静态文件</li><li>丰富主题-在几秒内，即可利用靓丽的主题生成静态网页。</li><li>自己还可以定制化开发</li></ol><hr><h2 id="hexo常用指令"><a href="#hexo常用指令" class="headerlink" title="hexo常用指令"></a>hexo常用指令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用于生成静态文件</span></span><br><span class="line">hexo generate</span><br><span class="line">hexo g <span class="comment">#简写</span></span><br><span class="line"><span class="comment">#情况pubilc文件 </span></span><br><span class="line">hexo clean</span><br><span class="line"><span class="comment">#启动服务预览</span></span><br><span class="line">hexo s</span><br><span class="line">hexo server</span><br><span class="line"><span class="comment">#部署站点，本地生成.deploy_git文件。并建编译后的文件上传至githab</span></span><br><span class="line"><span class="comment">## 新建文章</span></span><br><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line"><span class="comment">## 一键部署</span></span><br><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 建站心得 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
